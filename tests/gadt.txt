data Expr a where
  Zero :: Expr Int
  Succ :: Expr Int -> Expr Int
  Pair :: x -> y -> Expr (x, y)

data PairT (a : *) (b : *) = P a b ; let Int : * = nat in let fst : (a : *) -> (b : *) -> PairT a b -> a = \a : * . \b : * . \p : PairT a b . case p of P (x : a) (y : b) => x in let snd : (a : *) -> (b : *) -> PairT a b -> b = \a : * . \b : * . \p : PairT a b . case p of P (x : a) (y : b) => y in let Expr : * -> * = mu t : * -> * . \a : * . (b : * -> *) -> b Int -> (t Int -> b Int) -> ((x : *) -> (y : *) -> t x -> t y -> b (PairT x y)) -> b a in let Zero : Expr Int = fold 2 [Expr Int] (\b : * -> * . \cx : b Int . \cy : Expr Int -> b Int . \cz : (x : *) -> (y : *) -> Expr x -> Expr y -> b (PairT x y) . cx) in let Succ : Expr Int -> Expr Int = \e : Expr Int . fold 2 [Expr Int] (\b : * -> * . \cx : b Int . \cy : Expr Int -> b Int . \cz : (x : *) -> (y : *) -> Expr x -> Expr y -> b (PairT x y) . cy e) in let Pair : (x : *) -> (y : *) -> Expr x -> Expr y -> Expr (PairT x y) = \x : * . \y : * . \ex : Expr x . \ey : Expr y . fold 2 [Expr (PairT x y)] (\b : * -> * . \cx : b Int . \cy : Expr Int -> b Int . \cz : (x : *) -> (y : *) -> Expr x -> Expr y -> b (PairT x y) . cz x y ex ey) in let eval : (a : *) -> Expr a -> a = mu f : (a : *) -> Expr a -> a . \a : * . \e : Expr a . unfold 1 ((unfold 2 e) (\x : * . x) (fold 1 [(\x : * . x) Int] 0) (\e' : Expr Int . fold 1 [(\x : * . x) Int] (1 + (f Int e'))) (\x : * . \y : * . \ex : Expr x . \ey : Expr y . fold 1 [(\x : * . x) (PairT x y)] (P x y (f x ex) (f y ey)))) in let testPair : Expr (PairT Int Int) = Pair Int Int (Succ (Succ Zero)) (Succ Zero) in fst Int Int (eval (PairT Int Int) testPair)
