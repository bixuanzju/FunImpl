\section{Explicit Calculus of Constructions with Recursion}\label{sec:core}

In this section, we present the core language \name, namely the explicit Calculus of Constructions with recursion, a dependently typed intermediate language with general recursion. \name is carefully designed to be minimal enough for simplifying type checking and meta-theoretic studying, while still keeps the expressiveness to represent rich high-level constructions (\S \ref{sec:src}). By explicitly controlling the type-level computation with $\kw{cast}$ primitives, \name can safely allow non-termination without breaking the decidability of type checking. In rest of this section, we demonstrate the syntax (\S \ref{sec:core:syn}), type system (\S \ref{sec:core:type}) and meta-theories (\S \ref{sec:core:meta}) of \name.

\subsection{Syntax}\label{sec:core:syn}
Figure \ref{fig:core:syntax} shows the syntax of \name, including expressions, contexts and values. The syntax is similar to \cc and straightforward to understand, while there are still some differences that embody the simplicity and expressiveness of \name:

\subsubsection{Unified syntactic levels}
\name uses a unified syntactic representation for different levels of expressions by following the \emph{pure type system} (PTS) representation of \cc. Traditionally in \cc, there are two distinct sorts $[[star]]$ and $[[square]]$ representing the type of \emph{types} and \emph{sorts} respectively, and an axiom $[[star]]:[[square]]$ specifying the relation. In \name, we further merge types and kinds together by including only a single sort $[[star]]$ and an impredicative axiom $[[star]]:[[star]]$. 

Therefore, there is no syntactic distinction between terms, types or kinds. This design brings the economy for type checking, since one set of rules can cover all syntactic levels. By convention, we use metavariables $[[t]]$ and $[[T]]$ for an expression on the type-level position and $e$ for one on the term level.

\subsubsection{Dependent function types}
In the context of \cc, if a term $[[x]]$ has the type $[[t1]]$, and $[[t2]]$ is a type, i.e. $[[x]]:[[t1]]:[[star]]$ and $[[t2]]:[[square]]$, we call the type $[[Pi x:t1.t2]]$ a \emph{dependent product}. \name follows \cc to use the same $[[Pi]]$-notation to represent dependent function types.

However, a higher-kind polymorphic function type such as $[[Pi x:square.x->x]]$ is not allowed in \cc, because $[[square]]$ does not have a type and $[[t1]]=[[square]]$ can not be typed in $[[Pi x:t1.t2]]$.  $[[Pi]]$-notation in \name is more expressive and does not have such limitation because of the axiom $[[star]]:[[star]]$. Moreover, we interchangeably use the arrow form $[[(x:t1)->t2]]$ for the product in the source language for distinction. By convention, we also use the syntactic sugar $[[t1 --> t2]]$ to represent the product if $[[x]]$ does not occur free in $[[t2]]$.

\subsubsection{General recursion}
We use the polymorphic recursion operator $[[mu]]$ to represent general recursion on both term and type level in the same form $[[mu x:t.e]]$. On the term level, a $[[mu]]$-term has the similar functionality as a fixpoint, that its unfolding $[[e [x |-> mu x:t.e] ]]$ can be achieved by $\beta$-reduction \fixme{(See examples in \S \ref{sec:})}. On the type level, $[[mu x:t.e]]$ represents recursive types and uses the \emph{iso-recursive} approach, that the recursive type is not equal but only isomorphic to its unfolding.

\subsubsection{Explicit type conversion}
We introduce two new primitives $[[castup]]$ and $[[castdown]]$ (pronounced as "cast up" and "cast down") to replace implicit conversion rule of \cc with explicit type conversion. They represent two directions of type conversion: $[[castdown]]$ stands for the $\beta$-reduction of types, while $[[castup]]$ is the inverse \fixme{(See examples in \S \ref{sec:})}. $[[castup]]$ and $[[castdown]]$ also serve as the $\kw{fold}$ and $\kw{unfold}$ for iso-recursive types to map back and forth between the original and unrolled form (\S \ref{sec:core:type}).

Though $\kw{cast}$ primitives make the syntax verbose when type conversion is heavily used, the implementation of type checking is simplified because typing rules of \name are type-directed without \cc's implicit conversion rule. Considering the core language is compiler-oriented and \fixme{source language does not include $\kw{cast}$ primitives}, end-users will not directly use them. Some type conversions can be generated through the translation of the source language \fixme{(\S \ref{sec:src})}.

\begin{figure}
    \gram{\otte\ottinterrule
        \ottG\ottinterrule
        \ottv}
    \caption{Syntax of \name}
    \label{fig:core:syntax}
\end{figure}

\subsection{Type system}\label{sec:core:type}
The type system for the core language includes operational semantics and typing judgements. Typing judgements include rules of context well-formedness $[[|- G]]$ and expression typing $[[G |- e : t]]$. Note that there is only a single set of rules for expression typing, because of no distinction of different syntactic levels.

\subsubsection{Operational semantics}
The operational semantics is given by Figure \ref{fig:core:opsem}. Because of the polymorphic recursive term, the \emph{call-by-name}   style of reduction rules.

\begin{figure}
    \ottdefnstep{}
    \caption{Operational semantics of \name}
    \label{fig:core:opsem}
\end{figure}

\subsubsection{Expression typing}
Figure \ref{fig:core:typing} gives the typing rules of expressions. 


\begin{figure}
    \ottdefnctx{}
    \ottdefnexpr{}
    \caption{Typing rules of \name}
    \label{fig:core:typing}
\end{figure}

\subsection{Meta-theories}\label{sec:core:meta}
