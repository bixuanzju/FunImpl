\section{The core language}\label{sec:core}

In this section, we present \name calculus, the core language with explicit type-level computation. \name is carefully designed to be minimal enough for simplifying type checking and meta-theoretic studying, while still keeps the expressiveness to represent rich high-level constructions (\S \ref{sec:src}). By explicitly controlling the type-level computation with $\kw{cast}$ operators, \name can safely allow non-termination without breaking the decidability of type checking. In rest of this section, we demonstrate the syntax (\S \ref{sec:core:syn}), type system (\S \ref{sec:core:type}) and meta-theories (\S \ref{sec:core:meta}) of \name.

\subsection{Syntax}\label{sec:core:syn}
Figure \ref{fig:core:syntax} shows the syntax of \name, including expressions, contexts and values. The syntax follows \cc and straightforward to understand, while there are still some differences that embody the simplicity and expressiveness of \name.

\subsubsection{Unified syntactic levels}
\name uses a unified syntactic representation for different levels of expressions by following the \emph{pure type system} (PTS) representation of \cc. Traditionally in \cc, there are two distinct sorts $[[star]]$ and $[[square]]$ representing the type of \emph{types} and \emph{sorts} respectively, and an axiom $[[star]]:[[square]]$ specifying the relation. In \name, we further merge types and kinds together by including only a single sort $[[star]]$ and an impredicative axiom $[[star]]:[[star]]$. 

Therefore, there is no syntactic distinction between terms, types or kinds. This design brings the economy for type checking, since one set of rules can cover all syntactic levels. By convention, we use metavariables $[[t]]$ and $[[T]]$ for an expression on the type-level position and $e$ for one on the term level.

\subsubsection{Dependent function types}
In the context of \cc, if a term $[[x]]$ has the type $[[t1]]$, and $[[t2]]$ is a type, i.e. $[[x]]:[[t1]]:[[star]]$ and $[[t2]]:[[square]]$, we call the type $[[Pi x:t1.t2]]$ a \emph{dependent product}. \name follows \cc to use the same $[[Pi]]$-notation to represent dependent function types.

However, a higher-kind polymorphic function type such as $[[Pi x:square.x->x]]$ is not allowed in \cc, because $[[square]]$ is the highest sort that can not be typed. While $[[Pi]]$-notation in \name is more expressive and does not have such limitation because of the axiom $[[star]]:[[star]]$. In the source language, we interchangeably use the arrow form $[[(x:t1)->t2]]$ of the product for clarity. By convention, we also use the syntactic sugar $[[t1 --> t2]]$ to represent the product if $[[x]]$ does not occur free in $[[t2]]$.

\subsubsection{General recursion}
We use the polymorphic recursion operator $[[mu]]$ to represent general recursion on both term and type level in the same form $[[mu x:t.e]]$. On the term level, a $[[mu]]$-term has the similar functionality as a fixpoint, that its unfolding $[[e [x |-> mu x:t.e] ]]$ can be achieved by one-step reduction \fixme{(See examples in \S \ref{sec:})}. On the type level, $[[mu x:t.e]]$ represents recursive types and uses the \emph{iso-recursive} approach, that the recursive type is not equal but only isomorphic to its unrolling.

\subsubsection{Explicit type conversion}
We introduce two new primitives $[[castup]]$ and $[[castdown]]$ (pronounced as "cast up" and "cast down") to replace implicit conversion rule of \cc with one-step explicit type conversion. They represent two directions of type conversion: $[[castdown]]$ stands for the $\beta$-reduction of types, while $[[castup]]$ is the inverse \fixme{(see examples in \S \ref{sec:})}. $[[castup]]$ and $[[castdown]]$ also serve as the $\kw{fold}$ and $\kw{unfold}$ for iso-recursive types to map back and forth between the original and unrolled form (\S \ref{sec:core:type}).

Though $\kw{cast}$ primitives make the syntax verbose when type conversion is heavily used, the implementation of type checking is simplified because typing rules of \name become type-directed without \cc's implicit conversion rule. Considering the core language is compiler-oriented and \fixme{source language does not include $\kw{cast}$ primitives}, end-users will not directly use them. Some type conversions can be generated through the translation of the source language \fixme{(\S \ref{sec:src})}.

\begin{figure}
    \gram{\otte\ottinterrule
        \ottG\ottinterrule
        \ottv}
    \caption{Syntax of \name}
    \label{fig:core:syntax}
\end{figure}

\subsection{Type system}\label{sec:core:type}
The type system for the core language includes operational semantics and typing judgements. Typing judgements include rules of context well-formedness $[[|- G]]$ and expression typing $[[G |- e : t]]$. Note that there is only a single set of rules for expression typing, because of no distinction of different syntactic levels.

\subsubsection{Operational semantics}
Figure \ref{fig:core:opsem} shows the \emph{call-by-name} operational semantics, defined by one-step reduction relations, namely $[[-->]]$. Three base cases include \ruleref{S\_Beta} for $\beta$-reduction, \ruleref{S\_Mu} for recursion unrolling and \ruleref{S\_CastDownUp} for cast canceling. Two inductive case, \ruleref{S\_App} and \ruleref{S\_CastDown}, define reduction in the head position of an application, and in the $[[castdown]]$ inner expression respectively.

The reduction rules are \emph{weak} in the sense that it is not allowed to reduce inside a $\lambda$-term or $[[castup]]$-term which are viewed as a value (see Figure \ref{fig:core:syntax}) that ends the reduction. Note that we do not treat the $[[mu]]$-term as a value, which is different from conventional iso-recursive types. Because on the term level, the $[[mu]]$ operator is treated as a fixpoint. The $[[mu]]$-term is equivalent to a recursive function that should be allowed to unroll without restriction.

\begin{figure}
    \ottdefnstep{}
    \caption{Operational semantics of \name}
    \label{fig:core:opsem}
\end{figure}

\subsubsection{Expression typing}
Figure \ref{fig:core:typing} gives the \emph{syntax-directed} typing rules of valid context and expression. Most typing rules are quite standard. We write $[[|- G]]$ if a context $[[G]]$ is well-formed. Since there is only a single sort $[[star]]$, $[[G |- t : star]]$ is used in rules to check if $[[t]]$ is a well-formed type. Rule \ruleref{T\_Ax} is the "type-in-type" axiom. Rule \ruleref{T\_Var} checks the type of variable $[[x]]$ from the valid context. Rules \ruleref{T\_App} and \ruleref{T\_Lam} check the validity of application and abstraction. Rules \ruleref{T\_Pi} and \ruleref{T\_Mu} check the type well-formedness of the dependent function and polymorphic recursion. Rule \ruleref{T\_Mu} indicates that the polymorphic recursion $[[mu x:t.e]]$ should have the same type $[[t]]$ as the binder $[[x]]$ and the body $[[e]]$.

Rules \ruleref{T\_CastUp} and \ruleref{T\_CastDown} deal with the explicit type conversion. They differ from the conventional implicit type conversion rule (see \ref{}) in \cc: $\kw{cast}$ rules are syntax-directed and only perform \emph{one-step} type conversion for every $\kw{cast}$ operator. Specifically speaking, if given $[[G |- e : t2]]$ and $[[t1 --> t2]] [[-->]] [[t3]]$, then $[[castup [t1] e]]$ expands the type of $[[e]]$ from $[[t2]]$ to $[[t1]]$, while $[[castdown e]]$ reduces the type of $[[e]]$ from $[[t2]]$ to $[[t3]]$. 

Giving up the implicit conversion rule means that we do not have $\beta$-equality but only have \emph{syntactical equality} (or $\alpha$-equality) for types in \name. By limiting the reduction relation to only one step, evaluating type-level recursive terms is fully controlled by the $\kw{cast}$ operators: the number of evaluation steps of is equal to the number of $\kw{cast}$ operators, which is finite. Thus, this prevents the type checker from looping forever when evaluating recursive terms.

Finally, we look back at the polymorphic recursion $[[mu x:t.e]]$ again. If it appears on the term level, the reduction rule \ruleref{S\_Mu} makes the $[[mu]]$-operator behave like a fixpoint. Because evaluating $[[mu x:t.e]]$ obtains its unrolling $[[e [x |-> mu x:t.e] ]]$, i.e. substituting all $[[x]]$ in $e$ with the whole $[[mu]]$-term itself, just like a fixpoint. If the recursion appears on the type level, assume there exist expressions $[[e1]]$ and $[[e2]]$ such that 
\[\begin{array}{lll}
	&[[e1]] &: [[mu x:t.e]]\\
	&[[e2]] &: [[e [x |-> mu x:t.e] ]]
\end{array}\]
Note that $[[e1]]$ and $[[e2]]$ have distinct types but the type of $[[e2]]$ is the unrolling of $[[e1]]$'s type, which follows the one-step reduction relation by rule \ruleref{S\_Mu}:
\[ [[mu x:t.e --> e [x |-> mu x:t.e] ]] \]
 Thus, by applying rules \ruleref{T\_CastUp} and \ruleref{T\_CastDown}, we can obtain the following typing results:
\[\begin{array}{lll}
	&[[castdown e1]] &: [[e [x |-> mu x:t.e] ]]\\
	&[[castup [mu x:t.e] e2]] &: [[mu x:t.e]]
\end{array}\]
Thus, $[[castup]]$ and $[[castdown]]$ witness the isomorphism between the original recursive type and its unrolling, which behave the same as $\kw{fold}$ and $\kw{unfold}$ operations in iso-recursive types.

\begin{figure}
    \ottdefnctx{}
    \ottdefnexpr{}
    \caption{Typing rules of \name}
    \label{fig:core:typing}
\end{figure}

\subsection{Meta-theory}\label{sec:core:meta}
We now discuss the meta-theory of \name. We focus on two properties: the decidability of type checking and the type-safety of the language. First, we want to show type checking \name is decidable without normalizing property. And the type checker will never be stuck by type-level non-termination. Second, the core language is type safe, or sound, proven by standard subject reduction and progress lemmas.

\subsubsection{Decidability of type checking}

\subsubsection{Type safety}
