%%% !!! WARNING: AUTO GENERATED. DO NOT MODIFY !!! %%%
\newcommand{\FV}{\mathsf{FV}}
\newcommand{\dom}{\mathsf{dom}}

\section{Surface language}
\label{sec:surface}

% \begin{itemize}
% \item Expand the core language with datatypes and pattern matching by encoding.
% \item Give translation rules.
% \item Encode GADTs and maybe other Haskell extensions? GADTs seems challenging, so perhaps some other examples would be datatypes like $Fix f$, and $Monad$ as a record. Could formalize records in Haskell style.
% \end{itemize}

In this section, we present a surface language built on top of \name with
features that are convenient for functional programming: user-defined
datatypes, and pattern matching. Thanks to the expressiveness of
\name, all these features can be elaborated into the core language
without extending the built-in language constructs of \name. In what
follows, we first give the syntax of the surface language, followed by
the extended typing rules, then we show the formal translation rules
that translates a surface language expression to an expression in
\name. Finally we prove the type-safety of the translation.

\subsection{Extended Syntax}

% \newcommand{\case}{\mathbf{case}} \newcommand{\of}{\mathbf{of}}
% \newcommand{\data}{\mathbf{data}} \newcommand{\where}{\mathbf{where}}
% \newcommand{\letbb}{\mathbf{let}} \newcommand{\inb}{\mathbf{in}}

The full syntax of the surface language is defined in Figure~\ref{fig:surface:syntax}. Compared with \name, the surface language has a new syntax category: a program, consisting of a list of datatype declarations, followed by a expression. An \emph{algebraic data type} $D$ is introduced as a top-level \textbf{data} declaration with its \emph{data constructors}. For the purpose of presentation, we sometimes adopt the following syntactic convention:
\[
\overline{\tau}^n \rightarrow \tau_r \equiv \tau_1 \rightarrow \dots \rightarrow \tau_n \rightarrow \tau_r
\]
The type of a data constructor $K$ has the form:
\[
\ottmv{K}  \ottsym{:}  \ottsym{(}  \,\overline{  \ottnt{u}  \ottsym{:}  \kappa  }\,  \ottsym{)}  \rightarrow  \,\overline{  T  }\,  \rightarrow  \ottmv{D}    \,\overline{  \ottnt{u}  }\,
\]
\bruno{this looks a bit odd for a number of reasons: firstly why to
  insist on having the quantified variables in the same order as the
  arguments in the constructor? Secondly it seems that all other
  arguments cannot be dependently typed? 
It seems to me that 
\[
\ottmv{K}  \ottsym{:}  \ottsym{(}  \,\overline{  \ottmv{x}  \ottsym{:}  \kappa  }\,  \ottsym{)}  \rightarrow  \ottmv{D}    \,\overline{  \ottnt{u}  }\,
\]
where all variables $u$ are bound ($u \in \overline{x}$) would be
better. 
}
The quantified type variables $\,\overline{  \ottnt{u}  }\,$ appear in the same order in
the return type $\ottmv{D}    \,\overline{  \ottnt{u}  }\,$. Note that the use of dependent product
to tie together the type constructor arguments ($\ottsym{(}  \,\overline{  \ottnt{u}  \ottsym{:}  \kappa  }\,  \ottsym{)}$) makes
it possible to let the type of some type constructor arguments depend
on other type constructor arguments. The \textbf{case} expression is
conventional, used to break up values built with data constructors.
The patterns of a case expression are flat (no nested patterns), and
bind value variables.

\begin{figure*}
\centering
\gram{\ottpgm\ottinterrule
\ottdecl\ottinterrule
\ottu\ottinterrule
\ottp\ottinterrule
\ottE\ottinterrule
\ottV\ottinterrule
\ottGs}
    \[
    \begin{array}{lllll}
     &&&& \text{Syntactic Sugar} \\
     T_{{\mathrm{1}}}  \rightarrow  T_{{\mathrm{2}}} & \triangleq & \Pi \, \ottmv{x}  \ottsym{:}  T_{{\mathrm{1}}}  \ottsym{.}  T_{{\mathrm{2}}} & x \not \in \FV(T_{{\mathrm{2}}}) & \quad\text{Function type} \\
     \ottsym{(}  \ottmv{x}  \ottsym{:}  T_{{\mathrm{1}}}  \ottsym{)}  \rightarrow  T_{{\mathrm{2}}} & \triangleq & \Pi \, \ottmv{x}  \ottsym{:}  T_{{\mathrm{1}}}  \ottsym{.}  T_{{\mathrm{2}}} & x \in \FV(T_{{\mathrm{2}}}) & \quad\text{Dependent function type} \\
     \kw{data} \, \ottmv{R}  \,\overline{  \ottnt{u}  \ottsym{:}  \kappa  }\,  \ottsym{=}  \ottmv{K}  \ottsym{\{}  \,\overline{  \ottmv{N}  \ottsym{:}  T  }\,  \ottsym{\}} & \triangleq &
                    \kw{data} \, \ottmv{R}  \,\overline{  \ottnt{u}  \ottsym{:}  \kappa  }\,  \ottsym{=}  \ottmv{K}  \,\overline{  T  }\,; && \quad\text{Record} \\
                  &&  \kw{let} ~\ottmv{N}_i : \ottsym{(}  \,\overline{  \ottnt{u}  \ottsym{:}  \kappa  }\,  \ottsym{)}  \rightarrow  \ottmv{R}    \,\overline{  \ottnt{u}  }\,  \rightarrow  T_i = & \forall i &  \\
                  && \lambda  \,\overline{  \ottnt{u}  \ottsym{:}  \kappa  }\,  \ottsym{.}  \lambda  \ottmv{y}  \ottsym{:}  \ottmv{R} \, \,\overline{  \ottnt{u}  }\,  \ottsym{.}  \kw{case} \, \ottmv{y} \, \kw{of} \, \ottmv{K}  \,\overline{  \ottmv{x}  \ottsym{:}  T  }\,  \Rightarrow  \ottmv{x}_i~ \kw{in}  && \\
    \end{array}
    \]
\caption{Syntax of the surface language}
\label{fig:surface:syntax}
\end{figure*}


% \begin{figure}[ht]
% \centering
% \small
% \[
%   \begin{array}{llll}
%     \textbf{Declarations} \\
%     pgm &::= & \overline{decl}; e & \text{Declarations} \\
%     decl &::= & \data\,D\,\overline{u : \kappa} = \overline{\mid K\,\overline{\tau}} & \text{Datatype} \\ \\
%     \textbf{Terms} \\
%     u &::= & x \mid K & \text{Variables and constructors} \\
%     e,\tau,\sigma,\upsilon,\kappa &::= & u & \text{Term atoms} \\
%     & & \dots \\
%     & \mid & \case\,e\,\of\,\overline{p \Rightarrow e} & \text{Case analysis} \\
%     p &::= & K\,\overline{x : \tau} & \text{Pattern} \\ \\
%     \textbf{Environments} \\
%     \Gamma &::= &\varnothing & \text{Empty} \\
%     & \mid & \Gamma,u:\tau & \text{Variable binding}
%   \end{array}
% \]
%   \caption{Syntax of \sufcc ($e$ for terms; $\tau,\sigma,\upsilon$ for types; $\kappa$ for kinds)}\label{fig:datasyn}
% \end{figure}

For the sake of programming, the surface language employs some
syntactic sugar. A non-dependent function type can be written as
$T_{{\mathrm{1}}}  \rightarrow  T_{{\mathrm{2}}}$. A dependent function type $\Pi \, \ottmv{x}  \ottsym{:}  T_{{\mathrm{1}}}  \ottsym{.}  T_{{\mathrm{2}}}$ is
abbreviated as $\ottsym{(}  \ottmv{x}  \ottsym{:}  T_{{\mathrm{1}}}  \ottsym{)}  \rightarrow  T_{{\mathrm{2}}}$ for easy reading. We also
introduce a Haskell-like record syntax, which is desugared to
datatypes with accompanying selector functions.

% \begin{figure}[ht]
% \centering
% \[
%   \begin{array}{l}
%     \data\,R\,\overline{u : \kappa} = K\,\{\,\overline{S:\tau}\,\} \triangleq \\
%     \data\,R\,\overline{u : \kappa} = K\,\overline{\tau} \\
%     \letbb\,S_{i} : \Pi \overline{u : \kappa}.R\,\overline{u} \rightarrow \tau_{i} = \\
%     \quad \lambda \overline{(u:\kappa)}.\lam{l}{R\,\overline{u}}{\case\,l\,\of\, K\,\overline{x:\tau} \Rightarrow x_{i}} \\
%     \inb
%   \end{array}
% \]
% \caption{Syntactic sugar for records}\label{fig:records}
% \end{figure}

\subsection{Extended Typing Rules}
\bruno{For typing and translation show only one figure (Figure 8), since the
  typing figure is just a subset. We can use gray to highlight the
  parts which belong to the translation.}

Figure~\ref{fig:surface:typing} defines the type system of the surface
language. Several new typing judgments appear in the type system. The
use of different subscripts of the judgments is to be distinct from
the one used in \name. Most rules of the type system are standard for
systems based on \coc, including the rules for the well-formedness of
contexts (\ruleref{EnvS\_Empty}, \ruleref{EnvS\_Var}), inferring the
types of variables (\ruleref{TS\_Var}), and dependent application
(\ruleref{TS\_App}). Two judgments $ \Sigma  \labeledjudge{pg}  \ottnt{pgm}  :  T $ and
$ \Sigma  \labeledjudge{d}  \ottnt{decl}  :  \Sigma' $ are of the essence to the type checking of the
surface language. The former type checks a whole program, and the
latter type checks datatype declarations.

Rule \ruleref{TSpgm\_Pgm} type checks a whole program. It first
type-checks the declarations, which in return gives a new typing
environment. Combined with the original environment, it then continues
to type check the expression and return the result type. Rule
\ruleref{TSpgm\_Data} is used to type check datatype declarations. It
first ensures the well-formedness of the type of the type constructor
application (of kind $\star$). Note that since our system adopts
$\star : \star$, this means we can express kind polymophism in the
type parameters. Finally it make sure the types of data constructors
are valid.

Rules \ruleref{TS\_Case} and \ruleref{Tpat\_Alt} handle the type
checking of case expressions. The conclusion of \ruleref{TS\_Case}
binds the right types to the scrutinee expression $\ottnt{E_{{\mathrm{1}}}}$ and
alternatives $\overline{p \Rightarrow E_2}$. The first premise of
\ruleref{Tpat\_Alt} binds the actual type constructor arguments to
$\,\overline{  \ottnt{u}  }\,$. The second premise checks whether the types of the
right-hand sides of each alternative, instantiated to the actual type
constructor arguments $\,\overline{  \ottnt{u}  }\,$, are equal. Finally the third
premise checks the well-formedness of the types of data constructor
arguments.
\bruno{Mention that we do not support refinement, as in GADTs?}

\begin{figure*}
\ottdefnctxsrc{}
\ottdefnpgmsrc{}
\ottdefndeclsrc{}
\ottdefnpatsrc{}
\ottdefnexprsrc{}
\caption{Typing rules of surface language}
\label{fig:surface:typing}
\end{figure*}

% \newcommand{\ctx}[2][\Gamma]{#1 \vdash #2}
% \newcommand{\ctxz}[1]{\ctx[\varnothing]{#1}}
% \newcommand{\ctxw}[3][\Gamma]{#1,#2 \vdash #3}

% \begin{figure*}
%   \centering \small
%   \begin{tabular}{lc}
%     \framebox{$\Gamma \vdash pgm : \tau$} \\
%     (Pgm) & $\inferrule {\overline{\Gamma_{0} \vdash decl : \Gamma_{d}} \\ \Gamma = \Gamma_{0}, \overline{\Gamma_{d}} \\ \ctx{e:\tau}} {\Gamma_{0} \vdash \overline{decl}; e : \tau}$ \\
%     \framebox{$\Gamma \vdash decl : \Gamma_d$} \\
%     (Data) & $\inferrule {\Gamma \vdash \overline{\kappa} \rightarrow \star : \square \\ \overline{\Gamma, D:\overline{\kappa} \rightarrow \star, \overline{u : \kappa} \vdash \overline{\tau} \rightarrow D\,\overline{u}:\star}} {\ctx{(\data\,D\,\overline{u : \kappa} = \overline{\mid K\,\overline{\tau}}): (D : \overline{\kappa} \rightarrow \star, \overline{K : \Pi\overline{u : \kappa}.\overline{\tau} \rightarrow D\,\overline{u}})}}$ \\
%     \framebox{$\Gamma \vdash e : \tau$} \\
%     (Case) & $\inferrule {\ctx{e_{1}}:\sigma \\ \overline{\Gamma\vdash_{p} p \Rightarrow e_{2}:\sigma \rightarrow \tau}} {\Gamma\vdash\case\,e_{1}\,\of\,\overline{p \Rightarrow e_{2}}:\tau}$ \\
%     \framebox{$\Gamma \vdash_{p} p \Rightarrow e : \sigma \rightarrow \tau$} \\
%     (Alt) & $\inferrule {\theta=[\overline{u := \upsilon}] \\\\ K:\Pi\overline{u:\kappa}.\,\overline{\sigma} \rightarrow D\,\overline{u} \in \Gamma \\ \Gamma,\overline{x:\theta(\sigma)} \vdash e:\tau} {\Gamma \vdash_{p} K\,\overline{x:\theta(\sigma)} \Rightarrow e : D\,\overline{\upsilon} \rightarrow \tau}$
%   \end{tabular}
%   \caption{Typing rules of \sufcc}\label{fig:datatype}
% \end{figure*}

\subsection{Translation Overview}

We use a type-directed translation. The basic translation rules have the form:
\[
 \Sigma  \labeledjudge{s}  \ottnt{E}  :  T   \rightsquigarrow   \ottnt{e} 
\]

It states that \name expression $\ottnt{e}$ is the translation of the
surface expression $\ottnt{E}$ of type $T$.
Figure~\ref{fig:source:translate} defines the translation rules, which
are the typing rules in Figure~\ref{fig:surface:typing} extended with
the resulting expression $\ottnt{e}$. In the translation, we require that
applications of constructors to be \emph{saturated}.\bruno{Any
  partiular reasons for this?}

Among others, Rules \ruleref{TRdecl\_Data}, \ruleref{TRpat\_Alt} and \ruleref{TR\_Case} are of the essence to the translation. Rule \ruleref{TR\_Case} translates case expressions into applications by first translating the scrutinee expression, casting it down to the right type. It is then applied to the result type of the body expression and a list of translated \name expressions of its alternatives. Rule \ruleref{TRpat\_Alt} tells how to translate each alternative. Basically it translates an alternative into a lambda abstraction, where each bound variable in the pattern corresponds to a bound variable in the lambda abstraction in the same order. The body in the alternative is recursively translated and treated as the body of the lambda abstraction.

Rule \ruleref{TRDecl\_Data} does the most heavy work and deserves further explanation. First of all, it results in an incomplete expression (as can be seen by the incomplete \emph{let} expressions), The result expression is supposed to be prepended to the translation of the last expression to form a complete \name expression, as specified by Rule \ruleref{TRpgm\_Pgm}. Furthermore, each type constructor is translated to a recursive type, of which the body is a type-level lambda abstraction. What is interesting is that each recursive mention of the datatype in the data constructor parameters is replaced with the recursive variable $\ottmv{X}$. Note that for the moment, the result type variable $\alpha$ is restricted to have kind $\star$. This could pose difficulties when translating GADTs as we will discussion in the future work. Each data constructor is translated to a lambda abstraction. Notice how we use \castup in the lambda body to get the right type.

The rest of the translation rules hold few surprises.

\begin{figure*}
\ottdefnctxtrans{}
\ottdefnpgmtrans{}
\ottdefndecltrans{}
\begin{align*}
\ottnt{e}  \triangleq ~  &  \kw{let} \, \ottmv{D}  \ottsym{:}  \ottsym{(}  \,\overline{  \ottnt{u}  \ottsym{:}  \sigma  }\,  \ottsym{)}  \rightarrow  \star  \ottsym{=}  \mu \, \ottmv{X}  \ottsym{:}  \ottsym{(}  \,\overline{  \ottnt{u}  \ottsym{:}  \sigma  }\,  \ottsym{)}  \rightarrow  \star  \ottsym{.}  \lambda  \,\overline{  \ottnt{u}  \ottsym{:}  \sigma  }\,  \ottsym{.}  \ottsym{(}  \alpha  \ottsym{:}  \star  \ottsym{)}  \rightarrow  \,\overline{  \ottsym{(}  \,\overline{  \tau  }\,  \ottsym{[}  \ottmv{D}  \mapsto  \ottmv{X}  \ottsym{]} \,  \rightarrow  \alpha  \ottsym{)}  }\,  \rightarrow  \alpha \, \kw{in} \, \\ &  \kw{let} \, \ottmv{K_{\ottmv{i}}}  \ottsym{:}  \ottsym{(}  \,\overline{  \ottnt{u}  \ottsym{:}  \sigma  }\,  \ottsym{)}  \rightarrow  \,\overline{  \tau  }\,  \rightarrow  \ottmv{D}    \,\overline{  \ottnt{u}  }\,  \ottsym{=}  \lambda  \,\overline{  \ottnt{u}  \ottsym{:}  \sigma  }\,  \ottsym{.}  \lambda  \,\overline{  \ottmv{x}  \ottsym{:}  \tau  }\,  \ottsym{.}  \kw{cast}_{\uparrow}^n \, \ottsym{[}  \ottmv{D}    \,\overline{  \ottnt{u}  }\,  \ottsym{]} \,  \ottsym{(}  \lambda  \alpha  \ottsym{:}  \star  \ottsym{.}  \lambda  \,\overline{  b  \ottsym{:}  \,\overline{  \tau  }\,  \rightarrow  \alpha  }\,  \ottsym{.}  b_{\ottmv{i}} \, \,\overline{  \ottmv{x}  }\,  \ottsym{)} \, \kw{in} \, 
\end{align*}
\ottdefnpattrans{}
\ottdefnexprtrans{}
\caption{Translation rules of source language}
\label{fig:source:translate}
\end{figure*}

\subsection{Type-safefy of Translation}

\jeremy{put Linus's theorem here}

% \begin{figure*}
%   \renewcommand{\arraystretch}{2.5}
%   \centering \small
%   \begin{tabular}{lcl}
%     \framebox{$\Gamma \vdash e : \tau \rightsquigarrow E$} \\
%     (Ax) & $\inferrule { } {\ctxz{\star:\square \rightsquigarrow \star}}$ \\

%     (Var) & $\inferrule {x:\tau \in \Gamma} {\ctx{x:\tau \rightsquigarrow x}}$ \\

%     (App) & $\inferrule {\ctx{e_{1}:(\pai{x}{\tau_{2}}{\tau_{1}}) \rightsquigarrow E_{1}} \\ \ctx{e_{2}:\tau_{2} \rightsquigarrow E_{2}}} {\ctx{e_{1}e_{2}:\tau_{1}[x:=e_{2}] \rightsquigarrow E_{1}E_{2}}}$ \\

%     (Lam) & $\inferrule {\ctxw{x:\tau_{1}}{e:\tau_{2} \rightsquigarrow E} \\ \ctx{(\pai{x}{\tau_{1}}{\tau_{2}}):t}} {\ctx{(\lam{x}{\tau_{1}}{e})}:(\pai{x}{\tau_{1}}{\tau_{2}}) \rightsquigarrow \lam{x}{\tau_{1}}{E}}$ & $t \in \{\star, \square\}$ \\

%     (Pi) & $\inferrule {\ctx{\tau_{1}:s} \\ \ctxw{x:\tau_{1}}{\tau_{2}:t}} {\ctx{(\pai{x}{\tau_{1}}{\tau_{2}}):t \rightsquigarrow \pai{x}{\tau_{1}}{\tau_{2}}}}$ & $(s,t) \in \mathcal{R}$ \\

%     (Mu) & $\inferrule {\ctxw{x:\tau}{e:\tau} \rightsquigarrow E \\ \ctx{\tau:s}} {\ctx{(\miu{x}{\tau}{e}):\tau} \rightsquigarrow \miu{x}{\tau}{E}}$ & $s \in \{\star, \square\}$ \\

%     (Fold) & $\inferrule {\ctx{e:\tau_{2} \rightsquigarrow E} \\ \ctx{\tau_{1}:s} \\ \tau_{1} \longrightarrow \tau_{2}} {\ctx{(\fold{{\tau_{1}}}{e}):{\tau_{1}} \rightsquigarrow \fold{\tau_{1}}{E}}}$ \\

%     (Unfold) & $\inferrule {\ctx{e:\tau_{1} \rightsquigarrow E} \\ \ctx{\tau_{2}:s} \\ \tau_{1} \longrightarrow \tau_{2}} {\ctx{(\unfold{e}):\tau_{2} \rightsquigarrow \unfold{E}}}$ \\

%     (Case) & $\inferrule {\ctx{e_{1}:\sigma \rightsquigarrow E_{1}} \\ \overline{\Gamma\vdash_{p} p \Rightarrow e_{2}:\sigma \rightarrow \tau \rightsquigarrow E_{2}}} {\Gamma\vdash\case\,e_{1}\,\of\,\overline{p \Rightarrow e_{2}}:\tau \rightsquigarrow (\unfold{E_{1}})\,\tau\,\overline{E_{2}}}$ \\
%     \framebox{$\Gamma \vdash_{p} p \Rightarrow e : \sigma \rightarrow \tau \rightsquigarrow E$} \\
%     (Alt) & $\inferrule {\theta=[\overline{u := \upsilon}] \\\\ K:\Pi\overline{u:\kappa}.\,\overline{\sigma} \rightarrow D\,\overline{u} \in \Gamma \\ \Gamma,\overline{x:\theta(\sigma)} \vdash e:\tau \rightsquigarrow E} {\Gamma \vdash_{p} K\,\overline{x:\theta(\sigma)} \Rightarrow e : D\,\overline{\upsilon} \rightarrow \tau \rightsquigarrow \lambda(\overline{x:\theta(\sigma)}).E}$ \\
%     \framebox{$\Gamma \vdash decl : \Gamma_d \rightsquigarrow E$} \\
%     (Data) & $\inferrule {\Gamma \vdash \overline{\kappa} \rightarrow \star : \square \\ \overline{\Gamma, D:\overline{\kappa} \rightarrow \star, \overline{u : \kappa} \vdash \overline{\tau} \rightarrow D\,\overline{u}:\star}} {\ctx{(\data\,D\,\overline{u : \kappa} = \overline{\mid K\,\overline{\tau}}): (D : \overline{\kappa} \rightarrow \star, \overline{K : \Pi\overline{u : \kappa}.\overline{\tau} \rightarrow D\,\overline{u}}) \rightsquigarrow E}}$ \\
%          & \begingroup \renewcommand*{\arraystretch}{1.0} $\begin{array} {lll}
%                                                              E & ::= & \letbb\,D : \overline{\kappa} \rightarrow \star =\lambda\overline{u : \kappa}.\,\mu X : \star.\,\Pi b:\star.\,\overline{(\overline{\tau}[D\,\overline{u}:=X] \rightarrow b)} \rightarrow b\,\inb \\ & & \letbb\,K_{i} : \Pi\overline{u : \kappa}.\overline{\tau} \rightarrow D\,\overline{u} = \lambda \overline{(u : \kappa)}.\lambda\overline{(x : \tau)}.\\
%                                                                     & & \quad \fold{D\,\overline{u}}{(\lambda (b : \star)\overline{(c : \overline{\tau} \rightarrow b)} . c_{i}\,\overline{x})}\,\inb \end{array}$ \endgroup \\
%     \framebox{$\Gamma \vdash pgm : \tau \rightsquigarrow E$} \\
%     (Pgm) & $\inferrule {\overline{\Gamma_{0} \vdash decl : \Gamma_{d} \rightsquigarrow E_{1}} \\ \Gamma = \Gamma_{0}, \overline{\Gamma_{d}} \\ \ctx{e:\tau \rightsquigarrow E}} {\Gamma_{0} \vdash \overline{decl}; e : \tau \rightsquigarrow \overline{E_{1}} \oplus E}$
%   \end{tabular}
%   \caption{Type-directed translation from \sufcc to \name}\label{fig:datatrans}
% \end{figure*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
