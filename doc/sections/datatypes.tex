%%% !!! WARNING: AUTO GENERATED. DO NOT MODIFY !!! %%%
\newcommand{\FV}{\mathsf{FV}}
\newcommand{\dom}{\mathsf{dom}}

\section{Surface language}
\label{sec:surface}

% \begin{itemize}
% \item Expand the core language with datatypes and pattern matching by encoding.
% \item Give translation rules.
% \item Encode GADTs and maybe other Haskell extensions? GADTs seems challenging, so perhaps some other examples would be datatypes like $Fix f$, and $Monad$ as a record. Could formalize records in Haskell style.
% \end{itemize}

In this section, we present a surface language \sufcc, built on top of
\name with features that are convenient for functional programming:
user-defined datatypes, and pattern matching. Thanks to the
expressiveness of \name, all these features can be elaborated into the
core language without extending the built-in language constructs of
\name. In what follows, we first give the syntax of the surface
language, followed by the extended typing rules, then we show the
formal translation rules that translates a surface language expression
to an expression in \name. Finally we prove the type-safety of the
translation.

\subsection{Extended Syntax}

% \newcommand{\case}{\mathbf{case}} \newcommand{\of}{\mathbf{of}}
% \newcommand{\data}{\mathbf{data}} \newcommand{\where}{\mathbf{where}}
% \newcommand{\letbb}{\mathbf{let}} \newcommand{\inb}{\mathbf{in}}

The full syntax of \sufcc is defined in Figure~\ref{fig:surface:syntax}. Compared with \name, \sufcc has a new syntax category: a program, consisting of a list of datatype declarations, followed by a expression. An \emph{algebraic data type} $D$ is introduced as a top-level \textbf{data} declaration with its \emph{data constructors}. For the purpose of presentation, we sometimes adopt the following syntactic convention:
\[
\overline{\tau}^n \rightarrow \tau_r \equiv \tau_1 \rightarrow \dots \rightarrow \tau_n \rightarrow \tau_r
\]
The type of a data constructor $K$ has the form:
\[
\ottmv{K}  \ottsym{:}  \ottsym{(}  \,\overline{  \ottnt{u}  \ottsym{:}  \kappa  }\,  \ottsym{)}  \rightarrow  \ottsym{(}  \,\overline{  \ottmv{x}  \ottsym{:}  T  }\,  \ottsym{)}  \rightarrow  \ottmv{D}    \,\overline{  \ottnt{u}  }\,
\]
\bruno{this looks a bit odd for a number of reasons: firstly why to
  insist on having the quantified variables in the same order as the
  arguments in the constructor? Secondly it seems that all other
  arguments cannot be dependently typed? 
It seems to me that 
\[
\ottmv{K}  \ottsym{:}  \ottsym{(}  \,\overline{  \ottmv{x}  \ottsym{:}  \kappa  }\,  \ottsym{)}  \rightarrow  \ottmv{D}    \,\overline{  \ottnt{u}  }\,
\]
where all variables $u$ are bound ($u \in \overline{x}$) would be
better.  } \jeremy{changed!  $\ottsym{(}  \,\overline{  \ottnt{u}  \ottsym{:}  \kappa  }\,  \ottsym{)}$ are for the arguments of
a type constructor, $\ottsym{(}  \,\overline{  \ottmv{x}  \ottsym{:}  T  }\,  \ottsym{)}$ are for the arguments of a data
constrcutor}
% The quantified type variables $\,\overline{  \ottnt{u}  }\,$ appear in the same order in
% the return type $\ottmv{D}    \,\overline{  \ottnt{u}  }\,$.
Note that the use of the dependent product in the type of a data
constructor (e.g., $\ottsym{(}  \,\overline{  \ottnt{u}  \ottsym{:}  \kappa  }\,  \ottsym{)}$) makes it possible to let the type
of some type constructor arguments depend on other type constructor
arguments, while in Haskell, this is not possible, becuase the arrow
$\rightarrow$ can be seen as an independent product type. The
\textbf{case} expression is conventional, used to break up values
built with data constructors.  The patterns of a case expression are
flat (no nested patterns), and bind value variables.

\begin{figure*}
\centering
\gram{\ottpgm\ottinterrule
\ottdecl\ottinterrule
\ottu\ottinterrule
\ottp\ottinterrule
\ottE\ottinterrule
\ottGs}
\[\ottsurfsugar\] % defined in otthelper.mng.tex
\caption{Syntax of the surface language}
\label{fig:surface:syntax}
\end{figure*}


% \begin{figure}[ht]
% \centering
% \small
% \[
%   \begin{array}{llll}
%     \textbf{Declarations} \\
%     pgm &::= & \overline{decl}; e & \text{Declarations} \\
%     decl &::= & \data\,D\,\overline{u : \kappa} = \overline{\mid K\,\overline{\tau}} & \text{Datatype} \\ \\
%     \textbf{Terms} \\
%     u &::= & x \mid K & \text{Variables and constructors} \\
%     e,\tau,\sigma,\upsilon,\kappa &::= & u & \text{Term atoms} \\
%     & & \dots \\
%     & \mid & \case\,e\,\of\,\overline{p \Rightarrow e} & \text{Case analysis} \\
%     p &::= & K\,\overline{x : \tau} & \text{Pattern} \\ \\
%     \textbf{Environments} \\
%     \Gamma &::= &\varnothing & \text{Empty} \\
%     & \mid & \Gamma,u:\tau & \text{Variable binding}
%   \end{array}
% \]
%   \caption{Syntax of \sufcc ($e$ for terms; $\tau,\sigma,\upsilon$ for types; $\kappa$ for kinds)}\label{fig:datasyn}
% \end{figure}

For the sake of programming, \sufcc employs some syntactic sugar. A
non-dependent function type can be written as $T_{{\mathrm{1}}}  \rightarrow  T_{{\mathrm{2}}}$. A
dependent function type $\Pi \, \ottmv{x}  \ottsym{:}  T_{{\mathrm{1}}}  \ottsym{.}  T_{{\mathrm{2}}}$ is abbreviated as
$\ottsym{(}  \ottmv{x}  \ottsym{:}  T_{{\mathrm{1}}}  \ottsym{)}  \rightarrow  T_{{\mathrm{2}}}$ for easy reading. We also introduce a
Haskell-like record syntax, which is desugared to datatypes with
accompanying selector functions.

% \begin{figure}[ht]
% \centering
% \[
%   \begin{array}{l}
%     \data\,R\,\overline{u : \kappa} = K\,\{\,\overline{S:\tau}\,\} \triangleq \\
%     \data\,R\,\overline{u : \kappa} = K\,\overline{\tau} \\
%     \letbb\,S_{i} : \Pi \overline{u : \kappa}.R\,\overline{u} \rightarrow \tau_{i} = \\
%     \quad \lambda \overline{(u:\kappa)}.\lam{l}{R\,\overline{u}}{\case\,l\,\of\, K\,\overline{x:\tau} \Rightarrow x_{i}} \\
%     \inb
%   \end{array}
% \]
% \caption{Syntactic sugar for records}\label{fig:records}
% \end{figure}

\subsection{Extended Typing Rules}
\bruno{For typing and translation show only one figure (Figure 8),
  since the typing figure is just a subset. We can use gray to
  highlight the parts which belong to the translation.}
\jeremy{adjusted!}

Figure~\ref{fig:source:translate} defines the type system of the
surface language (ignore the gray parts for the moment). Several new
typing judgments appear in the type system. The use of different
subscripts of the judgments is to be distinct from the one used in
\name. Most rules of the type system are standard for systems based on
\coc, including the rules for the well-formedness of contexts
(\ruleref{TRenv\_Empty}, \ruleref{TRenv\_Var}), inferring the types of
variables (\ruleref{TR\_Var}), and dependent application
(\ruleref{TR\_App}). Two judgments $ \Sigma  \labeledjudge{pg}  \ottnt{pgm}  :  T $ and
$ \Sigma  \labeledjudge{d}  \ottnt{decl}  :  \Sigma' $ are of the essence to the type checking of the
surface language. The former type checks a whole program, and the
latter type checks datatype declarations.

Rule \ruleref{TRpgm\_Pgm} type checks a whole program. It first
type-checks the declarations, which in return gives a new typing
environment. Combined with the original environment, it then continues
to type check the expression and return the result type. Rule
\ruleref{TRpgm\_Data} is used to type check datatype declarations. It
first ensures the well-formedness of the type of the type constructor
application (of kind $\star$). Note that since our system adopts
$\star : \star$, this means we can express kind polymophism for
datatypes. Finally it make sure the types of data constructors are
valid.

Rules \ruleref{TR\_Case} and \ruleref{TRpat\_Alt} handle the type
checking of case expressions. The conclusion of \ruleref{TS\_Case}
binds the right types to the scrutinee $\ottnt{E_{{\mathrm{1}}}}$ and alternatives
$\overline{p \Rightarrow E_2}$. The first premise of
\ruleref{Tpat\_Alt} binds the actual type constructor arguments to
$\,\overline{  \ottnt{u}  }\,$. The second premise checks whether the types of the
right-hand sides of each alternative, instantiated to the actual type
constructor arguments $\,\overline{  \ottnt{u}  }\,$, are equal. Finally the third
premise checks the well-formedness of the types of data constructor
arguments.  \bruno{Mention that we do not support refinement, as in
  GADTs?} \jeremy{done!}

As can be seen, currently \sufcc does not support refinement on the
final result of each data constructor, as in GADTs. However, our
encoding method does support some form of GADTs, as is discussed in
Section~\ref{Discussion}.

\begin{figure*}
\ottdefnctxtrans{}\ottinterrule
\ottdefnpgmtrans{}\ottinterrule
\ottdefndecltrans{}
\[\hlmath{\ottdecltrans}\]\ottinterrule % defined in otthelper.mng.tex
\ottdefnpattrans{}\ottinterrule
\ottdefnexprtrans{}
\caption{Type directed translation rules of the surface language}
\label{fig:source:translate}
\end{figure*}


% \begin{figure*}
% \ottdefnctxsrc{}
% \ottdefnpgmsrc{}
% \ottdefndeclsrc{}
% \ottdefnpatsrc{}
% \ottdefnexprsrc{}
% \caption{Typing rules of surface language}
% \label{fig:surface:typing}
% \end{figure*}

% \newcommand{\ctx}[2][\Gamma]{#1 \vdash #2}
% \newcommand{\ctxz}[1]{\ctx[\varnothing]{#1}}
% \newcommand{\ctxw}[3][\Gamma]{#1,#2 \vdash #3}

% \begin{figure*}
%   \centering \small
%   \begin{tabular}{lc}
%     \framebox{$\Gamma \vdash pgm : \tau$} \\
%     (Pgm) & $\inferrule {\overline{\Gamma_{0} \vdash decl : \Gamma_{d}} \\ \Gamma = \Gamma_{0}, \overline{\Gamma_{d}} \\ \ctx{e:\tau}} {\Gamma_{0} \vdash \overline{decl}; e : \tau}$ \\
%     \framebox{$\Gamma \vdash decl : \Gamma_d$} \\
%     (Data) & $\inferrule {\Gamma \vdash \overline{\kappa} \rightarrow \star : \square \\ \overline{\Gamma, D:\overline{\kappa} \rightarrow \star, \overline{u : \kappa} \vdash \overline{\tau} \rightarrow D\,\overline{u}:\star}} {\ctx{(\data\,D\,\overline{u : \kappa} = \overline{\mid K\,\overline{\tau}}): (D : \overline{\kappa} \rightarrow \star, \overline{K : \Pi\overline{u : \kappa}.\overline{\tau} \rightarrow D\,\overline{u}})}}$ \\
%     \framebox{$\Gamma \vdash e : \tau$} \\
%     (Case) & $\inferrule {\ctx{e_{1}}:\sigma \\ \overline{\Gamma\vdash_{p} p \Rightarrow e_{2}:\sigma \rightarrow \tau}} {\Gamma\vdash\case\,e_{1}\,\of\,\overline{p \Rightarrow e_{2}}:\tau}$ \\
%     \framebox{$\Gamma \vdash_{p} p \Rightarrow e : \sigma \rightarrow \tau$} \\
%     (Alt) & $\inferrule {\theta=[\overline{u := \upsilon}] \\\\ K:\Pi\overline{u:\kappa}.\,\overline{\sigma} \rightarrow D\,\overline{u} \in \Gamma \\ \Gamma,\overline{x:\theta(\sigma)} \vdash e:\tau} {\Gamma \vdash_{p} K\,\overline{x:\theta(\sigma)} \Rightarrow e : D\,\overline{\upsilon} \rightarrow \tau}$
%   \end{tabular}
%   \caption{Typing rules of \sufcc}\label{fig:datatype}
% \end{figure*}

\subsection{Translation Overview}

We use a type-directed translation. The basic translation rules have the form:
\[
 \Sigma  \labeledjudge{s}  \ottnt{E}  :  T   \rightsquigarrow   \ottnt{e} 
\]
It states that \name expression $\ottnt{e}$ is the translation of the
surface expression $\ottnt{E}$ of type $T$.  The gray parts in
Figure~\ref{fig:source:translate} defines the translation
rules. \bruno{Any partiular reasons for this?} \jeremy{deleted}

Among others, Rules \ruleref{TRdecl\_Data}, \ruleref{TRpat\_Alt} and
\ruleref{TR\_Case} are of the essence to the translation. Rule
\ruleref{TR\_Case} translates case expressions into applications by
first translating the scrutinee expression, casting it down to the
right type. It is then applied to the result type of the body
expression and a list of translated \name expressions of its
alternatives. Rule \ruleref{TRpat\_Alt} tells how to translate each
alternative. Basically it translates an alternative into a lambda
abstraction, where each bound variable in the pattern corresponds to a
bound variable in the lambda abstraction in the same order. The body
in the alternative is recursively translated and treated as the body
of the lambda abstraction. Note that due to the rigidness of the
translation, pattern matching must be exhaustive, and the order of
patterns matters (the same order as in the datatype declaration).

Rule \ruleref{TRDecl\_Data} does the most heavy work and deserves
further explanation. First of all, it results in an incomplete
expression (as can be seen by the incomplete $\mathsf{let}$
expressions), The result expression is supposed to be prepended to the
translation of the last expression to form a complete \name
expression, as specified by Rule \ruleref{TRpgm\_Pgm}. Furthermore,
each type constructor is translated to a recursive type, of which the
body is a type-level lambda abstraction. What is interesting is that
each recursive mention of the datatype in the data constructor
parameters is replaced with the recursive variable $\ottmv{X}$. Note that
for the moment, the result type variable $b$ is restricted to
have kind $\star$. This could pose difficulties when translating GADTs
as we will discussion in the future work. Each data constructor is
translated to a lambda abstraction. Notice how we use $ \mathsf{cast}^{\uparrow} $ in
the lambda body to get the right type.

The rest of the translation rules hold few surprises.

\subsection{Type-safefy of Translation}

\jeremy{put Linus's theorem here}

% \begin{figure*}
%   \renewcommand{\arraystretch}{2.5}
%   \centering \small
%   \begin{tabular}{lcl}
%     \framebox{$\Gamma \vdash e : \tau \rightsquigarrow E$} \\
%     (Ax) & $\inferrule { } {\ctxz{\star:\square \rightsquigarrow \star}}$ \\

%     (Var) & $\inferrule {x:\tau \in \Gamma} {\ctx{x:\tau \rightsquigarrow x}}$ \\

%     (App) & $\inferrule {\ctx{e_{1}:(\pai{x}{\tau_{2}}{\tau_{1}}) \rightsquigarrow E_{1}} \\ \ctx{e_{2}:\tau_{2} \rightsquigarrow E_{2}}} {\ctx{e_{1}e_{2}:\tau_{1}[x:=e_{2}] \rightsquigarrow E_{1}E_{2}}}$ \\

%     (Lam) & $\inferrule {\ctxw{x:\tau_{1}}{e:\tau_{2} \rightsquigarrow E} \\ \ctx{(\pai{x}{\tau_{1}}{\tau_{2}}):t}} {\ctx{(\lam{x}{\tau_{1}}{e})}:(\pai{x}{\tau_{1}}{\tau_{2}}) \rightsquigarrow \lam{x}{\tau_{1}}{E}}$ & $t \in \{\star, \square\}$ \\

%     (Pi) & $\inferrule {\ctx{\tau_{1}:s} \\ \ctxw{x:\tau_{1}}{\tau_{2}:t}} {\ctx{(\pai{x}{\tau_{1}}{\tau_{2}}):t \rightsquigarrow \pai{x}{\tau_{1}}{\tau_{2}}}}$ & $(s,t) \in \mathcal{R}$ \\

%     (Mu) & $\inferrule {\ctxw{x:\tau}{e:\tau} \rightsquigarrow E \\ \ctx{\tau:s}} {\ctx{(\miu{x}{\tau}{e}):\tau} \rightsquigarrow \miu{x}{\tau}{E}}$ & $s \in \{\star, \square\}$ \\

%     (Fold) & $\inferrule {\ctx{e:\tau_{2} \rightsquigarrow E} \\ \ctx{\tau_{1}:s} \\ \tau_{1} \longrightarrow \tau_{2}} {\ctx{(\fold{{\tau_{1}}}{e}):{\tau_{1}} \rightsquigarrow \fold{\tau_{1}}{E}}}$ \\

%     (Unfold) & $\inferrule {\ctx{e:\tau_{1} \rightsquigarrow E} \\ \ctx{\tau_{2}:s} \\ \tau_{1} \longrightarrow \tau_{2}} {\ctx{(\unfold{e}):\tau_{2} \rightsquigarrow \unfold{E}}}$ \\

%     (Case) & $\inferrule {\ctx{e_{1}:\sigma \rightsquigarrow E_{1}} \\ \overline{\Gamma\vdash_{p} p \Rightarrow e_{2}:\sigma \rightarrow \tau \rightsquigarrow E_{2}}} {\Gamma\vdash\case\,e_{1}\,\of\,\overline{p \Rightarrow e_{2}}:\tau \rightsquigarrow (\unfold{E_{1}})\,\tau\,\overline{E_{2}}}$ \\
%     \framebox{$\Gamma \vdash_{p} p \Rightarrow e : \sigma \rightarrow \tau \rightsquigarrow E$} \\
%     (Alt) & $\inferrule {\theta=[\overline{u := \upsilon}] \\\\ K:\Pi\overline{u:\kappa}.\,\overline{\sigma} \rightarrow D\,\overline{u} \in \Gamma \\ \Gamma,\overline{x:\theta(\sigma)} \vdash e:\tau \rightsquigarrow E} {\Gamma \vdash_{p} K\,\overline{x:\theta(\sigma)} \Rightarrow e : D\,\overline{\upsilon} \rightarrow \tau \rightsquigarrow \lambda(\overline{x:\theta(\sigma)}).E}$ \\
%     \framebox{$\Gamma \vdash decl : \Gamma_d \rightsquigarrow E$} \\
%     (Data) & $\inferrule {\Gamma \vdash \overline{\kappa} \rightarrow \star : \square \\ \overline{\Gamma, D:\overline{\kappa} \rightarrow \star, \overline{u : \kappa} \vdash \overline{\tau} \rightarrow D\,\overline{u}:\star}} {\ctx{(\data\,D\,\overline{u : \kappa} = \overline{\mid K\,\overline{\tau}}): (D : \overline{\kappa} \rightarrow \star, \overline{K : \Pi\overline{u : \kappa}.\overline{\tau} \rightarrow D\,\overline{u}}) \rightsquigarrow E}}$ \\
%          & \begingroup \renewcommand*{\arraystretch}{1.0} $\begin{array} {lll}
%                                                              E & ::= & \letbb\,D : \overline{\kappa} \rightarrow \star =\lambda\overline{u : \kappa}.\,\mu X : \star.\,\Pi b:\star.\,\overline{(\overline{\tau}[D\,\overline{u}:=X] \rightarrow b)} \rightarrow b\,\inb \\ & & \letbb\,K_{i} : \Pi\overline{u : \kappa}.\overline{\tau} \rightarrow D\,\overline{u} = \lambda \overline{(u : \kappa)}.\lambda\overline{(x : \tau)}.\\
%                                                                     & & \quad \fold{D\,\overline{u}}{(\lambda (b : \star)\overline{(c : \overline{\tau} \rightarrow b)} . c_{i}\,\overline{x})}\,\inb \end{array}$ \endgroup \\
%     \framebox{$\Gamma \vdash pgm : \tau \rightsquigarrow E$} \\
%     (Pgm) & $\inferrule {\overline{\Gamma_{0} \vdash decl : \Gamma_{d} \rightsquigarrow E_{1}} \\ \Gamma = \Gamma_{0}, \overline{\Gamma_{d}} \\ \ctx{e:\tau \rightsquigarrow E}} {\Gamma_{0} \vdash \overline{decl}; e : \tau \rightsquigarrow \overline{E_{1}} \oplus E}$
%   \end{tabular}
%   \caption{Type-directed translation from \sufcc to \name}\label{fig:datatrans}
% \end{figure*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
