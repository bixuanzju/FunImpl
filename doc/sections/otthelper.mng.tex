% Hack to use mathpartir for ott
\newcommand{\ottlinebreak}{}
\renewcommand{\ottdrule}[4][]{{\inferrule{#2 }{#3}\quad\ottdrulename{#4}}}
\renewcommand{\ottgrammartabular}[1]{\begin{tabular}{llcllllll}#1\end{tabular}}
\renewcommand{\ottinterrule}{\\[3.0mm]}
\newcommand{\gram}[1]{\ottgrammartabular{#1\ottafterlastrule}}
\newcommand{\ruleref}[1]{\ottdrulename{#1}}

\newcommand{\castup}{$[[castup]]$\xspace}
\newcommand{\castdown}{$[[castdown]]$\xspace}
\newcommand{\cast}{$[[cast]]$\xspace}

\newcommand{\lam}[3]{[[\]] #1:#2.\,#3}
\newcommand{\pai}[3]{[[Pi]] #1:#2.\,#3}
\newcommand{\miu}[3]{[[mu]] #1:#2.\,#3}

\newcommand*{\mathscale}[2][4]{\scalebox{#1}{$#2$}}%

\def\replace#1#2#3{%
 \def\tmp##1#2{##1#3\tmp}%
   \tmp#1\stopreplace#2\stopreplace}
\def\stopreplace#1\stopreplace{}

\newcommand{\ottcoresugar}{%%
\begin{array}{llll} %
    \text{Syntactic Sugar}\\ %
    \quad [[A1->A2]] & \triangleq & [[Pi x:A1.A2]] \quad x \not \in %
        \FV([[A2]]) \\ %
    \quad [[(x:A1)->A2]] & \triangleq & [[Pi x:A1.A2]] \quad x \in \FV([[A2]]) %
        \\ %
    \quad [[foldn [t1] e]] & [[:=]] & [[castup]] [ [[t1]] ] ([[castup]] [ %
        [[t2]] ] (\dots ( [[castup [tn] e]] ) \dots )) \\ %
    \quad [[unfoldn e]] & [[:=]] & \underbrace{[[castdown]] ([[castdown]] %
        (\dots ( [[castdown]]}_n [[e]]) \dots )) %
\end{array} %
}

\newcommand{\ottsurfsugar}{%%
\begin{array}{lllll} %
    &&&& \text{Syntactic Sugar} \\ %
    [[A1->A2]] & \triangleq & [[Pi x:A1.A2]] & x \not \in \FV([[A2]]) & %
        \quad\text{Function type} \\ %
    [[(x:A1)->A2]] & \triangleq & [[Pi x:A1.A2]] & x \in \FV([[A2]]) & %
        \quad\text{Dependent function type} \\ %
    [[data R <<u:k>> = K { <<N:A>> }]] & \triangleq & %
        [[data R <<u:k>> = K <<x:A>>]]; && \quad\text{Record} \\ %
        && [[let]]~[[N]]_i : [[ (<<u:k>>) -> R@<<u>> -> A]]_i = & %
        \forall i &  \\ %
        && [[\ <<u:k>> . \ y : R <<u>> . case y of K <<x:A>> => x]]_i~[[in]] && \\ %
\end{array} %
}

\newcommand{\ottdeclD}{%%
[[mu X : (<<u:ro>>n) -> star . \ <<u:ro>>n . (aa:star) -> << ((<<x : t[D |-> X]>>) -> aa) >> -> aa]] %
}

\newcommand{\ottdeclK}{%%
[[\ <<u:ro>>n . \<<x:t>> . foldnp [D@<<u>>n] (\aa:star.\<<bb : (<<x:t>>) -> aa >> . bbi <<x>>)]] %
}

\newcommand{\ottdecltrans}{%%
\begin{array}{ll} %
    [[e]] [[:=]] & [[ let ]] [[D]] : [[(<<u:ro>>n) -> star]] = \ottdeclD [[ in ]] \\ %
    & [[ let ]]  [[Ki]] : [[ (<<u:ro>>n) -> (<<x:t>>) -> D@<<u>>n ]] = \ottdeclK [[ in ]] %
\end{array} %
}
