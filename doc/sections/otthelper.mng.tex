% Hack to use mathpartir for ott
\newcommand{\ottlinebreak}{}
\renewcommand{\ottdrule}[4][]{{\inferrule{#2 }{#3}\quad\ottdrulename{#4}}}
\renewcommand{\ottgrammartabular}[1]{\begin{tabular}{llcllllll}#1\end{tabular}}
\renewcommand{\ottinterrule}{\\[3.0mm]}
\newcommand{\gram}[1]{\ottgrammartabular{#1\ottafterlastrule}}
\newcommand{\ruleref}[1]{\ottdrulename{#1}}

\newcommand{\castup}{$[[castup]]$\xspace}
\newcommand{\castdown}{$[[castdown]]$\xspace}
\newcommand{\cast}{$[[cast]]$\xspace}
\newcommand{\fold}{$[[fold]]$\xspace}
\newcommand{\unfold}{$[[unfold]]$\xspace}

\newcommand{\lam}[3]{[[\]] #1:#2.\,#3}
\newcommand{\pai}[3]{[[Pi]] #1:#2.\,#3}
\newcommand{\miu}[3]{[[mu]] #1:#2.\,#3}

\newcommand{\ottcoresugar}{%%
\begin{array}{llll} %
    \text{Syntactic Sugar}\\ %
    \quad [[A1->A2]] & \triangleq & [[Pi x:A1.A2]] \quad x \not \in %
        \FV([[A2]]) \\ %
    \quad [[(x:A1)->A2]] & \triangleq & [[Pi x:A1.A2]] \quad x \in \FV([[A2]]) %
        \\ %
    \quad [[foldn [t1] e]] & [[:=]] & [[castup]] [ [[t1]] ] ([[castup]] [ %
        [[t2]] ] (\dots ( [[castup [tn] e]] ) \dots )) \\ %
    \quad [[unfoldn e]] & [[:=]] & \underbrace{[[castdown]] ([[castdown]] %
        (\dots ( [[castdown]]}_n [[e]]) \dots )) %
\end{array} %
}

\newcommand{\ottsurfsugar}{%%
\begin{array}{lllll} %
    &&&& \text{Syntactic Sugar} \\ %
    [[A1->A2]] & \triangleq & [[Pi x:A1.A2]] & x \not \in \FV([[A2]]) & %
        \quad\text{Function type} \\ %
    [[(x:A1)->A2]] & \triangleq & [[Pi x:A1.A2]] & x \in \FV([[A2]]) & %
        \quad\text{Dependent function type} \\ %
    [[foldn [A1] E]] & [[:=]] & [[castup]] [ [[A1]] ] ([[castup]] [ %
        [[A2]] ] (\dots ( [[castup [An] E]] ) \dots )) && %
        \quad\text{Cast up in $n$ steps} \\ %
    [[unfoldn E]] & [[:=]] & \underbrace{[[castdown]] ([[castdown]] %
        (\dots ( [[castdown]]}_n [[E]]) \dots )) && %
        \quad\text{Cast down in $n$ steps} \\ %
    [[data R <<u:k>> = K { <<N:A>> }]] & \triangleq & %
        [[data R <<u:k>> = K <<A>>]]; && \quad\text{Record} \\ %
        && [[let]]~[[N]]_i : [[ (<<u:k>>) -> R@<<u>> -> A]]_i = & %
        \forall i &  \\ %
        && [[\ <<u:k>> . \ y : R <<u>> . case y of K <<x:A>> => x]]_i~[[in]] && \\ %
\end{array} %
}

\newcommand{\ottdecltrans}{%%
\begin{array}{ll} %
    [[e]] [[:=]] & [[ let D : (<<u:T>>) -> star = mu X : (<<u:T>>) -> star . \ <<u:T>> . (aa:star) -> << (<<t>>[D |-> X] -> aa) >> -> aa in @@ ]] \\ %
    & [[ let Ki : (<<u:T>>) -> <<t>> -> D@<<u>> = \ <<u:T>> . \<<x:t>> . foldn [D@<<u>>] (\aa:star.\<<bb : <<t>> -> aa >> . bbi <<x>>) in @@ ]] %
\end{array} %
}
