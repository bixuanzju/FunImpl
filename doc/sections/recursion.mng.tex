\section{The Explicit Calculus of Constructions with Recursion}

\bruno{Linus and Jeremy, I think you should do this section together. Most work is on Linus though since he needs to work out the proofs. Jeremy is mostly for Linus to consult with here :).}

%This section shows how to extend $\lambda C\beta$ with recursion. This extension 
%allows the calculus to account for both: 1) recursive definitions; 2) recursive types. 
%The extension preserves the decidability and soundness of the type system.

%%% FIXME: Dirty hacks, may change later
\newcommand{\newsyntax}{
\ottrulehead{\ottnt{e}  ,\ \tau}{::=}{\ottcom{Expressions}}\ottprodnewline
\ottfirstprodline{|}{\dots}{}{}{}{}\ottprodnewline
\ottprodline{|}{[[mu x.t]]}{}{}{}{\ottcom{General recursion}}}

We have shown that \expcc does not rely on strong normalization for decidable type checking and soundness. Thus it is safe to combine general recursion with \expcc under the control of explicit type conversion operations $[[castup]]$ and $[[castdown]]$. We extend \expcc into \name by introducing one unified primitive called $\mu$-notation for general recursion. It functions as a fixed point at the term level as well as a recursive type at the type level.

\subsection{The $\mu$-notation}
Based on the syntax of \expcc, we add the following $\mu$-notation for \name (the same part as \expcc is left out):

\begin{figure}[ht]
	\centering
	\gram{\newsyntax}
\end{figure}

The $\mu$-notation is similar to the definition of recursive types, except that it is not only treated as types but also terms. This also corresponds to the property of \expcc that terms and types are not distinguished.

The typing rule and operational semantics of $\mu$-notation for terms and types are also unified, thus each one rule for static and dynamic semantics is only needed to add over \expcc. The new type checking rule of $\mu$-notation is as follows:

\begin{figure}[ht]
	\ottusedrule{\ottdruleTXXMu{}}
\end{figure}

And the one-step reduction rule is as follows:

\begin{figure}[ht]
	\ottusedrule{\ottdruleSXXMu{}}
\end{figure}

If $[[mu x . t]]$ is a term, with the \ruleref{S\_Mu} rule, it is not treated as a value and can be further reduced, which is different from conventional iso-recursive types. The one-step reduced term of $[[mu x . t]]$ is the substitution of $[[x]]$ in $[[t]]$ with itself, i.e. $[[t [x |-> mu x . t] ]]$. Such behavior is just the same as the definition of a fixed point.

If $[[mu x . t]]$ is a type, assume there exist $e : [[mu x . t]]$ and $e' : [[t [x |-> mu x . t] ]]$. Notice that the types of $e$ and $e'$ are equivalent by $\beta$-equivalence. But such result cannot be directly obtained because of the removal of implicit conversion rule. Instead, by using explicit cast operations of \expcc, we can obtain the following transformation between $e$ and $e'$:
\[\begin{array}{lll}
	&[[castup [mu x . t] e']] &: [[mu x . t]]\\
	&[[castdown e]] &: [[(mu x . t [x |-> mu x . t])]]
\end{array}\]
For type-level $\mu$-notation, $[[castup]]$ and $[[castdown]]$ work in the same way as $\textsf{fold}$ and $\textsf{unfold}$ operations in iso-recursive types to control recursion explicitly.

\subsection{Decidability and soundness}
\linus{Not finished. Needs thorough thinking about the proof of soundness.}

Due to the introduction of recursive types, \name is no long consistent so that not able to be used as a logic. But with the power of general recursion, the expressibility of \name is increased since more data types and functions can be mapped or encoded into \name. And more importantly, even with $\mu$-notation, \name can still be proved to have the same properties as \name in the sense of decidability of type checking and soundness.

As what we previously illustrate in Section \ref{sec:ecc:sound}, the type checking of \expcc can always terminate because the derivation is finite without the implicit conversion rule. With the $mu$-notation in \name, the decidability of type checking still holds because the type level recursion is explicitly controlled by cast operations. Notice that in the typing rule of $[[castup]]$ and $[[castdown]]$, the reduction is performed by one step. Thus the reduction sequences are always finite. Also by adopting the definitional equality, to judge if two terms are equal in the type checking is also decidable. Therefore, the new \ruleref{T\_Mu} rule is decidable for type checking.

To prove the soundness, we only need to consider each one more case for subject reduction and progress, i.e. \ruleref{S\_Mu} and \ruleref{T\_Mu}. It is straightforward to verify these two rules still keeping the soundness.
