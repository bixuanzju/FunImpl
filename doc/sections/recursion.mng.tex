\newcommand{\newsyntax}{
\ottrulehead{\ottnt{e}  ,\ \tau,\
\sigma}{::=}{\ottcom{Expressions}}\ottprodnewline
\ottfirstprodline{|}{\dots}{}{}{}{}\ottprodnewline
\ottprodline{|}{[[mu x:t.e]]}{}{}{}{\ottcom{Polymorphic Recursion}}}

\section{Dependent Types with General Recursion}\label{sec:rec}

In this section we present \name: an extension of \ecore with a
general recursion construct.  The general recursion is polymorphic and
has a uniform representation on both term level and type level. The
same construct works both as a term-level fixpoint and recursive type.
The addition of general recursion does not break decidability of
type-checking nor type-safety.

\subsection{Syntax and Semantics}

Figure \ref{fig:rec:ext} shows the changes of extending \ecore to
\name with general recursion. The changes are subtle, since we add
only one more primitive, reduction rule and typing rule for general
recursion. Nevertheless general recursion allows a large number 
of programs that can be expressed in programming languages such 
as Haskell to be expressed in \name as well.

For syntax, we add the polymorphic recursive expression $[[mu x:t.e]]$
to represent general recursion in both terms and types.  The recursive
operator is \emph{polymorphic} in the sense that the binder $x$ can
have a higher kind like $[[star -> star]]$ to take parameters.
For operational semantics, we add
the rule \ruleref{S\_Mu} to define the unrolling of recursion
as a one-step reduction. For typing, we
add the rule \ruleref{T\_Mu} for checking the validity of a
polymorphic recursive term. The rule ensures that the polymorphic
recursion $[[mu x:t.e]]$ should have the same type $[[t]]$ as the
binder $[[x]]$ and also the inner expression $[[e]]$.

\begin{figure}
	\gram{\newsyntax}\ottinterrule
	\ottdefnstepXXrec{}\ottinterrule
	\ottdefnexprXXrec{}
	\caption{Syntax and semantics changes from \ecore to \name}
    \label{fig:rec:ext}
\end{figure}

\subsection{Recursion as Term and Type}
\label{subsec:recur}
\paragraph{Term-level Recursion}

In \name, the $[[mu]]$-operator works as a \emph{fixpoint} on the term
level. By rule \ruleref{S\_Mu}, evaluating a term $[[mu x:t.e]]$ will
substitute all $[[x]]$'s in $e$ with the whole $[[mu]]$-term itself,
resulting in the unrolling $[[e [x |-> mu x:t.e] ]]$. The
$[[mu]]$-term is equivalent to a recursive function that should be
allowed to unroll without restriction. Therefore, the definition of
values is not changed in \name and $[[mu]]$-term is not treated as a
value. 

Recall the factorial function example (Section
\ref{sec:overview:recursion}) defined as follows:
\begin{align*}
    \mathsf{fact} [[:=]] &[[mu]] f : [[int -> int]] . \\ &[[\x : int
        . @@]]~\kw{if}~\textsf{isZero}~x~\kw{then}~1~\kw{else}~x \times (f~(x
    - 1))
\end{align*}
By rule \ruleref{T\_Mu}, the type of $\mathsf{fact}$ is $[[int ->
    int]]$. Thus, we can apply $\mathsf{fact}$ to an integer, say $1$,
and will get an integer as the result. In this example, we assume
evaluating the $\kw{if}$-$\kw{then}$ construct follows the one-step
reduction. With standard reduction rules \ruleref{S\_Mu} and
\ruleref{S\_App}, we can evaluate the term $\mathsf{fact}~1$ as
follows:
\begin{align*}
    &\mathsf{fact}~1 \\ [[-->]]~& ([[\x : int . @@]]~\kw{if}~
  \textsf{isZero}~x~\kw{then}~1~\kw{else}~x \times (\mathsf{fact}~(x - 1)))~1
  \\ [[-->]]~ & \kw{if}~\textsf{isZero}~1~\kw{then}~1~\kw{else}~1 \times
  (\mathsf{fact}~(1 - 1)) \\ [[-->]]~& 1 \times (\mathsf{fact}~(1-1))
  \\ [[-->]]~& 1 \times (\mathsf{fact}~0) [[-->]]~ \dots [[-->]]~ 1 \times
  1 [[-->]]~ 1. 
\end{align*}

Note that we never check if a $\mu$-term can terminate or not, which
is an undecidable halting problem for general recursive terms. The
factorial function example above can stop, while there exist some
terms that will loop forever. However, term-level non-termination is
only a runtime concern and does not block the type checker. In Section
\ref{sec:rec:meta} we show type checking \name is still decidable
in the presence of general recursion.

\paragraph{Type-level Recursion}

On the type level, $[[mu x:t.e]]$ works as a \emph{iso-recursive}
type, a kind of recursive type that is not equal but only isomorphic
to its unrolling. Normally, we need to add two more primitives
$[[fold]]$ and $[[unfold]]$ for the iso-recursive type to map back
and forth between the original and unrolled form:
\begin{align*}
  [[mu x:t.T]] \xrightleftharpoons[{[[fold]]~[ [[mu x:t.T]] ]}]
  {[[unfold]]} [[T[x |-> mu x:t.T] ]]
\end{align*}
where the operators satisfy the following typing rules:
\[ \inferrule{[[G |- e2 : T[x |-> mu x:t.T] ]] \\ [[G |- (mu x:t.T) : star]] }
   {[[G |- fold [mu x:t.T] e2 : (mu x:t.T) ]]} \]
\[ \inferrule{[[G |- e1 :(mu x:t.T)]] \\ [[G |- T[x |-> mu x:t.T] : star]]}
   {[[G |- unfold e1 : (T[x |-> mu x:t.T]) ]]} \]

However, in \name we do not need to introduce $[[fold]]$ and
$[[unfold]]$ operators, because with the rule \ruleref{S\_Mu},
$[[castup]]$ and $[[castdown]]$ \emph{generalize} $[[fold]]$ and
$[[unfold]]$ and have the same functionality. Assume there exist
expressions $[[e1]]$ and $[[e2]]$ such that
\[\begin{array}{lll}
	&[[e1]] &: [[mu x:t.e]]\\
	&[[e2]] &: [[e [x |-> mu x:t.e] ]]
\end{array}\]
Note that $[[e1]]$ and $[[e2]]$ have distinct types but the type of
$[[e2]]$ is the unrolling of $[[e1]]$'s type, which follows the
one-step reduction relation by rule \ruleref{S\_Mu}:
\[ [[mu x:t.e --> e [x |-> mu x:t.e] ]] \]
By applying rules \ruleref{T\_CastUp} and \ruleref{T\_CastDown}, we
can obtain the following typing results:
\[\begin{array}{lll}
	&[[castdown e1]] &: [[e [x |-> mu x:t.e] ]]\\
	&[[castup [mu x:t.e] e2]] &: [[mu x:t.e]]
\end{array}\]
Thus, $[[castup]]$ and $[[castdown]]$ witness the isomorphism between
the original recursive type and its unrolling, which behave the same
as $[[fold]]$ and $[[unfold]]$ operations in iso-recursive types:
\begin{align*}
  [[mu x:t.e]] \xrightleftharpoons[{[[castup]]~[ [[mu x:t.e]]
  ]}]{[[castdown]]} [[e[x |-> mu x:t.e] ]]
\end{align*}


\subsection{Decidability of Type Checking and Type Safety}\label{sec:rec:meta}
We gave the proof of the decidability of type checking \ecore in
Section \ref{sec:ecore:meta} without requiring normalization. The
\cast rules are critical for decidability, which rely on checking if
one type can be reduced to another in one step. When we introduce
general recursion into the language, if we can make sure the newly
added and original typing rules are still decidable, the decidability
of type checking still follows in \name.

The rule \ruleref{T\_Mu} for checking the well-formedness of
polymorphic recursion is decidable because its premises only include
decidable typing judgements. However, the rule \ruleref{S\_Mu} changes
the one-step reduction, which may affect the decidability of \cast
rules. If the decidability of changed reduction rules still holds, by
following the proof for \ecore, we can show that \cast
rules are still decidable in \name. Note that given a recursive term
$[[mu x:t.e]]$, by rule \ruleref{S\_Mu}, there always exists a unique
term $[[e']]=[[e[x|->mu x:t.e] ]]$ such that $[[mu x:t.e -->
    e']]$. Thus, the decidability of one-step reduction still holds,
i.e. Lemma \ref{lem:ecore:unique} holds in \name. And the decidability
of type checking, namely Theorem \ref{lem:ecore:decide} holds in \name:

\begin{thm}[Decidability of Type Checking \name]\label{lem:rec:decide}
	There is an algorithm which given $[[G]], [[e]]$ computes the
        unique $[[t]]$ such that $[[G |- e:t]]$ or reports there is no
        such $[[t]]$.
\end{thm}

Moreover, it is straightforward to show the type-safety of \name by
considering rules \ruleref{T\_Mu} and \ruleref{T\_Mu} during the
induction of proof. Thus, Theorem \ref{lem:ecore:reduct} and
\ref{lem:ecore:prog} also hold in \name:

\begin{thm}[Subject Reduction]\label{lem:rec:reduct}
If $[[G |- e:T]]$ and $[[e]] [[->>]] e'$ then $[[G |- e':T]]$.
\end{thm}

\begin{thm}[Progress]\label{lem:rec:prog}
If $[[empty |- e:T]]$ then either $[[e]]$ is a value $v$ or there
exists $[[e]]'$ such that $[[e --> e']]$.
\end{thm}
