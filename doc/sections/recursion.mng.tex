\newcommand{\newsyntax}{
\ottrulehead{\ottnt{e}  ,\ \tau,\ \sigma}{::=}{\ottcom{Expressions}}\ottprodnewline
\ottfirstprodline{|}{\dots}{}{}{}{}\ottprodnewline
\ottprodline{|}{[[mu x:t.e]]}{}{}{}{\ottcom{Polymorphic recursion}}}

\section{Dependent Types with General Recursion}\label{sec:rec}

In this section we present \name: an extension of \ecore with a
general recursion contruct.  The general recursion is polymorphic and
has a uniform representation on both term level and type level. The
same construct works both as a term-level fixpoint and recursive type.
The addition of general recursion does not break decidability of
type-checking nor type-safety.

%Although a calculus with 
%general recursion is not strongly normalizing, it is safe for
%\name to allow non-termination on the type level without breaking the
%decidability of type checking.

\subsection{Syntax and Semantics}

Figure \ref{fig:rec:ext} shows the changes of extending \ecore to
\name with general recursion. The changes are subtle, since we add
only one more primitive, reduction rule and typing rule for general
recursion. Nevertheless general recursion allows a large number 
of programs that can be expressed in programming languages such 
as Haskell to be expressed in \name as well.

For syntax, we add the polymorphic recursion operator $[[mu]]$ to
represent general recursion on both term and type level in the same
form $[[mu x:t.e]]$. For operational semantics, we add the rule
\ruleref{S\_Mu} to define the unrolling operation of a recursion,
which results in $[[e [x |-> mu x:t.e] ]]$. For typing, we add the
rule \ruleref{T\_Mu} for checking the validity of a polymorphic
recursive term. The rule ensures that the polymorphic recursion $[[mu
    x:t.e]]$ should have the same type $[[t]]$ as the binder $[[x]]$
and also the inner expression $[[e]]$.

\begin{figure}
	\gram{\newsyntax}\vspace{1em}
	\ottdefnstepXXrec{}
	\ottdefnexprXXrec{}
	\caption{Grammar changes for general recursion}
    \label{fig:rec:ext}
\end{figure}

\subsection{Recursion as Term and Type}
\subsubsection{Term-level recursion}

Note that the definition of values is not changed and $[[mu]]$-term is
not treated as a value. This is different from conventional
iso-recursive types, because the $[[mu]]$-operator can also be
regarded as a \emph{fixpoint} on the term level. By rule
\ruleref{S\_Mu}, evaluating a term $[[mu x:t.e]]$ will substitute all
$[[x]]$ in $e$ with the whole $[[mu]]$-term itself, resulting in the
unrolling $[[e [x |-> mu x:t.e] ]]$. So the $[[mu]]$-term is
equivalent to a recursive function that should be allowed to unroll
without restriction. Consider the  example in \S \ref{}) \ldots.
\bruno{Show an example of the execution, maybe for fact(2)}

\subsubsection{Type-level recursion}

On the type level, $[[mu x:t.e]]$ works as a \emph{iso-recursive}
type, a kind of recursive type that is not equal but only isomorphic
to its unrolling. Normally, we need to add two more primitives
$\kw{fold}$ and $\kw{unfold}$ for the iso-recursive type to map back
and forth between the original and unrolled form. However, in \name we
can show that with the rule \ruleref{S\_Mu}, $[[castup]]$ and
$[[castdown]]$ \emph{generalize} $\kw{fold}$ and
$\kw{unfold}$.\bruno{Show the rules for fold and unfold here to help 
you make the argument.}

Assume there exist expressions $[[e1]]$ and $[[e2]]$ such that 
\[\begin{array}{lll}
	&[[e1]] &: [[mu x:t.e]]\\
	&[[e2]] &: [[e [x |-> mu x:t.e] ]]
\end{array}\]
Note that $[[e1]]$ and $[[e2]]$ have distinct types but the type of $[[e2]]$ is the unrolling of $[[e1]]$'s type, which follows the one-step reduction relation by rule \ruleref{S\_Mu}:
\[ [[mu x:t.e --> e [x |-> mu x:t.e] ]] \]
By applying rules \ruleref{T\_CastUp} and \ruleref{T\_CastDown}, we can obtain the following typing results:
\[\begin{array}{lll}
	&[[castdown e1]] &: [[e [x |-> mu x:t.e] ]]\\
	&[[castup [mu x:t.e] e2]] &: [[mu x:t.e]]
\end{array}\]
Thus, $[[castup]]$ and $[[castdown]]$ witness the isomorphism between the original recursive type and its unrolling, which behave the same as $\kw{fold}$ and $\kw{unfold}$ operations in iso-recursive types.


\subsection{Type Safety and Decidability of Type Checking}
\bruno{I think it is worth restating the lemmas here to aid the discussion.
No need to show all lemmas, just the main ones: decidability of type-checking 
and type-safety.}
We give the proof of the decidability of type checking \ecore in \S
\ref{sec:ecore:meta} without requiring normalization. The \cast rules
are critical for decidability, which rely on checking if one type can
be reduced to another in one step. When we introduce general recursion
into the language, if we can make sure the newly added and original
typing rules are still decidable, the decidability of type checking
will still follow in \name.

The rule \ruleref{T\_Mu} for checking the well-formedness of
polymorphic recursion is decidable because its premises only include
decidable typing judgements. However, the rule \ruleref{S\_Mu} changes
one-step reduction, which may affect the decidability of \cast
rules. If the uniqueness of changed reduction rules still holds, by
following the same proof tactic of \ecore, we can show that \cast
rules are still decidable in \name. Note that given a recursive term
$[[mu x:t.e]]$, by rule \ruleref{S\_Mu}, there always exists a unique
term $[[e']]=[[e[x|->mu x:t.e] ]]$ such that $[[mu x:t.e -->
    e']]$. Thus, the uniqueness of one-step reduction still holds,
i.e. Lemma \ref{lem:ecore:unique} holds in \name. So the decidability
of type checking, namely Lemma \ref{lem:ecore:decide} holds in \name.

Moreover, it is straightforward to show the type-safety of \name by
considering rules \ruleref{T\_Mu} and \ruleref{T\_Mu} during the
induction of proof. Thus, Lemma \ref{lem:ecore:subst},
\ref{lem:ecore:reduct} and \ref{lem:ecore:prog} also hold in \name.
