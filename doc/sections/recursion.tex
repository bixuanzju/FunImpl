%%% !!! WARNING: AUTO GENERATED. DO NOT MODIFY !!! %%%
\newcommand{\newsyntax}{
\ottrulehead{\ottnt{e}  ,\ \tau,\
\sigma}{::=}{\ottcom{Expressions}}\ottprodnewline
\ottfirstprodline{|}{\dots}{}{}{}{}\ottprodnewline
\ottprodline{|}{\mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}}{}{}{}{\ottcom{Polymorphic recursion}}}

\section{Dependent Types with General Recursion}\label{sec:rec}

In this section we present \name: an extension of \ecore with a
general recursion contruct.  The general recursion is polymorphic and
has a uniform representation on both term level and type level. The
same construct works both as a term-level fixpoint and recursive type.
The addition of general recursion does not break decidability of
type-checking nor type-safety.

%Although a calculus with 
%general recursion is not strongly normalizing, it is safe for
%\name to allow non-termination on the type level without breaking the
%decidability of type checking.

\subsection{Syntax and Semantics}

Figure \ref{fig:rec:ext} shows the changes of extending \ecore to
\name with general recursion. The changes are subtle, since we add
only one more primitive, reduction rule and typing rule for general
recursion. Nevertheless general recursion allows a large number 
of programs that can be expressed in programming languages such 
as Haskell to be expressed in \name as well.

For syntax, we add the polymorphic recursion operator $ \mu $ to
represent general recursion on both term and type level in the same
form $\mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}$. For operational semantics, we add the rule
\ruleref{S\_Mu} to define the unrolling operation of a recursion,
which results in $\ottnt{e}  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}  \ottsym{]} \,$. For typing, we add the
rule \ruleref{T\_Mu} for checking the validity of a polymorphic
recursive term. The rule ensures that the polymorphic recursion $\mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}$ should have the same type $\tau$ as the binder $\ottmv{x}$
and also the inner expression $\ottnt{e}$.

\begin{figure}
	\gram{\newsyntax}\ottinterrule
	\ottdefnstepXXrec{}\ottinterrule
	\ottdefnexprXXrec{}
	\caption{Syntax and semantics changes for general recursion}
    \label{fig:rec:ext}
\end{figure}

\subsection{Recursion as Term and Type}
\paragraph{Term-level Recursion}

In \name, $ \mu $-operator works as a \emph{fixpoint} on the term
level. By rule \ruleref{S\_Mu}, evaluating a term $\mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}$ will
substitute all $\ottmv{x}$ in $e$ with the whole $ \mu $-term itself,
resulting in the unrolling $\ottnt{e}  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}  \ottsym{]} \,$. The
$ \mu $-term is equivalent to a recursive function that should be
allowed to unroll without restriction. Therefore, the definition of
values is not changed in \name and $ \mu $-term is not treated as a
value. This is different from conventional term-level fixpoint that is
usually treated as values \cite{zombie:popl14}.

Recall the factorial function example (\S
\ref{sec:overview:recursion}), which can be defined as a $ \mu $-term
as follows:
\begin{align*}
    \mathsf{fact}  \triangleq ~  & \mu  f : \mathsf{Int}  \rightarrow  \mathsf{Int} . \\ &\lambda  \ottmv{x}  \ottsym{:}  \mathsf{Int}  \ottsym{.}  ~\kw{if}~x  \equiv 0~\kw{then}~1~\kw{else}~x \times (f~(x
    - 1))
\end{align*}
By rule \ruleref{T\_Mu}, the type of $\mathsf{fact}$ is $\mathsf{Int}  \rightarrow  \mathsf{Int}$. Thus, we can apply $\mathsf{fact}$ to an integer, say $1$, and
will get an integer as the result.  By rules \ruleref{S\_Mu} and
\ruleref{S\_App}, we can evaluate the term $\mathsf{fact}~1$ as follows:
\begin{align*}
    &\mathsf{fact}~1 \\  \longrightarrow ~& (\lambda  \ottmv{x}  \ottsym{:}  \mathsf{Int}  \ottsym{.}  ~\kw{if}~x
   \equiv 0~\kw{then}~1~\kw{else}~x \times (\mathsf{fact}~(x - 1)))~1
  \\  \longrightarrow ~ & \kw{if}~1  \equiv 0~\kw{then}~1~\kw{else}~1 \times
  (\mathsf{fact}~(1 - 1)) \\  \longrightarrow ~& 1 \times (\mathsf{fact}~(1-1))
  \\  \longrightarrow ~& 1 \times (\mathsf{fact}~0)  \longrightarrow ~ \dots  \longrightarrow ~ 1 \times
  1  \longrightarrow ~ 1.
\end{align*}

Note that we never check if a $\mu$-term can terminate or not, which
is an undecidable halting problem for general recursive terms. The
factorial function example above can stop, while there exist some
terms that will loop forever. However, term-level non-termination is
only a runtime concern and does not block the type checker. Later we
will see type checking \name is still decidable.
\bruno{Show an example of the execution, maybe for fact(2)}
\linus{Done.}

\paragraph{Type-level Recursion}

On the type level, $\mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}$ works as a \emph{iso-recursive}
type, a kind of recursive type that is not equal but only isomorphic
to its unrolling. Normally, we need to add two more primitives
$ \mathsf{fold} $ and $ \mathsf{unfold} $ for the iso-recursive type to map back
and forth between the original and unrolled form:
\begin{align*}
  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \sigma \xrightleftharpoons[{ \mathsf{fold} ~[ \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \sigma ]}]{ \mathsf{unfold} } \sigma  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \sigma  \ottsym{]} \,
\end{align*}
where the operators satisfy the following typing rules:
\[ \inferrule{\Gamma  \vdash  \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}  \sigma  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \sigma  \ottsym{]} \, \\ \Gamma  \vdash  \ottsym{(}  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \sigma  \ottsym{)}  \ottsym{:}  \star }
   {\Gamma  \vdash  \mathsf{fold} \, \ottsym{[}  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \sigma  \ottsym{]} \,  \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}  \ottsym{(}  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \sigma  \ottsym{)}} \]
\[ \inferrule{\Gamma  \vdash  \ottnt{e_{{\mathrm{1}}}}  \ottsym{:}  \ottsym{(}  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \sigma  \ottsym{)} \\ \Gamma  \vdash  \sigma  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \sigma  \ottsym{]} \,  \ottsym{:}  \star}
   {\Gamma  \vdash  \mathsf{unfold} \, \ottnt{e_{{\mathrm{1}}}}  \ottsym{:}  \ottsym{(}  \sigma  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \sigma  \ottsym{]} \,  \ottsym{)}} \]
\bruno{Show the rules for fold and unfold here to help you make the
  argument.}
\linus{Figure added to show the relationship.}

However, in \name we do not need to introduce $ \mathsf{fold} $ and
$ \mathsf{unfold} $ operators, because with the rule \ruleref{S\_Mu},
$ \mathsf{cast}^{\uparrow} $ and $ \mathsf{cast}_{\downarrow} $ \emph{generalize} $ \mathsf{fold} $ and
$ \mathsf{unfold} $ and have the same functionality. Assume there exist
expressions $\ottnt{e_{{\mathrm{1}}}}$ and $\ottnt{e_{{\mathrm{2}}}}$ such that
\[\begin{array}{lll}
	&\ottnt{e_{{\mathrm{1}}}} &: \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}\\
	&\ottnt{e_{{\mathrm{2}}}} &: \ottnt{e}  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}  \ottsym{]} \,
\end{array}\]
Note that $\ottnt{e_{{\mathrm{1}}}}$ and $\ottnt{e_{{\mathrm{2}}}}$ have distinct types but the type of $\ottnt{e_{{\mathrm{2}}}}$ is
the unrolling of $\ottnt{e_{{\mathrm{1}}}}$'s type, which follows the one-step reduction relation
by rule \ruleref{S\_Mu}:
\[ \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}  \longrightarrow  \ottnt{e}  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}  \ottsym{]} \, \]
By applying rules \ruleref{T\_CastUp} and \ruleref{T\_CastDown}, we can obtain
the following typing results:
\[\begin{array}{lll}
	&\mathsf{cast}_{\downarrow} \, \ottnt{e_{{\mathrm{1}}}} &: \ottnt{e}  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}  \ottsym{]} \,\\
	&\mathsf{cast}^{\uparrow} \, \ottsym{[}  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}  \ottsym{]} \,  \ottnt{e_{{\mathrm{2}}}} &: \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}
\end{array}\]
Thus, $ \mathsf{cast}^{\uparrow} $ and $ \mathsf{cast}_{\downarrow} $ witness the isomorphism between the
original recursive type and its unrolling, which behave the same as $ \mathsf{fold} $
and $ \mathsf{unfold} $ operations in iso-recursive types:
\begin{align*}
  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e} \xrightleftharpoons[{ \mathsf{cast}^{\uparrow} ~[ \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}
  ]}]{ \mathsf{cast}_{\downarrow} } \ottnt{e}  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}  \ottsym{]} \,
\end{align*}


\subsection{Decidability of Type Checking and Type Safety}
\bruno{I think it is worth restating the lemmas here to aid the discussion.
No need to show all lemmas, just the main ones: decidability of type-checking 
and type-safety.}
\linus{Revised.}
We give the proof of the decidability of type checking \ecore in \S
\ref{sec:ecore:meta} without requiring normalization. The \cast rules
are critical for decidability, which rely on checking if one type can
be reduced to another in one step. When we introduce general recursion
into the language, if we can make sure the newly added and original
typing rules are still decidable, the decidability of type checking
will still follow in \name.

The rule \ruleref{T\_Mu} for checking the well-formedness of
polymorphic recursion is decidable because its premises only include
decidable typing judgements. However, the rule \ruleref{S\_Mu} changes
one-step reduction, which may affect the decidability of \cast
rules. If the uniqueness of changed reduction rules still holds, by
following the same proof tactic of \ecore, we can show that \cast
rules are still decidable in \name. Note that given a recursive term
$\mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}$, by rule \ruleref{S\_Mu}, there always exists a unique
term $\ottnt{e'}=\ottnt{e}  \ottsym{[}  \ottmv{x}  \mapsto  \mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}  \ottsym{]} \,$ such that $\mu \, \ottmv{x}  \ottsym{:}  \tau  \ottsym{.}  \ottnt{e}  \longrightarrow  \ottnt{e'}$. Thus, the uniqueness of one-step reduction still holds,
i.e. Lemma \ref{lem:ecore:unique} holds in \name. So the decidability
of type checking, namely Lemma \ref{lem:ecore:decide} holds in \name:

\begin{thm}[Decidability of Type Checking \name]\label{lem:rec:decide}
	There is an algorithm which given $\Gamma, \ottnt{e}$ computes the unique
$\tau$ such that $\Gamma  \vdash  \ottnt{e}  \ottsym{:}  \tau$ or reports there is no such $\tau$.
\end{thm}

Moreover, it is straightforward to show the type-safety of \name by
considering rules \ruleref{T\_Mu} and \ruleref{T\_Mu} during the
induction of proof. Thus, Lemma \ref{lem:ecore:reduct} and \ref{lem:ecore:prog}
also hold in \name:

\begin{thm}[Subject Reduction]\label{lem:rec:reduct}
If $\Gamma  \vdash  \ottnt{e}  \ottsym{:}  \sigma$ and $\ottnt{e}  \twoheadrightarrow  e'$ then $\Gamma  \vdash  \ottnt{e'}  \ottsym{:}  \sigma$.
\end{thm}

\begin{thm}[Progress]\label{lem:rec:prog}
If $\varnothing  \vdash  \ottnt{e}  \ottsym{:}  \sigma$ then either $\ottnt{e}$ is a value $v$ or there exists $\ottnt{e}'$
such that $\ottnt{e}  \longrightarrow  \ottnt{e'}$.
\end{thm}
