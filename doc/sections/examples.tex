%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%


\section{Applications}
\label{sec:app}

In this section, we show some large examples using \name.

\subsection{Parametric HOAS}
\label{sec:phoas}

Parametric Higher Order Abstract Syntax (PHOAS) is a higher order approach to represent binders, in which the function space of the meta-language is used to encode the binders of the object language. We show that \name can handle PHOAS by encoding lambda calculus as below:


\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{PLambda}\;(\Varid{a}\mathbin{:}\mathbin{*})\mathrel{=}\Conid{Var}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{Num}\;\Varid{nat}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{Lam}\;(\Varid{a}\to \Conid{PLambda}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{App}\;(\Conid{PLambda}\;\Varid{a})\;(\Conid{PLambda}\;\Varid{a});{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

Next we define the evaluator for our lambda calculus. One advantage of PHOAS is that, environments are implicitly handled by the meta-language, thus the type of the evaluator is simply \ensuremath{\Varid{plambda}\;\Varid{value}\to \Varid{value}}. The code is presented as below:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Value}{}\<[13]%
\>[13]{}\mathrel{=}\Conid{VI}\;\Varid{nat}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{VF}\;(\Conid{Value}\to \Conid{Value});{}\<[E]%
\\
\>[B]{}\mathbf{let}\;\Varid{eval}\mathbin{:}\Conid{PLambda}\;\Conid{Value}\to \Conid{Value}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mu\;\Varid{ev}\mathbin{:}\Conid{PLambda}\;\Conid{Value}\to \Conid{Value}.{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\lambda \Varid{e}\mathbin{:}\Conid{PLambda}\;\Conid{Value}.\mathbf{case}\;\Varid{e}\;\mathbf{of}{}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\Conid{Var}\;(\Varid{v}\mathbin{:}\Conid{Value})\Rightarrow \Varid{v}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\mid \Conid{Num}\;(\Varid{n}\mathbin{:}\Varid{nat}){}\<[24]%
\>[24]{}\Rightarrow \Conid{VI}\;\Varid{n}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\mid \Conid{Lam}\;(\Varid{f}\mathbin{:}\Conid{Value}\to \Conid{PLambda}\;\Conid{Value})\Rightarrow {}\<[E]%
\\
\>[6]{}\hsindent{4}{}\<[10]%
\>[10]{}\Conid{VF}\;(\lambda \Varid{x}\mathbin{:}\Conid{Value}.\Varid{ev}\;(\Varid{f}\;\Varid{x})){}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\mid \Conid{App}\;(\Varid{a}\mathbin{:}\Conid{PLambda}\;\Conid{Value})\;(\Varid{b}\mathbin{:}\Conid{PLambda}\;\Conid{Value})\Rightarrow {}\<[E]%
\\
\>[6]{}\hsindent{3}{}\<[9]%
\>[9]{}\mathbf{case}\;(\Varid{ev}\;\Varid{a})\;\mathbf{of}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\Conid{VI}\;(\Varid{n}\mathbin{:}\Varid{nat}){}\<[35]%
\>[35]{}\Rightarrow \Conid{VI}\;\Varid{n}\mbox{\onelinecomment  impossible to reach}{}\<[E]%
\\
\>[6]{}\hsindent{3}{}\<[9]%
\>[9]{}\mid \Conid{VF}\;(\Varid{f}\mathbin{:}\Conid{Value}\to \Conid{Value})\Rightarrow \Varid{f}\;(\Varid{ev}\;\Varid{b}){}\<[E]%
\\
\>[B]{}\mathbf{in}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

Now we can evaluate some lambda expression and get the result back:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{let}\;\Varid{show}\mathbin{:}\Conid{Value}\to \Varid{nat}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\lambda \Varid{e}\mathbin{:}\Conid{Value}.\mathbf{case}\;\Varid{e}\;\mathbf{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{VI}\;(\Varid{n}\mathbin{:}\Varid{nat}){}\<[29]%
\>[29]{}\Rightarrow \Varid{n}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{VF}\;(\Varid{f}\mathbin{:}\Conid{Value}\to \Conid{Value})\Rightarrow \mathrm{10000}\mbox{\onelinecomment  impossible to reach}{}\<[E]%
\\
\>[B]{}\mathbf{in}{}\<[E]%
\\
\>[B]{}\mathbf{let}\;\Varid{example}\mathbin{:}\Conid{PLambda}\;\Conid{Value}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{App}\;\Conid{Value}\;{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}(\Conid{Lam}\;\Conid{Value}\;(\lambda \Varid{x}\mathbin{:}\Conid{Value}.\Conid{Var}\;\Conid{Value}\;\Conid{X}))\;{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}(\Conid{Num}\;\Conid{Value}\;\mathrm{42}){}\<[E]%
\\
\>[B]{}\mathbf{in}{}\<[E]%
\\
\>[B]{}\Varid{show}\;(\Varid{eval}\;\Varid{example})\mbox{\onelinecomment  return 42}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

\subsection{Perfect binary trees}
\label{sec:binTree}

A perfect binary tree is a binary tree whose size is exactly a power of two. In Haskell, perfect binary trees are usually represented using nested datatypes. We show that \name is able to encode nested datatypes.

First we define a pair datatype as follows:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{PairT}\;(\Varid{a}\mathbin{:}\mathbin{*})\;(\Varid{b}\mathbin{:}\mathbin{*})\mathrel{=}\Conid{Pair}\;\Varid{a}\;\Varid{b};{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

Using pairs, perfect binary trees are easily defined as:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{B}\;(\Varid{a}\mathbin{:}\mathbin{*})\mathrel{=}\Conid{One}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\mid \Conid{Two}\;(\Conid{B}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a}));{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

Notice that the recursive use of \emph{B} does not hold \emph{a}, but \emph{PairT a a}. This means every time we use a \emph{Two} constructor, the size of the pairs doubles. In case you are curious about the encoding of \emph{B}, here is the one:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{let}\;\Conid{B}\mathbin{:}\mathbin{*}\to \mathbin{*}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mu\;\Conid{X}\mathbin{:}\mathbin{*}\to \mathbin{*}.{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\mathbin{*}.\lambda \Conid{B}\mathbin{:}\mathbin{*}.(\Varid{a}\to \Conid{B})\to (\Conid{X}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\to \Conid{B})\to \Conid{B}\;\mathbf{in}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

Because of the polymorphic recursive type ($\mu X : \star \rightarrow \star $) being used, it is fairly straightforward to encode nested datatypes.

To easily construct a perfect binary tree from a list, we define a help function:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{let}\;\Varid{pairs}\mathbin{:}(\Varid{a}\mathbin{:}\mathbin{*})\to \Conid{List}\;\Varid{a}\to \Conid{List}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mu\;\Varid{pairs'}\mathbin{:}(\Varid{a}\mathbin{:}\mathbin{*})\to \Conid{List}\;\Varid{a}\to \Conid{List}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a}).{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\mathbin{*}.\lambda \Varid{xs}\mathbin{:}\Conid{List}\;\Varid{a}.{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbf{case}\;\Varid{xs}\;\mathbf{of}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\Conid{Nil}\Rightarrow \Conid{Nil}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mid \Conid{Cons}\;(\Varid{y}\mathbin{:}\Varid{a})\;(\Varid{ys}\mathbin{:}\Conid{List}\;\Varid{a})\Rightarrow {}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mathbf{case}\;\Varid{ys}\;\mathbf{of}\;\Conid{Nil}\Rightarrow {}\<[E]%
\\
\>[13]{}\hsindent{2}{}\<[15]%
\>[15]{}\Conid{Nil}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a}){}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mid \Conid{Cons}\;(\Varid{y'}\mathbin{:}\Varid{a})\;(\Varid{ys'}\mathbin{:}\Conid{List}\;\Varid{a})\Rightarrow {}\<[E]%
\\
\>[13]{}\hsindent{4}{}\<[17]%
\>[17]{}\Conid{Cons}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\;(\Conid{Pair}\;\Varid{a}\;\Varid{a}\;\Varid{y}\;\Varid{y'})\;(\Varid{pairs'}\;\Varid{a}\;\Varid{ys'}){}\<[E]%
\\
\>[3]{}\mathbf{in}{}\<[E]%
\\
\>[3]{}\mathbf{let}\;\Varid{fromList}\mathbin{:}(\Varid{a}\mathbin{:}\mathbin{*})\to \Conid{List}\;\Varid{a}\to \Conid{B}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mu\;\Varid{from'}\mathbin{:}(\Varid{a}\mathbin{:}\mathbin{*})\to \Conid{List}\;\Varid{a}\to \Conid{B}\;\Varid{a}.{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\mathbin{*}.\lambda \Varid{xs}\mathbin{:}\Conid{List}\;\Varid{a}.{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbf{case}\;\Varid{xs}\;\mathbf{of}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\Conid{Nil}\Rightarrow \Conid{Two}\;\Varid{a}\;(\Varid{from'}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\;(\Varid{pairs}\;\Varid{a}\;(\Conid{Nil}\;\Varid{a}))){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mid \Conid{Cons}\;(\Varid{x}\mathbin{:}\Varid{a})\;(\Varid{xs'}\mathbin{:}\Conid{List}\;\Varid{a})\Rightarrow {}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\mathbf{case}\;\Varid{xs'}\;\mathbf{of}{}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}\Conid{Nil}\Rightarrow \Conid{One}\;\Varid{a}\;\Varid{x}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\mid \Conid{Cons}\;(\Varid{y}\mathbin{:}\Varid{a})\;(\Varid{zs}\mathbin{:}\Conid{List}\;\Varid{a})\Rightarrow {}\<[E]%
\\
\>[11]{}\hsindent{4}{}\<[15]%
\>[15]{}\Conid{Two}\;\Varid{a}\;(\Varid{from'}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\;(\Varid{pairs}\;\Varid{a}\;\Varid{xs})){}\<[E]%
\\
\>[3]{}\mathbf{in}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

Now we can define an interesting function \emph{powerTwo}. Given a natural number $n$, it compute the largest natural number $m$, such that $2^{m} < n$:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{let}\;\Varid{twos}\mathbin{:}(\Varid{a}\mathbin{:}\mathbin{*})\to \Conid{B}\;\Varid{a}\to \Varid{nat}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mu\;\Varid{twos'}\mathbin{:}(\Varid{a}\mathbin{:}\mathbin{*})\to \Conid{B}\;\Varid{a}\to \Varid{nat}.{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\mathbin{*}.\lambda \Varid{x}\mathbin{:}\Conid{B}\;\Varid{a}.{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbf{case}\;\Varid{x}\;\mathbf{of}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\Conid{One}\;(\Varid{y}\mathbin{:}\Varid{a})\Rightarrow \mathrm{0}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mid \Conid{Two}\;(\Varid{c}\mathbin{:}\Conid{B}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a}))\Rightarrow {}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mathrm{1}\mathbin{+}\Varid{twos'}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\;\Varid{c}{}\<[E]%
\\
\>[3]{}\mathbf{in}{}\<[E]%
\\
\>[3]{}\mathbf{let}\;\Varid{powerTwo}\mathbin{:}\Conid{Nat}\to \Varid{nat}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\lambda \Varid{n}\mathbin{:}\Conid{Nat}.\Varid{twos}\;\Varid{nat}\;(\Varid{fromList}\;\Varid{nat}\;(\Varid{take}\;\Varid{n}\;(\Varid{repeat}\;\mathrm{1}))){}\<[E]%
\\
\>[3]{}\mathbf{in}\;\Varid{powerTwo}\;(\Conid{S}\;(\Conid{S}\;(\Conid{S}\;(\Conid{S}\;\Conid{Z}))))\mbox{\onelinecomment  return 2}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
