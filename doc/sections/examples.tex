%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%



\section{Showcase}
\label{sec:app}

In this section, we showcase applications, which either Haskell needs non-trivial extensions to do that, or dependently typed languages like Coq and Agda are impossible to do, whereas we can easily achieve in \name.

% \subsection{Parametric HOAS}
% \label{sec:phoas}

% Parametric Higher Order Abstract Syntax (PHOAS) is a higher order approach to represent binders, in which the function space of the meta-language is used to encode the binders of the object language. We show that \name can handle PHOAS by encoding lambda calculus as below:

% \begin{figure}[h!]
% \begin{spec}
% data PLambda (a : *) = Var a
%    | Num nat
%    | Lam (a -> PLambda a)
%    | App (PLambda a) (PLambda a);
% \end{spec}
% \end{figure}

% Next we define the evaluator for our lambda calculus. One advantage of PHOAS is that, environments are implicitly handled by the meta-language, thus the type of the evaluator is simply |plambda value -> value|. The code is presented in Figure~\ref{fig:phoas}.

% \begin{figure}[ht]
% \begin{spec}
% data Value  = VI nat
%    | VF (Value -> Value);
% let eval : PLambda Value -> Value =
%    mu ev : PLambda Value -> Value .
%      \ e : PLambda Value . case e of
%        Var (v : Value) => v
%      | Num (n : nat)   => VI n
%      | Lam (f : Value -> PLambda Value) =>
%          VF (\ x : Value . ev (f x))
%      | App (a : PLambda Value) (b : PLambda Value) =>
%         case (ev a) of
%           VI (n : nat)            => VI n -- impossible to reach
%         | VF (f : Value -> Value) => f (ev b)
% in
% \end{spec}
%   \caption{Lambda Calculus in PHAOS}
%   \label{fig:phoas}
% \end{figure}

% Now we can evaluate some lambda expression and get the result back as in Figure~\ref{fig:pex}

% \begin{figure}[ht]
% \begin{spec}
% let show : Value -> nat =
%   \ e : Value . case e of
%     VI (n : nat)            => n
%   | VF (f : Value -> Value) => 10000 -- impossible to reach
% in
% let example : PLambda Value =
%   App Value
%       (Lam Value (\ x : Value . Var Value X))
%       (Num Value 42)
% in show (eval example) -- return 42
% \end{spec}
% \caption{Example of using PHOAS}
% \label{fig:pex}
% \end{figure}

\subsubsection{Conventional datatypes}

Conventional datatypes like natural numbers or polymorphic lists can be easily defined in \name, as in Haskell. For example, below is the definition of polymorphic lists:

\begin{figure}[H]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{List}\;(\Varid{a}\mathbin{:}\star)\mathrel{=}\Conid{Nil}\mid \Conid{Cons}\;\Varid{a}\;(\Conid{List}\;\Varid{a});{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

Because \name is explicitly typed, each type parameter needs to be accompanied with corresponding kind expressions. The use of the above datatype is best illustrated by the \emph{length} function:

\begin{figure}[h!]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{letrec}\;\Varid{length}\mathbin{:}(\Varid{a}\mathbin{:}\star)\to \Conid{List}\;\Varid{a}\to \Varid{nat}\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\star.\,\lambda \Varid{l}\mathbin{:}\Conid{List}\;\Varid{a}.\,\mathbf{case}\;\Varid{l}\;\mathbf{of}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{}\Conid{Nil}\Rightarrow \mathrm{0}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mid {}\<[10]%
\>[10]{}\Conid{Cons}\;(\Varid{x}\mathbin{:}\Varid{a})\;(\Varid{xs}\mathbin{:}\Conid{List}\;\Varid{a})\Rightarrow \mathrm{1}\mathbin{+}\Varid{length}\;\Varid{a}\;\Varid{xs}{}\<[E]%
\\
\>[5]{}\mathbf{in}{}\<[E]%
\\
\>[5]{}\mathbf{let}\;\Varid{test}\mathbin{:}\Conid{List}\;\Varid{nat}\mathrel{=}\Conid{Cons}\;\Varid{nat}\;\mathrm{1}\;(\Conid{Cons}\;\Varid{nat}\;\mathrm{2}\;(\Conid{Nil}\;\Varid{nat})){}\<[E]%
\\
\>[5]{}\mathbf{in}\;\Varid{length}\;\Varid{nat}\;\Varid{test}\mbox{\onelinecomment  return 2}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

\subsubsection{Higher-kinded types}

Higher-kinded types are types that take other types and produce a new type. To support higher-kinded types, languages like Haskell have to extend their existing core languages to account for kind expressions. In \name, since all syntactical constructs are in the same level, we can easily construct higher-kinded types. We show this by an example of encoding the \emph{Functor} class:

\begin{figure}[h!]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{rcrd}\;\Conid{Functor}\;(\Varid{f}\mathbin{:}\star\to \star)\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Func}\;\{\mskip1.5mu \Varid{fmap}\mathbin{:}(\Varid{a}\mathbin{:}\star)\to (\Varid{b}\mathbin{:}\star)\to \Varid{f}\;\Varid{a}\to \Varid{f}\;\Varid{b}\mskip1.5mu\};{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

A functor is just a record that has only one field \emph{fmap}. A Functor instance of the \emph{Maybe} datatype is simply:

\begin{figure}[h!]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}c<{\hspost}@{}}%
\column{8E}{@{}l@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{let}\;\Varid{maybeInst}\mathbin{:}\Conid{Functor}\;\Conid{Maybe}\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Func}\;\Conid{Maybe}\;(\lambda \Varid{a}\mathbin{:}\star.\,\lambda \Varid{b}\mathbin{:}\star.\,\lambda \Varid{f}\mathbin{:}\Varid{a}\to \Varid{b}.\,\lambda \Varid{x}\mathbin{:}\Conid{Maybe}\;\Varid{a}.\,{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbf{case}\;\Varid{x}\;\mathbf{of}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\Conid{Nothing}\Rightarrow \Conid{Nothing}\;\Varid{b}{}\<[E]%
\\
\>[7]{}\hsindent{1}{}\<[8]%
\>[8]{}\mid {}\<[8E]%
\>[11]{}\Conid{Just}\;(\Varid{z}\mathbin{:}\Varid{a})\Rightarrow \Conid{Just}\;\Varid{b}\;(\Varid{f}\;\Varid{z})){}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

\subsubsection{HOAS}

\emph{Higher-order abstract syntax} is a generalization of representing programs where the function space of the meta-language is used to encode the binders of the object language. Because the recursive mention of the datatype can appear in a negative position, systems like Coq and Agda would reject programs using HOAS due to the restrictiveness of their termination checkers. However \name is able to express HOAS in a straightforward way. We show an example of encoding a simple lambda calculus:

\begin{figure}[h!]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}c<{\hspost}@{}}%
\column{5E}{@{}l@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{Exp}\mathrel{=}\Conid{Num}\;\Varid{nat}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid {}\<[5E]%
\>[8]{}\Conid{Lam}\;(\Conid{Exp}\to \Conid{Exp}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid {}\<[5E]%
\>[8]{}\Conid{App}\;\Conid{Exp}\;\Conid{Exp};{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

Next we define the evaluator for our lambda calculus. As noted by~\cite{Fegaras1996}, the evaluation function needs an extra function \emph{reify} to invert the result of evaluation. The code is presented in Figure~\ref{fig:hoas}.

\begin{figure}[ht]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Value}\mathrel{=}\Conid{VI}\;\Varid{nat}\mid \Conid{VF}\;(\Conid{Value}\to \Conid{Value});{}\<[E]%
\\
\>[B]{}\mathbf{rcrd}\;\Conid{Eval}\mathrel{=}\Conid{Ev}\;\{\mskip1.5mu \Varid{eval'}\mathbin{:}\Conid{Exp}\to \Conid{Value},\Varid{reify'}\mathbin{:}\Conid{Value}\to \Conid{Exp}\mskip1.5mu\};{}\<[E]%
\\
\>[B]{}\mathbf{let}\;\Varid{f}\mathbin{:}\Conid{Eval}\mathrel{=}\mu\;\Varid{f'}\mathbin{:}\Conid{Eval}.\,{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Ev}\;{}\<[7]%
\>[7]{}(\lambda \Varid{e}\mathbin{:}\Conid{Exp}.\,\mathbf{case}\;\Varid{e}\;\mathbf{of}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Conid{Num}\;(\Varid{n}\mathbin{:}\Varid{nat})\Rightarrow \Conid{VI}\;\Varid{n}{}\<[E]%
\\
\>[7]{}\mid \Conid{Lam}\;(\Varid{fun}\mathbin{:}\Conid{Exp}\to \Conid{Exp})\Rightarrow {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Conid{VF}\;(\lambda \Varid{e'}\mathbin{:}\Conid{Value}.\,\Varid{eval'}\;\Varid{f'}\;(\Varid{fun}\;(\Varid{reify'}\;\Varid{f'}\;\Varid{e'}))){}\<[E]%
\\
\>[7]{}\mid \Conid{App}\;(\Varid{a}\mathbin{:}\Conid{Exp})\;(\Varid{b}\mathbin{:}\Conid{Exp})\Rightarrow {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\mathbf{case}\;\Varid{eval'}\;\Varid{f'}\;\Varid{a}\;\mathbf{of}{}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}\Conid{VI}\;(\Varid{n}\mathbin{:}\Varid{nat})\Rightarrow \Varid{error}{}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\mid \Conid{VF}\;(\Varid{fun}\mathbin{:}\Conid{Value}\to \Conid{Value})\Rightarrow \Varid{fun}\;(\Varid{eval'}\;\Varid{f'}\;\Varid{b}))\;{}\<[E]%
\\
\>[7]{}(\lambda \Varid{v}\mathbin{:}\Conid{Value}.\,\mathbf{case}\;\Varid{v}\;\mathbf{of}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Conid{VI}\;(\Varid{n}\mathbin{:}\Varid{nat})\Rightarrow \Conid{Num}\;\Varid{n}{}\<[E]%
\\
\>[7]{}\mid \Conid{VF}\;(\Varid{fun}\mathbin{:}\Conid{Value}\to \Conid{Value})\Rightarrow {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Conid{Lam}\;(\lambda \Varid{e'}\mathbin{:}\Conid{Exp}.\,(\Varid{reify'}\;\Varid{f'}\;(\Varid{fun}\;(\Varid{eval'}\;\Varid{f'}\;\Varid{e'}))))){}\<[E]%
\\
\>[B]{}\mathbf{in}\;\mathbf{let}\;\Varid{eval}\mathbin{:}\Conid{Exp}\to \Conid{Value}\mathrel{=}\Varid{eval'}\;\Varid{f}\;\mathbf{in}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
  \caption{An evaluator for the HOAS-encoded lambda calculus.}
  \label{fig:hoas}
\end{figure}

The definition of the evaluator is quite straightforward, although it is worth noting that the evaluator is a partial function that can cause run-time errors. Thanks to the flexibility of the $\mu$ primitive, mutual recursion can be encoded by using records!

Evaluation of a lambda expression proceeds as follows:

\begin{figure}[H]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{let}\;\Varid{test}\mathbin{:}\Conid{Exp}\mathrel{=}\Conid{App}\;{}\<[25]%
\>[25]{}(\Conid{Lam}\;(\lambda \Varid{f}\mathbin{:}\Conid{Exp}.\,\Conid{App}\;\Varid{f}\;(\Conid{Num}\;\mathrm{42})))\;{}\<[E]%
\\
\>[25]{}(\Conid{Lam}\;(\lambda \Varid{g}\mathbin{:}\Conid{Exp}.\,\Varid{g})){}\<[E]%
\\
\>[3]{}\mathbf{in}\;\Varid{show}\;(\Varid{eval}\;\Varid{test})\mbox{\onelinecomment  return 42}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

\subsubsection{Fix as a datatype}

The type-level \emph{Fix} is a good example to demonstrate the expressiveness of \name. The definition is simply:

\begin{figure}[H]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{rcrd}\;\Conid{Fix}\;(\Varid{f}\mathbin{:}\star\to \star)\mathrel{=}\Conid{In}\;\{\mskip1.5mu \Varid{out}\mathbin{:}(\Varid{f}\;(\Conid{Fix}\;\Varid{f}))\mskip1.5mu\};{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

The record notation also introduces the selector function: \ensuremath{\Varid{out}\mathbin{:}(\Varid{f}\mathbin{:}\star\to \star)\to \Conid{Fix}\;\Varid{f}\to \Varid{f}\;(\Conid{Fix}\;\Varid{f})}. The \emph{Fix} datatype is interesting in that Coq and Agda would reject this definition because the use of the higher-kinded type parameter \emph{f} could be anywhere (e.g., in a negative position). However in \name, where type-level computation is explicitly controlled, we can safely use \emph{Fix} in the program.

Given \emph{fmap}, many recursive shcemes can be defined, for example  we can have \emph{catamorphism} or generic function fold:

\begin{figure}[H]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{letrec}\;\Varid{cata}\mathbin{:}{}\<[20]%
\>[20]{}(\Varid{f}\mathbin{:}\star\to \star)\to (\Varid{a}\mathbin{:}\star)\to {}\<[E]%
\\
\>[20]{}\Conid{Functor}\;\Varid{f}\to (\Varid{f}\;\Varid{a}\to \Varid{a})\to \Conid{Fix}\;\Varid{f}\to \Varid{a}\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{f}\mathbin{:}\star\to \star.\,\lambda \Varid{a}\mathbin{:}\star.\,\lambda \Varid{m}\mathbin{:}\Conid{Functor}\;\Varid{f}.\,\lambda \Varid{g}\mathbin{:}\Varid{f}\;\Varid{a}\to \Varid{a}.\,\lambda \Varid{t}\mathbin{:}\Conid{Fix}\;\Varid{f}.\,{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Varid{g}\;(\Varid{fmap}\;\Varid{f}\;\Varid{m}\;(\Conid{Fix}\;\Varid{f})\;\Varid{a}\;(\Varid{cata}\;\Varid{f}\;\Varid{a}\;\Varid{m}\;\Varid{g})\;(\Varid{out}\;\Varid{f}\;\Varid{t})){}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}


\subsubsection{Kind polymophism for datatypes}

In Haskell, System $F_{c}^{\uparrow}$ was proposed to support kind polymorphism. However it separates expressions into terms, types and kinds, which complicates both the implementation and future extensions. \name natively allows datatype definitions to have polymorphic kinds. Here is an example, taken from~\cite{fc:pro}, of a datatype that benefits from kind polymophism: higher-kinded fixpoint combinator

\begin{figure}[H]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{data}\;\Conid{Mu}\;(\Varid{k}\mathbin{:}\star)\;(\Varid{f}\mathbin{:}(\Varid{k}\to \star)\to \Varid{k}\to \star)\;(\Varid{a}\mathbin{:}\Varid{k})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Roll}\;(\Varid{f}\;(\Conid{Mu}\;\Varid{k}\;\Varid{f})\;\Varid{a});{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

\emph{Mu} can be used to construct polymorphic recursive types of any kind, for instance:

\begin{figure}[H]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{data}\;\Conid{Listf}\;(\Varid{f}\mathbin{:}\star\to \star)\;(\Varid{a}\mathbin{:}\star)\mathrel{=}\Conid{Nil}\mid \Conid{Cons}\;\Varid{a}\;(\Varid{f}\;\Varid{a});{}\<[E]%
\\
\>[5]{}\mathbf{let}\;\Conid{List}\mathbin{:}\star\to \star\mathrel{=}\lambda \Varid{a}\mathbin{:}\star.\,\Conid{Mu}\star\Conid{Listf}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

\subsubsection{Nested datatypes and polymorphic recursion}

A nested datatype, also known as a \emph{non-regular} datatype, is a parametrised datatype whose definition contains different instances of the type parameters. Functions over nested datatypes usually involve polymorphic recursion. We show that \name is capable of defining all useful functions over a nested datatype. A simple example would be the type \emph{Pow} of power trees, whose size is exactly a power of two, declared as follows:

\begin{figure}[H]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{PairT}\;(\Varid{a}\mathbin{:}\star)\mathrel{=}\Conid{P}\;\Varid{a}\;\Varid{a};{}\<[E]%
\\
\>[3]{}\mathbf{data}\;\Conid{Pow}\;(\Varid{a}\mathbin{:}\star)\mathrel{=}\Conid{Zero}\;\Varid{a}\mid \Conid{Succ}\;(\Conid{Pow}\;(\Conid{PairT}\;\Varid{a}));{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

Notice that the recursive mention of \emph{Pow} does not hold \emph{a}, but \emph{PairT a}. This means every time we use a \emph{Succ} constructor, the size of the pairs doubles. In case you are curious about the encoding of \emph{Pow}, here is the one:

\begin{figure}[H]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{let}\;\Conid{Pow}\mathbin{:}\star\to \star\mathrel{=}\mu\;\Conid{X}\mathbin{:}\star\to \star.\,{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\star.\,(\Conid{B}\mathbin{:}\star)\to (\Varid{a}\to \Conid{B})\to (\Conid{X}\;(\Conid{PairT}\;\Varid{a})\to \Conid{B})\to \Conid{B}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

Notice how the higher-kinded type variable \ensuremath{\Conid{X}\mathbin{:}\star\to \star} helps encoding nested datatypes. Below is a simple function \emph{toList} that transforms a power tree into a list:

\begin{figure}[H]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{letrec}\;\Varid{toList}\mathbin{:}(\Varid{a}\mathbin{:}\star)\to \Conid{Pow}\;\Varid{a}\to \Conid{List}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\star.\,\lambda \Varid{t}\mathbin{:}\Conid{Pow}\;\Varid{a}.\,\mathbf{case}\;\Varid{t}\;\mathbf{of}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{}\Conid{Zero}\;(\Varid{x}\mathbin{:}\Varid{a})\Rightarrow \Conid{Cons}\;\Varid{a}\;\Varid{x}\;(\Conid{Nil}\;\Varid{a}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mid {}\<[10]%
\>[10]{}\Conid{Succ}\;(\Varid{c}\mathbin{:}\Conid{Pow}\;(\Conid{PairT}\;\Varid{a}))\Rightarrow {}\<[E]%
\\
\>[10]{}\hsindent{2}{}\<[12]%
\>[12]{}\Varid{concatMap}\;(\Conid{PairT}\;\Varid{a})\;\Varid{a}\;{}\<[E]%
\\
\>[12]{}\hsindent{2}{}\<[14]%
\>[14]{}(\lambda \Varid{x}\mathbin{:}\Conid{PairT}\;\Varid{a}.\,\mathbf{case}\;\Varid{x}\;\mathbf{of}{}\<[E]%
\\
\>[14]{}\hsindent{3}{}\<[17]%
\>[17]{}\Conid{P}\;(\Varid{m}\mathbin{:}\Varid{a})\;(\Varid{n}\mathbin{:}\Varid{a})\Rightarrow {}\<[E]%
\\
\>[17]{}\hsindent{2}{}\<[19]%
\>[19]{}\Conid{Cons}\;\Varid{a}\;\Varid{m}\;(\Conid{Cons}\;\Varid{a}\;\Varid{n}\;(\Conid{Nil}\;\Varid{a})))\;{}\<[E]%
\\
\>[12]{}\hsindent{2}{}\<[14]%
\>[14]{}(\Varid{toList}\;(\Conid{PairT}\;\Varid{a})\;\Varid{c}){}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}



% \subsubsection{Nested datatypes}
% \label{sec:binTree}

% A perfect binary tree is a binary tree whose size is exactly a power of two. In Haskell, perfect binary trees are usually represented using nested datatypes. We show that \name is able to encode nested datatypes.

% First we define a pair datatype as follows:

% \begin{figure}[H]
% \begin{spec}
%   data PairT (a : *) (b : *) = P a b;
% \end{spec}
% \end{figure}

% Using pairs, perfect binary trees are easily defined as below:

% \begin{figure}[h!]
% \begin{spec}
%   data B (a : *) = One a | Two (B (PairT a a));
% \end{spec}
% \end{figure}

% Notice that the recursive use of \emph{B} does not hold \emph{a}, but \emph{PairT a a}. This means every time we use a \emph{Two} constructor, the size of the pairs doubles. In case you are curious about the encoding of \emph{B}, here is the one:

% \begin{figure}[h!]
% \begin{spec}
%   let B : * -> * = mu X : * -> * .
%       \ a : * . (B : *) -> (a -> B) -> (X (PairT a a) -> B) -> B
%   in
% \end{spec}
% \end{figure}

% Because of the polymorphic recursive type ($\mu X : \star \rightarrow \star $) being used, it is fairly straightforward to encode nested datatypes.

% To easily construct a perfect binary tree from a list, we define a help function that transform a list to a perfect binary tree as shown in Figure~\ref{fig:perfectB}.

% \begin{figure}[ht]
% \begin{spec}
%   let pairs : (a : *) -> List a -> List (PairT a a) =
%     mu pairs' : (a : *) -> List a -> List (PairT a a) .
%       \ a : * . \ xs : List a .
%         case xs of
%           Nil => Nil (PairT a a)
%         | Cons (y : a) (ys : List a) =>
%             case ys of Nil =>
%               Nil (PairT a a)
%             | Cons (y' : a) (ys' : List a) =>
%                 Cons (PairT a a) (P a a y y') (pairs' a ys')
%   in
%   let fromList : (a : *) -> List a -> B a =
%     mu from' : (a : *) -> List a -> B a .
%       \ a : * . \xs : List a .
%         case xs of
%           Nil => Two a (from' (PairT a a) (pairs a (Nil a)))
%         | Cons (x : a) (xs' : List a) =>
%           case xs' of
%             Nil => One a x
%           | Cons (y : a) (zs : List a) =>
%               Two a (from' (PairT a a) (pairs a xs))
%   in
% \end{spec}
%   \caption{Construct a perfect binary tree from a list}
%   \label{fig:perfectB}
% \end{figure}

% Now we can define an interesting function \emph{powerTwo}. Given a natural number $n$, it computes the largest natural number $m$, such that $2^{m} < n$:

% \begin{figure}[H]
% \begin{spec}
%   let twos : (a : *) -> B a -> nat =
%     mu twos' : (a : *) -> B a -> nat .
%       \ a : * . \x : B a .
%         case x of
%           One (y : a) => 0
%         | Two (c : B (PairT a a)) =>
%             1 + twos' (PairT a a) c
%   in
%   let powerTwo : Nat -> nat =
%     \ n : Nat . twos nat (fromList nat (take n (repeat 1)))
%   in powerTwo (S (S (S (S Z)))) -- return 2
% \end{spec}
% \end{figure}
