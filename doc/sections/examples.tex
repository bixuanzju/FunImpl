%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%



\section{Applications}
\label{sec:app}

In this section, we show applications, which either Haskell needs non-trivial extensions to do that, or languages like Coq and Agda are impossible to do, whereas we can easily achieve in \name.

% \subsection{Parametric HOAS}
% \label{sec:phoas}

% Parametric Higher Order Abstract Syntax (PHOAS) is a higher order approach to represent binders, in which the function space of the meta-language is used to encode the binders of the object language. We show that \name can handle PHOAS by encoding lambda calculus as below:

% \begin{figure}[h!]
% \begin{spec}
% data PLambda (a : *) = Var a
%    | Num nat
%    | Lam (a -> PLambda a)
%    | App (PLambda a) (PLambda a);
% \end{spec}
% \end{figure}

% Next we define the evaluator for our lambda calculus. One advantage of PHOAS is that, environments are implicitly handled by the meta-language, thus the type of the evaluator is simply |plambda value -> value|. The code is presented in Figure~\ref{fig:phoas}.

% \begin{figure}[ht]
% \begin{spec}
% data Value  = VI nat
%    | VF (Value -> Value);
% let eval : PLambda Value -> Value =
%    mu ev : PLambda Value -> Value .
%      \ e : PLambda Value . case e of
%        Var (v : Value) => v
%      | Num (n : nat)   => VI n
%      | Lam (f : Value -> PLambda Value) =>
%          VF (\ x : Value . ev (f x))
%      | App (a : PLambda Value) (b : PLambda Value) =>
%         case (ev a) of
%           VI (n : nat)            => VI n -- impossible to reach
%         | VF (f : Value -> Value) => f (ev b)
% in
% \end{spec}
%   \caption{Lambda Calculus in PHAOS}
%   \label{fig:phoas}
% \end{figure}

% Now we can evaluate some lambda expression and get the result back as in Figure~\ref{fig:pex}

% \begin{figure}[ht]
% \begin{spec}
% let show : Value -> nat =
%   \ e : Value . case e of
%     VI (n : nat)            => n
%   | VF (f : Value -> Value) => 10000 -- impossible to reach
% in
% let example : PLambda Value =
%   App Value
%       (Lam Value (\ x : Value . Var Value X))
%       (Num Value 42)
% in show (eval example) -- return 42
% \end{spec}
% \caption{Example of using PHOAS}
% \label{fig:pex}
% \end{figure}

\subsubsection{Conventional datatypes}

Conventional datatypes like natural numbers or polymorphic lists can be easily defined in \name, as in Haskell. For example, below is the definition of polymorphic lists:

\begin{figure}[H]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{List}\;(\Varid{a}\mathbin{:}\star)\mathrel{=}\Conid{Nil}\mid \Conid{Cons}\;\Varid{a}\;(\Conid{List}\;\Varid{a});{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

Because \name is explicitly typed, each type parameter needs to be accompanied with corresponding kind expressions. The use of the above datatype is best illustrated by the \emph{length} function:

\begin{figure}[h!]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{letrec}\;\Varid{length}\mathbin{:}(\Varid{a}\mathbin{:}\star)\to \Conid{List}\;\Varid{a}\to \Varid{nat}\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\star.\,\lambda \Varid{l}\mathbin{:}\Conid{List}\;\Varid{a}.\,\mathbf{case}\;\Varid{l}\;\mathbf{of}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Conid{Nil}\Rightarrow \mathrm{0}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mid \Conid{Cons}\;(\Varid{x}\mathbin{:}\Varid{a})\;(\Varid{xs}\mathbin{:}\Conid{List}\;\Varid{a})\Rightarrow {}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathrm{1}\mathbin{+}\Varid{length}\;\Varid{a}\;\Varid{xs}{}\<[E]%
\\
\>[5]{}\mathbf{in}{}\<[E]%
\\
\>[5]{}\mathbf{let}\;\Varid{test}\mathbin{:}\Conid{List}\;\Varid{nat}\mathrel{=}\Conid{Cons}\;\Varid{nat}\;\mathrm{1}\;(\Conid{Cons}\;\Varid{nat}\;\mathrm{2}\;(\Conid{Nil}\;\Varid{nat})){}\<[E]%
\\
\>[5]{}\mathbf{in}\;\Varid{length}\;\Varid{nat}\;\Varid{test}\mbox{\onelinecomment  return 2}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

\subsubsection{Higher-kinded types}

\jeremy{Functor example}


\subsubsection{HOAS}

\emph{Higher-order abstract syntax} is a generalization of representing programs where the function space of the meta-language is used to encode the binders of the object language. Because the recursive mention of the datatype can appear in a negative position, systems like Coq and Agda would reject programs using HOAS due to the restrictiveness of their termination checkers. However \name is able to express HOAS in a straightforward way. We show an example of encoding simply typed lambda calculus:

\begin{figure}[h!]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{Exp}\mathrel{=}\Conid{Num}\;\Varid{nat}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid \Conid{Lam}\;(\Conid{Exp}\to \Conid{Exp}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid \Conid{App}\;\Conid{Exp}\;\Conid{Exp};{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

Next we define the evaluator for our lambda calculus. As noted by [], the evaluation function needs an extra function \emph{reify} to invert the result of evaluation. The code is presented in Figure~\ref{fig:hoas}.

\begin{figure}[ht]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Value}\mathrel{=}\Conid{VI}\;\Varid{nat}\mid \Conid{VF}\;(\Conid{Value}\to \Conid{Value});{}\<[E]%
\\
\>[B]{}\mathbf{rcrd}\;\Conid{Eval}\mathrel{=}\Conid{Ev}\;\{\mskip1.5mu \Varid{eval'}\mathbin{:}\Conid{Exp}\to \Conid{Value},\Varid{reify'}\mathbin{:}\Conid{Value}\to \Conid{Exp}\mskip1.5mu\};{}\<[E]%
\\
\>[B]{}\mathbf{let}\;\Varid{f}\mathbin{:}\Conid{Eval}\mathrel{=}\mu\;\Varid{f'}\mathbin{:}\Conid{Eval}.\,{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Ev}\;(\lambda \Varid{e}\mathbin{:}\Conid{Exp}.\,\mathbf{case}\;\Varid{e}\;\mathbf{of}{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}\Conid{Num}\;(\Varid{n}\mathbin{:}\Varid{nat})\Rightarrow \Conid{VI}\;\Varid{n}{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\mid \Conid{Lam}\;(\Varid{fun}\mathbin{:}\Conid{Exp}\to \Conid{Exp})\Rightarrow {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Conid{VF}\;(\lambda \Varid{e'}\mathbin{:}\Conid{Value}.\,\Varid{eval'}\;\Varid{f'}\;(\Varid{fun}\;(\Varid{reify'}\;\Varid{f'}\;\Varid{e'}))){}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\mid \Conid{App}\;(\Varid{a}\mathbin{:}\Conid{Exp})\;(\Varid{b}\mathbin{:}\Conid{Exp})\Rightarrow {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\mathbf{case}\;\Varid{eval'}\;\Varid{f'}\;\Varid{a}\;\mathbf{of}{}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}\Conid{VI}\;(\Varid{n}\mathbin{:}\Varid{nat})\Rightarrow \Conid{VI}\;\Varid{n}\mbox{\onelinecomment  abnormal branch}{}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\mid \Conid{VF}\;(\Varid{fun}\mathbin{:}\Conid{Value}\to \Conid{Value})\Rightarrow \Varid{fun}\;(\Varid{eval'}\;\Varid{f'}\;\Varid{b}))\;{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}(\lambda \Varid{v}\mathbin{:}\Conid{Value}.\,\mathbf{case}\;\Varid{v}\;\mathbf{of}{}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\Conid{VI}\;(\Varid{n}\mathbin{:}\Varid{nat})\Rightarrow \Conid{Num}\;\Varid{n}\mbox{\onelinecomment  abnormal branch}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\mid \Conid{VF}\;(\Varid{fun}\mathbin{:}\Conid{Value}\to \Conid{Value})\Rightarrow {}\<[E]%
\\
\>[6]{}\hsindent{4}{}\<[10]%
\>[10]{}\Conid{Lam}\;(\lambda \Varid{e'}\mathbin{:}\Conid{Exp}.\,(\Varid{reify'}\;\Varid{f'}\;(\Varid{fun}\;(\Varid{eval'}\;\Varid{f'}\;\Varid{e'}))))){}\<[E]%
\\
\>[B]{}\mathbf{in}\;\mathbf{let}\;\Varid{eval}\mathbin{:}\Conid{Exp}\to \Conid{Value}\mathrel{=}\Varid{eval'}\;\Varid{f}\;\mathbf{in}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
  \caption{An evaluator for the HOAS-encoded lambda calculus.}
  \label{fig:hoas}
\end{figure}

The definition of the evaluator is quite straightforward, although it is worth noting that, because \name has yet have exception mechanism, we have to pattern match on all possibilities. (That is why we have \emph{abnormal} branches in the above code.) Thanks to the flexibility of the $\mu$ primitive, mutual recursion can be encoded by using records!

Evaluation of a lambda expression proceeds as follows:

\begin{figure}[h!]
  \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{let}\;\Varid{test}\mathbin{:}\Conid{Exp}\mathrel{=}\Conid{App}\;(\Conid{Lam}\;(\lambda \Varid{x}\mathbin{:}\Conid{Exp}.\,\Varid{x}))\;(\Conid{Num}\;\mathrm{42}){}\<[E]%
\\
\>[3]{}\mathbf{in}\;\Varid{show}\;(\Varid{eval}\;\Varid{test})\mbox{\onelinecomment  return 42}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

\subsubsection{Kind polymophism for datatypes}


\subsubsection{Nested datatypes}
\label{sec:binTree}

A perfect binary tree is a binary tree whose size is exactly a power of two. In Haskell, perfect binary trees are usually represented using nested datatypes. We show that \name is able to encode nested datatypes.

First we define a pair datatype as follows:

\begin{figure}[H]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{PairT}\;(\Varid{a}\mathbin{:}\star)\;(\Varid{b}\mathbin{:}\star)\mathrel{=}\Conid{P}\;\Varid{a}\;\Varid{b};{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

Using pairs, perfect binary trees are easily defined as below:

\begin{figure}[h!]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{B}\;(\Varid{a}\mathbin{:}\star)\mathrel{=}\Conid{One}\;\Varid{a}\mid \Conid{Two}\;(\Conid{B}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a}));{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

Notice that the recursive use of \emph{B} does not hold \emph{a}, but \emph{PairT a a}. This means every time we use a \emph{Two} constructor, the size of the pairs doubles. In case you are curious about the encoding of \emph{B}, here is the one:

\begin{figure}[h!]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{let}\;\Conid{B}\mathbin{:}\star\to \star\mathrel{=}\mu\;\Conid{X}\mathbin{:}\star\to \star.\,{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\star.\,(\Conid{B}\mathbin{:}\star)\to (\Varid{a}\to \Conid{B})\to (\Conid{X}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\to \Conid{B})\to \Conid{B}{}\<[E]%
\\
\>[3]{}\mathbf{in}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}

Because of the polymorphic recursive type ($\mu X : \star \rightarrow \star $) being used, it is fairly straightforward to encode nested datatypes.

To easily construct a perfect binary tree from a list, we define a help function that transform a list to a perfect binary tree as shown in Figure~\ref{fig:perfectB}.

\begin{figure}[ht]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{let}\;\Varid{pairs}\mathbin{:}(\Varid{a}\mathbin{:}\star)\to \Conid{List}\;\Varid{a}\to \Conid{List}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mu\;\Varid{pairs'}\mathbin{:}(\Varid{a}\mathbin{:}\star)\to \Conid{List}\;\Varid{a}\to \Conid{List}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a}).\,{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\star.\,\lambda \Varid{xs}\mathbin{:}\Conid{List}\;\Varid{a}.\,{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbf{case}\;\Varid{xs}\;\mathbf{of}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\Conid{Nil}\Rightarrow \Conid{Nil}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mid \Conid{Cons}\;(\Varid{y}\mathbin{:}\Varid{a})\;(\Varid{ys}\mathbin{:}\Conid{List}\;\Varid{a})\Rightarrow {}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mathbf{case}\;\Varid{ys}\;\mathbf{of}\;\Conid{Nil}\Rightarrow {}\<[E]%
\\
\>[13]{}\hsindent{2}{}\<[15]%
\>[15]{}\Conid{Nil}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a}){}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mid \Conid{Cons}\;(\Varid{y'}\mathbin{:}\Varid{a})\;(\Varid{ys'}\mathbin{:}\Conid{List}\;\Varid{a})\Rightarrow {}\<[E]%
\\
\>[13]{}\hsindent{4}{}\<[17]%
\>[17]{}\Conid{Cons}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\;(\Conid{P}\;\Varid{a}\;\Varid{a}\;\Varid{y}\;\Varid{y'})\;(\Varid{pairs'}\;\Varid{a}\;\Varid{ys'}){}\<[E]%
\\
\>[3]{}\mathbf{in}{}\<[E]%
\\
\>[3]{}\mathbf{let}\;\Varid{fromList}\mathbin{:}(\Varid{a}\mathbin{:}\star)\to \Conid{List}\;\Varid{a}\to \Conid{B}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mu\;\Varid{from'}\mathbin{:}(\Varid{a}\mathbin{:}\star)\to \Conid{List}\;\Varid{a}\to \Conid{B}\;\Varid{a}.\,{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\star.\,\lambda \Varid{xs}\mathbin{:}\Conid{List}\;\Varid{a}.\,{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbf{case}\;\Varid{xs}\;\mathbf{of}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\Conid{Nil}\Rightarrow \Conid{Two}\;\Varid{a}\;(\Varid{from'}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\;(\Varid{pairs}\;\Varid{a}\;(\Conid{Nil}\;\Varid{a}))){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mid \Conid{Cons}\;(\Varid{x}\mathbin{:}\Varid{a})\;(\Varid{xs'}\mathbin{:}\Conid{List}\;\Varid{a})\Rightarrow {}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\mathbf{case}\;\Varid{xs'}\;\mathbf{of}{}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}\Conid{Nil}\Rightarrow \Conid{One}\;\Varid{a}\;\Varid{x}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\mid \Conid{Cons}\;(\Varid{y}\mathbin{:}\Varid{a})\;(\Varid{zs}\mathbin{:}\Conid{List}\;\Varid{a})\Rightarrow {}\<[E]%
\\
\>[11]{}\hsindent{4}{}\<[15]%
\>[15]{}\Conid{Two}\;\Varid{a}\;(\Varid{from'}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\;(\Varid{pairs}\;\Varid{a}\;\Varid{xs})){}\<[E]%
\\
\>[3]{}\mathbf{in}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
  \caption{Construct a perfect binary tree from a list}
  \label{fig:perfectB}
\end{figure}

Now we can define an interesting function \emph{powerTwo}. Given a natural number $n$, it computes the largest natural number $m$, such that $2^{m} < n$:

\begin{figure}[H]
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{let}\;\Varid{twos}\mathbin{:}(\Varid{a}\mathbin{:}\star)\to \Conid{B}\;\Varid{a}\to \Varid{nat}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mu\;\Varid{twos'}\mathbin{:}(\Varid{a}\mathbin{:}\star)\to \Conid{B}\;\Varid{a}\to \Varid{nat}.\,{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{a}\mathbin{:}\star.\,\lambda \Varid{x}\mathbin{:}\Conid{B}\;\Varid{a}.\,{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbf{case}\;\Varid{x}\;\mathbf{of}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\Conid{One}\;(\Varid{y}\mathbin{:}\Varid{a})\Rightarrow \mathrm{0}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mid \Conid{Two}\;(\Varid{c}\mathbin{:}\Conid{B}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a}))\Rightarrow {}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mathrm{1}\mathbin{+}\Varid{twos'}\;(\Conid{PairT}\;\Varid{a}\;\Varid{a})\;\Varid{c}{}\<[E]%
\\
\>[3]{}\mathbf{in}{}\<[E]%
\\
\>[3]{}\mathbf{let}\;\Varid{powerTwo}\mathbin{:}\Conid{Nat}\to \Varid{nat}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\lambda \Varid{n}\mathbin{:}\Conid{Nat}.\,\Varid{twos}\;\Varid{nat}\;(\Varid{fromList}\;\Varid{nat}\;(\Varid{take}\;\Varid{n}\;(\Varid{repeat}\;\mathrm{1}))){}\<[E]%
\\
\>[3]{}\mathbf{in}\;\Varid{powerTwo}\;(\Conid{S}\;(\Conid{S}\;(\Conid{S}\;(\Conid{S}\;\Conid{Z}))))\mbox{\onelinecomment  return 2}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{figure}
