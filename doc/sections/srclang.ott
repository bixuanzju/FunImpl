% Formalization of Source Language

%%% Syntax
grammar

%% Declarations
pgm                                         :: 'pgm_' ::=      {{ com Program }}
  | << decl >> ; E                          ::   :: Decl       {{ com Declarations }}
  | decl ; E                                :: M :: DeclSingle
  | ( pgm )                                 :: M :: ParenPgm

decl                                        :: 'decl_' ::=     {{ com Declarations }}
  | data D << u : k >> = << K << A >> >> ::   :: DataDecl   {{ com Datatype declaration }}
  | data D << u : k >> = K << A >>          :: M :: SDataDecl  {{ com Datatype single }}
  | data R << u : k >> = K { << N : A >> }  :: M :: RecordDecl {{ com Record declaration }}
  | ( decl )                                :: M :: ParenDecl
  | << decl >>                              :: M :: DeclVec

p                                           :: 'pat_' ::=      {{ com Patterns }}
  | K << x : A >>                           ::   :: Pattern    {{ com Pattern }}
  | ( p )                                   :: M :: ParenPat

u, U {{ tex \upsilon }}                     :: 'u_'   ::=      {{ com Atoms }}
  | x                                       ::  :: Var         {{ com Variable }}
  | K                                       ::  :: DCon        {{ com Data constructor }}

%% Expressions
E , A {{ tex T }}, B {{ tex S }}, k {{ tex \kappa }} :: 'es_' ::=       {{ com Expressions    }}
  | u                      ::  :: Atom       {{ com Atom }}
  | star                   ::  :: Star       {{ com Type of types }}
  | E1 E2                  ::  :: App        {{ com Application }}
  | \ x : A . E            ::  :: Lam        {{ com Abstraction }}
  | Pi x : A1 . A2         ::  :: Pi         {{ com Product }}
  | castup [ A ] E         ::  :: CastUp     {{ com Cast up to type}}
  | castdown E             ::  :: CastDown   {{ com Cast down by reduction }}
  | mu x : A . E           ::  :: Mu         {{ com General recursion }}
  | case E1 of << p => E2 >> ::  :: Case     {{ com Case analysis }}
  | let x : A = E2 in E1   ::  :: LetBinding {{ com Let binding }}
  | E1 [ x |-> E2 ]        :: M:: Sub        {{ com Substitution }}
  | ( E )                  :: M:: Parens     {{ com Parenthesized expression }}
  | A1 -> A2               :: M:: FuncType   {{ com Function type }}
  | ( x : A1 ) -> A2       :: M:: DepFunType {{ com Dependent function type }}
  | << E >>                :: M:: VectorForm
  | case E of p => E'      :: M:: CaseSingle
  | D @ << u >>            :: M:: Datatype
  | ( << u : k >> ) -> A   :: M:: FuncTypeVec
  | \ << u : k >> . E      :: M:: LamVec
  | E1 [ << u |-> E2 >> ]  :: M:: SubstVec
  | s                      :: M:: Sort       {{ com Sort }}

%% Contexts
Gs {{ tex \Gamma }} :: 'Gs_' ::= {{ com Contexts }}
  | empty           ::  :: Empty       {{ com Empty }}
  | Gs , u : A      ::  :: Binding     {{ com Atom binding }}

%%% Typing rules
defns
LintSrc :: '' ::=

defn |- G        ::  :: ctxsrc :: 'Ctx_' {{ com Well-formed context }}
by

-------- :: Empty
|- empty

|- G
G |- A : s
----------- :: Var
|- G, x : A

defn G  |- pgm : A ::  :: pgmsrc :: 'Tpgm_' {{ com Program context }}
by

<< G0 |- decl : G' >>
G = G0, <<G'>>
G |- E : A
--------------------- :: Pgm
G0 |- (<<decl>>;E) :A


defn G  |- decl : G' ::  :: declsrc :: 'Tdecl_' {{ com Datatype declaration }}
by

G |- (<<u:k>>) -> star : star
<< G, D : (<<u:k>>) -> star, << u:k >> |- <<A>> -> D@<<u>> : star >>
------------------------------------------------------------------ :: Data
G |- (data D << u:k >> = << K <<A>> >>) : (D : (<<u:k>>) -> star, << K : (<<u:k>>) -> <<A>> -> D@<<u>> >>)

defn G  |- p => E : B -> A ::  :: patsrc :: 'Tpat_' {{ com Pattern typing }}
by

K : (<<u:k>>)-><<B>>->D@<<u>> elt G
G,<<x:B[<< u |-> U >>]>> |- E:A
G |- B[<< u |-> U >>]:s
--------------------------- :: Alt
G |- K <<x:B[<< u |-> U >>]>> => E:D@<<U>>->A


defn G  |- E : A ::  :: exprsrc :: 'TS_' {{ com Expression typing }}
%{{ tex [[G]] \labeledjudge{E} [[E]] : [[A]] }}
by

---------------------- :: Ax
empty |- star : star

|- G
x:A elt G
---------- :: Var
G |- x:A

G |- E1 : (Pi x:A2.A1)
G |- E2 : A2
------------------------ :: App
G |- E1 E2 : A1[x |-> E2]

G, x : A1 |- E : A2
G |- (Pi x:A1.A2) : s
--------------------------- :: Lam
G |- (\x:A1.E):(Pi x:A1.A2)

G |- A1 : s
G, x:A1 |- A2:r
------------------- :: Pi
G |- (Pi x:A1.A2):r

G |- E : A2
G |- A1 : s
A1 --> A2
---------------------- :: CastUp
G |- (castup[A1] E):A1

G |- E : A1
G |- A2 : s
A1 --> A2
---------------------- :: CastDown
G |- (castdown E) : A2

G, x:A |- E:A
G |- A:s
------------------- :: Mu
G |- (mu x:A . E):A

G |- E1 : B
<< G |- p => E2 : B -> A >>
<< G |- B -> A : s >>
---------------------------------- :: Case
G |- case E1 of << p => E2 >> : A

G |- E2 : A
G |- E1 [x |-> E2] : B
---------------------------------- :: Let
G |- let x : A = E2 in E1 : B

%%% Translation rules
defn G  |- pgm : A ~> e ::  :: pgmtrans :: 'TRpgm_' {{ com Program translation }}
by

<< G0 |- decl : G' ~> e1 >>
G = G0, <<G'>>
G |- E : A ~> e
------------------------------------- :: Pgm
G0 |- (<<decl>>;E) :A ~> <<e1>> (+) e


defn G  |- decl : G' ~> e ::  :: decltrans :: 'TRdecl_' {{ com Datatype translation }}
by

G |- (<<u:k>>) -> star : star ~> (<<u:T>>) -> star
<< G, D : (<<u:k>>) -> star, << u:k >> |- <<A>> -> D@<<u>> : star ~> <<t>> -> D@<<u>> >>
------------------------------------------------------------------ :: Data
G |- (data D << u:k >> = << K <<A>> >>) : (D : (<<u:k>>) -> star, << K : (<<u:k>>) -> <<A>> -> D@<<u>> >>) ~> e

defn G  |- p => E : B -> A ~> e ::  :: pattrans :: 'TRpat_' {{ com Pattern translation }}
by

K : (<<u:k>>)-><<B>>->D@<<u>> elt G
G,<<x:B[<< u |-> U >>]>> |- E:A ~> e
G |- B[<< u |-> U >>]:s ~> T
--------------------------- :: Alt
G |- K <<x:B[<< u |-> U >>]>> => E:D@<<U>>->A ~> \<<x:T>>.e


defn G  |- E : A ~> e ::  :: exprtrans :: 'TR_' {{ com Expression translation }}
by

------------------------------ :: Ax
empty |- star : star ~> star

|- G
x:A elt G
------------- :: Var
G |- x:A ~> x

G |- E1 : (Pi x:A2.A1) ~> e1
G |- E2 : A2 ~> e2
---------------------------------- :: App
G |- E1 E2 : A1[x |-> E2] ~> e1 e2

G, x : A1 |- E : A2 ~> e
G |- (Pi x:A1.A2) : s ~> Pi x:t1.t2
------------------------------------ :: Lam
G |- (\x:A1.E):(Pi x:A1.A2) ~> \x:t1.e

G |- A1 : s1 ~> t1
G, x:A1 |- A2:s2 ~> t2
---------------------- :: Pi
G |- (Pi x:A1.A2):s2 ~> Pi x:t1.t2

G |- E : A2 ~> e
G |- A1 : s ~> t1
A1 --> A2
---------------------- :: CastUp
G |- (castup[A1] E):A1 ~> castup[t1] e

G |- E : A1 ~> e
G |- A2 : s ~> t2
A1 --> A2
------------------------------------ :: CastDown
G |- (castdown E) : A2 ~> castdown e

G, x:A |- E:A ~> e
G |- A:s ~> t
------------------------------- :: Mu
G |- (mu x:A . E):A ~> mu x:t.e

G |- E1 : B ~> e1
<< G |- p => E2 : B -> A ~> e2 >>
<< G |- B -> A : s ~> T -> t >>
---------------------------------------- :: Case
G |- case E1 of << p => E2 >> : A ~> (castdown e1) t <<e2>>

G |- E2 : A ~> e2
G |- E1 [x |-> E2] : B ~> e1 [x |-> e2]
---------------------------------------- :: Let
G |- let x : A = E2 in E1 : B ~> e1 [x |-> e2]
