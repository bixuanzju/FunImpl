% Formalization of Source Language

%%% Syntax
grammar

%% Declarations
pgm                                         :: 'pgm_' ::=      {{ com Program }}
  | << decl >> ; E                          ::   :: Decl       {{ com Declarations }}
  | decl ; E                                :: M :: DeclSingle
  | ( pgm )                                 :: M :: ParenPgm

decl                                        :: 'decl_' ::=     {{ com Declarations }}
  | data D << u : k >> = << K << A >> >> ::   :: DataDecl   {{ com Datatype declaration }}
  | data D << u : k >> = K << A >>          :: M :: SDataDecl  {{ com Datatype single }}
  | data R << u : k >> = K { << N : A >> }  :: M :: RecordDecl {{ com Record declaration }}
  | ( decl )                                :: M :: ParenDecl
  | << decl >>                              :: M :: DeclVec

p                                           :: 'pat_' ::=      {{ com Patterns }}
  | K << x : A >>                           ::   :: Pattern    {{ com Pattern }}
  | ( p )                                   :: M :: ParenPat

u, U {{ tex \upsilon }}                     :: 'u_'   ::=      {{ com Atoms }}
  | x                                       ::  :: Var         {{ com Variable }}
  | K                                       ::  :: DCon        {{ com Data constructor }}

%% Expressions
E , A {{ tex T }}, B {{ tex S }}, k {{ tex \kappa }} :: 'es_' ::=       {{ com Expressions    }}
  | u                      ::  :: Atom       {{ com Atom }}
  | star                   ::  :: Star       {{ com Type of types }}
  | E1 E2                  ::  :: App        {{ com Application }}
  | \ x : A . E            ::  :: Lam        {{ com Abstraction }}
  | Pi x : A . B           ::  :: Pi         {{ com Product }}
  | castup [ A ] E         ::  :: CastUp     {{ com Cast up by expansion}}
  | castdown E             ::  :: CastDown   {{ com Cast down by reduction }}
  | mu x : A . E           ::  :: Mu         {{ com General recursion }}
  | case E1 of << p => E2 >> ::  :: Case     {{ com Case analysis }}
  | let x : A = E2 in E1   :: M:: LetBinding {{ com Let binding }}
  | E1 [ x |-> E2 ]        :: M:: Sub        {{ com Substitution }}
  | ( E )                  :: M:: Parens     {{ com Parenthesized expression }}
  | A1 -> A2               :: M:: FuncType   {{ com Function type }}
  | ( x : A1 ) -> A2       :: M:: DepFunType {{ com Dependent function type }}
  | << E >>                :: M:: VectorForm
  | case E of p => E'      :: M:: CaseSingle
  | D @ << u >>            :: M:: Datatype
  | ( << u : k >> ) -> A   :: M:: FuncTypeVec
  | \ << u : k >> . E      :: M:: LamVec
  | E1 [ << u |-> E2 >> ]  :: M:: SubstVec
  | s                      :: M:: Sort       {{ com Sort }}
  | E *                    :: M:: Starred    {{ com Starred expression }}

V {{ tex v }} :: 'vs_' ::=                               {{ com Values   }}
  | star                 ::  :: Star       {{ com Type of types }}
  | \ x : A . E          ::  :: Lam        {{ com Abstraction  }}
  | Pi x : A . B         ::  :: Pi         {{ com Product }}
  | castup [ A ] E       ::  :: CastUp     {{ com Cast up by expansion }}
  | K << u >> << E >>    ::  :: DataCon    {{ com Data constructor }}


%% Contexts
Gs {{ tex \Sigma }} :: 'Gs_' ::= {{ com Contexts }}
  | empty           ::  :: Empty       {{ com Empty }}
  | Gs , u : A      ::  :: Binding     {{ com Atom binding }}
  | Gs , Gs'        :: M:: CtxBind     {{ com Context binding }}
  | << u : A >>     :: M:: SrcBindVec
  | u : A           :: M:: SrcBind
  | ( Gs )          :: M:: ParenCtx
  | << Gs >>        :: M:: CtxVec

%%% Dynamic semantics
defns
OpSemSrc :: '' ::=

defn E --> E' ::  :: stepsrc :: 'SC_' {{ com One-step reduction }}
by

----------------------------  :: Beta
(\x:A.E1) E2 --> E1 [x|->E2]

---------------------------- :: CastDownUp
castdown (castup[A] E) --> E

E1 --> E1'
---------------- :: App
E1 E2 --> E1' E2

E --> E'
-------------------------- :: CastDown
castdown E --> castdown E'

------------------------------- :: Mu
mu x:A.E --> E [x |-> mu x:A.E]

E1 --> E1'
----------------------------------------------------- :: Case
case E1 of << p => E >> --> case E1' of << p => E >>


defn E -->> E' ::  :: stepsrc_multi :: 'SC_' {{ com Case reduction }}
by

Ki << xi : Ai >> => Ei elt << p => E >>
------------------------------------- :: CaseMatch
case Ki <<u>> <<E1>> of <<p=>E>> -->> Ei [ << xi |-> E1 >> ]

%%% Typing rules
defns
LintSrc :: '' ::=

defn |- Gs        ::  :: ctxsrc :: 'EnvS_' {{ com Well-formed context }}
{{ tex \labeledjudge{wf} [[Gs]] }}
by

-------- :: Empty
|- empty

|- Gs
Gs |- A : s
----------- :: Var
|- Gs, x : A

defn Gs  |- pgm : A ::  :: pgmsrc :: 'TSpgm_' {{ com Program context }}
{{ tex [[Gs]] \labeledjudge{pg} [[pgm]] : [[A]] }}
by

<< Gs0 |- decl : Gs' >>
Gs = Gs0, <<Gs'>>
Gs |- E : A
--------------------- :: Pgm
Gs0 |- (<<decl>>;E) :A


defn Gs  |- decl : Gs' ::  :: declsrc :: 'TSdecl_' {{ com Datatype declaration }}
{{ tex [[Gs]] \labeledjudge{d} [[decl]] : [[Gs']] }}
by

Gs |- (<<u:k>>) -> star : star
<< Gs, D : (<<u:k>>) -> star, << u:k >> |- <<A>> -> D@<<u>> : star >>
------------------------------------------------------------------ :: Data
Gs |- (data D << u:k >> = << K <<A>> >>) : (D : (<<u:k>>) -> star, << K : (<<u:k>>) -> <<A>> -> D@<<u>> >>)

defn Gs  |- p => E : B -> A ::  :: patsrc :: 'Tpat_' {{ com Pattern typing }}
{{ tex [[Gs]] \labeledjudge{p} [[p]] [[=>]] [[E]] : [[B]] [[->]] [[A]] }}
by

K : (<<u:k>>)-><<B>>->D@<<u>> elt Gs
Gs,<<x:B[<< u |-> U >>]>> |- E:A
Gs |- B[<< u |-> U >>]:s
--------------------------- :: Alt
Gs |- K <<x:B[<< u |-> U >>]>> => E:D@<<U>>->A


defn Gs  |- E : A ::  :: exprsrc :: 'TS_' {{ com Expression typing }}
{{ tex [[Gs]] \labeledjudge{s} [[E]] : [[A]] }}
by

---------------------- :: Ax
empty |- star : star

|- Gs
x:A elt Gs
---------- :: Var
Gs |- x:A

Gs |- E1 : (Pi x:A2.A1)
Gs |- E2 : A2
------------------------ :: App
Gs |- E1 E2 : A1[x |-> E2]

Gs, x : A1 |- E : A2
Gs |- (Pi x:A1.A2) : s
--------------------------- :: Lam
Gs |- (\x:A1.E):(Pi x:A1.A2)

Gs |- A1 : s
Gs, x:A1 |- A2:r
------------------- :: Pi
Gs |- (Pi x:A1.A2):r

Gs |- E : A2
Gs |- A1 : s
A1 --> A2
---------------------- :: CastUp
Gs |- (castup[A1] E):A1

Gs |- E : A1
Gs |- A2 : s
A1 --> A2
---------------------- :: CastDown
Gs |- (castdown E) : A2

Gs, x:A |- E:A
Gs |- A:s
------------------- :: Mu
Gs |- (mu x:A . E):A

Gs |- E1 : B
<< Gs |- p => E2 : B -> A >>
<< Gs |- A : s >>
---------------------------------- :: Case
Gs |- case E1 of << p => E2 >> : A

%%% Translation rules
defn |- Gs ~> G     ::  :: ctxtrans :: 'TRenv_' {{ com Context translation }}
{{ tex \labeledjudge{wf} [[Gs]] [[~>]] [[G]] }}
by

---------------- :: Empty
|- empty ~> empty

|- Gs ~> G
Gs |- A : s ~> t
------------------------- :: Var
|- Gs, x : A ~> G, x : t

defn Gs  |- pgm : A ~> e ::  :: pgmtrans :: 'TRpgm_' {{ com Program translation }}
{{ tex [[Gs]] \labeledjudge{pg} [[pgm]] : [[A]] [[~>]] [[e]] }}
by

<< Gs0 |- decl : Gs' ~> e1 >>
Gs = Gs0, <<Gs'>>
Gs |- E : A ~> e
------------------------------------- :: Pgm
Gs0 |- (<<decl>>;E) :A ~> <<e1>> (+) e


defn Gs  |- decl : Gs' ~> e ::  :: decltrans :: 'TRdecl_' {{ com Datatype translation }}
{{ tex [[Gs]] \labeledjudge{d} [[decl]] : [[Gs']] [[~>]] [[e]] }}
by

Gs |- (<<u:k>>) -> star : star ~> (<<u:T>>) -> star
<< Gs, D : (<<u:k>>) -> star, << u:k >> |- <<A>> -> D@<<u>> : star ~> <<t>> -> D@<<u>> >>
------------------------------------------------------------------ :: Data
Gs |- (data D << u:k >> = << K <<A>> >>) : (D : (<<u:k>>) -> star, << K : (<<u:k>>) -> <<A>> -> D@<<u>> >>) ~> e

defn Gs  |- p => E : B -> A ~> e ::  :: pattrans :: 'TRpat_' {{ com Pattern translation }}
{{ tex [[Gs]] \labeledjudge{p} [[p]] [[=>]] [[E]] : [[B]] [[->]] [[A]] [[~>]] [[e]] }}
by

K : (<<u:k>>)-><<B>>->D@<<u>> elt Gs
Gs,<<x:B[<< u |-> U >>]>> |- E:A ~> e
Gs |- B[<< u |-> U >>]:s ~> T
--------------------------- :: Alt
Gs |- K <<x:B[<< u |-> U >>]>> => E:D@<<U>>->A ~> \<<x:T>>.e


defn Gs  |- E : A ~> e ::  :: exprtrans :: 'TR_' {{ com Expression translation }}
{{ tex [[Gs]] \labeledjudge{s} [[E]] : [[A]] [[~>]] [[e]] }}
by

------------------------------ :: Ax
empty |- star : star ~> star

|- Gs ~> G
x:A elt Gs
------------- :: Var
Gs |- x:A ~> x

Gs |- E1 : (Pi x:A2.A1) ~> e1
Gs |- E2 : A2 ~> e2
---------------------------------- :: App
Gs |- E1 E2 : A1[x |-> E2] ~> e1 e2

Gs, x : A1 |- E : A2 ~> e
Gs |- (Pi x:A1.A2) : s ~> Pi x:t1.t2
------------------------------------ :: Lam
Gs |- (\x:A1.E):(Pi x:A1.A2) ~> \x:t1.e

Gs |- A1 : s ~> t1
Gs, x:A1 |- A2:r ~> t2
---------------------- :: Pi
Gs |- (Pi x:A1.A2):r ~> Pi x:t1.t2

Gs |- E : A2 ~> e
Gs |- A1 : s ~> t1
A1 --> A2
------------------------------------- :: CastUp
Gs |- (castup[A1] E):A1 ~> castup[t1] e

Gs |- E : A1 ~> e
Gs |- A2 : s ~> t2
A1 --> A2
------------------------------------ :: CastDown
Gs |- (castdown E) : A2 ~> castdown e

Gs, x:A |- E:A ~> e
Gs |- A:s ~> t
------------------------------- :: Mu
Gs |- (mu x:A . E):A ~> mu x:t.e

Gs |- E1 : B ~> e1
<< Gs |- p => E2 : B -> A ~> e2 >>
<< Gs |- A : s ~> t >>
---------------------------------------- :: Case
Gs |- case E1 of << p => E2 >> : A ~> (unfoldn e1) t <<e2>>
