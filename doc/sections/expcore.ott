% Formalization of Explicit CoC

embed {{ tex-preamble
  \newcommand{\labeledjudge}[1]{\vdash_{\!\!\mathsf{#1} } }
  \newcommand{\kw}[1]{\mathsf{#1} }
}}

%%% Metavariables
metavar x, y, z, d, X, D, K, N, R, th {{ tex \theta }}, aa {{ tex \alpha }}, bb {{ tex b }} ::= {{ com Variable names }}
indexvar i, j ::= {{ com Index variables }}

%%% Syntax
grammar

%% Expressions
e, t {{ tex \tau }}, T {{ tex \sigma }} :: 'e_' ::=       {{ com Expressions    }}
  | x                         ::  :: Var        {{ com Variable }}
  | s                         ::  :: Sort       {{ com Sort }}
  | e1 e2                     ::  :: App        {{ com Application }}
  | \ x : t . e               ::  :: Lam        {{ com Abstraction }}
  | Pi x : t1 . t2            ::  :: Pi         {{ com Product }}
  | castup [ t ] e            ::  :: CastUp     {{ com Cast up to type}}
  | castdown e                ::  :: CastDown   {{ com Cast down by reduction }}
  | mu x : t . e              ::  :: Mu         {{ com General recursion }}
  | e1 [ x |-> e2 ]           :: M:: Sub        {{ com Substitution }}
  | ( e )                     :: M:: Parens     {{ com Parenthesized expression }}
  | let x : t = e2 in e1      :: M:: LetBinding {{ com Let binding }}
  | t1 -> t2                  :: M:: FuncType   {{ com Function type }}
  | lit                       :: M:: Literals   {{ com Literals }}
  | e *                       :: M:: Starred    {{ com Starred expression }}
  | << e >>                   :: M:: ExprVec
  | e1 (+) e2                 :: M:: ExprUnion
  | ( << u : t1 >> ) -> t2    :: M:: FuncTypeVec
  | ( u : t1 ) -> t2          :: M:: DepFuncType
  | \ << u : t >> . e         :: M:: LamVec
  | e1 [ << e2 |-> t2 >> ]    :: M:: SubstVec
  | D @ << u >>               :: M:: Datatype
  | e1 [ D @ << u >> |-> e3 ] :: M:: ExprSubst
  | \\\ e                     :: M:: LineHack
  | & e                       :: M:: AlignHack
  | @@                        :: M:: DummyExpr
  | let x * : t = e2 in e1    :: M:: StarBinding

%% Literals
lit :: 'lit_' ::=
  | int                 :: M:: IntType
  | bool                :: M:: BoolType
  | three               :: M:: Number

%% Sorts
s, r {{ tex t }} :: 's_' ::= {{ com Sorts }}
  | star                ::  :: Star                  {{ com Star }}
  | square              ::  :: Square                {{ com Square }}

%% Contexts
G {{ tex \Gamma }} :: 'G_' ::= {{ com Contexts }}
  | empty          ::  :: Empty       {{ com Empty }}
  | G , x : t      ::  :: Binding     {{ com Variable binding }}
  | G , G'         :: M:: CtxBind     {{ com Context binding }}
  | G , x : t , G' :: M:: MixBind     {{ com Context-var binding }}
  | G [ x |-> e ]  :: M:: CtxSubst    {{ com Context substitution }}
  | G *            :: M:: CtxStar     {{ com Starred context }}
  | << u : A >>    :: M:: SrcBindVec
  | u : A          :: M:: SrcBind
  | ( G )          :: M:: ParenCtx
  | << G >>        :: M:: CtxVec

%% Values
v :: 'v_' ::=                               {{ com Values   }}
  | \ x : t . e          ::  :: Lam        {{ com Abstraction  }}
  | Pi x : t1 . t2       ::  :: Pi         {{ com Product }}
  | castup [ t ] e       ::  :: CastUp     {{ com Cast up }}
  | let x : t = e2 in e1 :: M:: LetBinding {{ com Let binding }}
  | t1 -> t2             :: M:: FuncType   {{ com Function Type }}

%% Core without mu
ee {{ tex e }} , tt {{ tex \tau }} :: 'ee_' ::=       {{ com Expressions    }}
  | x                              ::  :: eVar        {{ com Variable }}
  | s                              ::  :: eSort       {{ com Sort }}
  | ee1 ee2                        ::  :: eApp        {{ com Application }}
  | \ x : tt . ee                  ::  :: eLam        {{ com Abstraction }}
  | Pi x : tt1 . tt2               ::  :: ePi         {{ com Product }}
  | castup [ tt ] ee               ::  :: eCastUp     {{ com Cast up to type}}
  | castdown ee                    ::  :: eCastDown   {{ com Cast down by reduction }}

%%% Terminals
terminals :: 'terminals_' ::=
  | \        ::  :: lambda    {{ tex \lambda }}
  | Pi       ::  :: pi        {{ tex \Pi }}
  | mu       ::  :: mu        {{ tex \mu }}
  | star     ::  :: star      {{ tex \star }}
  | square   ::  :: square    {{ tex \Box }}
  | empty    ::  :: empty     {{ tex \varnothing }}
  | ->       ::  :: to        {{ tex \rightarrow }}
  | -->      ::  :: steps     {{ tex \longrightarrow }}
  | ->>      ::  :: msteps    {{ tex \twoheadrightarrow }}
  | |->      ::  :: mapsto    {{ tex \mapsto }}
  | castup   ::  :: castup    {{ tex \kw{cast}^{\uparrow} }}
  | |-       ::  :: turnstile {{ tex \vdash }}
  | ==       ::  :: equiv     {{ tex \equiv }}
  | =a       ::  :: alphaeq   {{ tex \equiv }}
  | =b       ::  :: betaeq    {{ tex =_{\beta} }}
  | castdown ::  :: castdown  {{ tex \kw{cast}_{\downarrow} }}
  | let      ::  :: let       {{ tex \kw{let} }}
  | in       ::  :: key_in    {{ tex \kw{in} }}
  | eqb      ::  :: eqb       {{ tex =_{\beta} }}
  | int      ::  :: int       {{ tex \kw{Int} }}
  | bool     ::  :: bool      {{ tex \kw{Bool} }}
  | three    ::  :: three     {{ tex 3 }}
  | elt      ::  :: elt       {{ tex \in }}
  | *        ::  :: upstar    {{ tex ^{*} }}
  | =>       ::  :: match     {{ tex \Rightarrow }}
  | /=       ::  :: ineq      {{ tex \not \eq }}
  | data     ::  :: data      {{ tex \kw{data} }}
  | or       ::  :: or        {{ tex \mid }}
  | case     ::  :: case      {{ tex \kw{case} }}
  | of       ::  :: of        {{ tex \kw{of} }}
  | <<       ::  :: vecl      {{ tex \overline{ }}
  | >>       ::  :: vecr      {{ tex } }}
  | @        ::  :: marker    {{ tex }}
  | ~>       ::  :: transto   {{ tex \rightsquigarrow }}
  | (+)      ::  :: union     {{ tex \uplus }}
  | :=       ::  :: define    {{ tex \triangleq ~ }}
  | &        ::  :: align     {{ tex & }}
  | \\\      ::  :: newline   {{ tex \\ & }}
  | @@       ::  :: dummy     {{ tex }}

%%% Fomulae
formula :: 'formula_' ::=
  | judgement                          ::   :: judgement
  | G1 = G2                            ::   :: context_rewrite
  | e1 = e2                            ::   :: rewrite
  | e1 /= e2                           ::   :: inequality
  | e1 =b e2                           ::   :: beta_equality
  | e1 =a e2                           ::   :: alpha_equality
  | e1 == e2                           ::   :: equivalence
  | ( formula )                        ::   :: parens
  | x : t elt G                        ::   :: context_inclusion
  | G |- tylit lit : k                 ::   :: lintTyLit
    {{ tex [[G]] \labeledjudge{tylit} [[lit]] : [[k]] }}
  | |- e : t                           ::   :: empty_context
  | formula \\                         ::   :: lbhack {{ tex [[formula]] \ottlinebreak }}
  | u : A elt G                        ::   :: context_inclusion_src
  | |- E : A                           ::   :: empty_context_src
  | E1 --> E2                          ::   :: reduction_src
  | << formula >>                      ::   :: formula_vector
  | E1 = E2                            ::   :: rewrite_src
  | e1 := e2                           ::   :: definition

%%% Subrule
subrules
  v <:: e
  ee <:: e

%%% Typing rules
defns
LintCore :: '' ::=

defn G  |- e : t ::  :: coc :: 'T_' {{ com CoC typing }}
by

G |- e : t1
G |- t2 : s
t1 =b t2
----------- :: Conv
G |- e : t2

defn G  |- e : t ::  :: ext :: 'T_' {{ com Extended expression typing }}
by

G, x:t |- e:t
G |- t:s
------------------- :: Mu
G |- (mu x:t . e):t

|- G
x:t elt G
---------- :: VarEnv
G |- x:t

defn |- G        ::  :: ctx :: 'Env_' {{ com Well-formed context }}
by

-------- :: Empty
|- empty

|- G
G |- t : s
----------- :: Var
|- G, x : t

defn G  |- e : t ::  :: expr :: 'T_' {{ com Expression typing }}
%{{ tex [[G]] \labeledjudge{e} [[e]] : [[t]] }}
by

---------------------- :: Ax
empty |- star : square

G |- t : s
----------------- :: Var
G, x : t |- x : t

G |- e : t2
G |- t1 : s
------------------- :: Weak
G, x : t1 |- e : t2

G |- e1 : (Pi x:t2.t1)
G |- e2 : t2
------------------------ :: App
G |- e1 e2 : t1[x |-> e2]

G, x : t1 |- e : t2
G |- (Pi x:t1.t2) : s
--------------------------- :: Lam
G |- (\x:t1.e):(Pi x:t1.t2)

G |- t1 : s
G, x:t1 |- t2:r
------------------- :: Pi
G |- (Pi x:t1.t2):r

G |- e : t2
G |- t1 : s
t1 --> t2
---------------------- :: CastUp
G |- (castup[t1] e):t1

G |- e : t1
G |- t2 : s
t1 --> t2
---------------------- :: CastDown
G |- (castdown e) : t2

%%% Dynamic semantics
defns
OpSem :: '' ::=

defn e --> e' ::  :: extstep :: 'S_' {{ com One-step reduction }}
by

------------------------------- :: Mu
mu x:t.e --> e [x |-> mu x:t.e]

defn e --> e' ::  :: step :: 'S_' {{ com One-step reduction }}
by

----------------------------  :: Beta
(\x:t.e1) e2 --> e1 [x|->e2]

e1 --> e1'
---------------- :: App
e1 e2 --> e1' e2

e --> e'
-------------------------- :: CastDown
castdown e --> castdown e'

---------------------------- :: CastDownUp
castdown (castup[t] e) --> e

