%%% !!! WARNING: AUTO GENERATED. DO NOT MODIFY !!! %%%
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\section{Discussion}

\paragraph{More Type-level Computation}


\paragraph{Eliminating Cast Operators}

Explicit type \cast operators $ \mathsf{cast}^{\uparrow} $ and $ \mathsf{cast}_{\downarrow} $ are
generalized from $ \mathsf{fold} $ and $ \mathsf{unfold} $ of iso-recursive
types. By convention, $ \mathsf{cast}^{\uparrow} $ follows $ \mathsf{fold} $ as a value, so
it cannot be further reduced during the evaluation. This may cause
semantics and performance issues.

To show the semantics issue, suppose there is a non-terminating term
$\mathit{loop}$. It should loop forever when evaluated. But if it is
wrapped by $ \mathsf{cast}^{\uparrow} $ like $ \mathsf{cast}^{\uparrow} ~[ \tau ]~\mathit{loop}$, the
evaluation stops immediately. So the dynamic semantics of a term-level
expression wrapped by $ \mathsf{cast}^{\uparrow} $ might differ from the original. The
performance issue may occur during code generation. Since $ \mathsf{cast}^{\uparrow} $
will remain after evaluation, too many $ \mathsf{cast}^{\uparrow} $ constructs can
increase the size of the program and cause runtime overhead.

In fact, \cast operators can be safely eliminated after type checking,
because they do not actually transform a term other than changing its
type. There are two choices of when to remove \cast operators, during
evaluation or code generation. The following alternative reduction
rules can eliminate \cast during evaluation:
\ottusedrule{\ottdruleSXXCastUpE{}}
\ottusedrule{\ottdruleSXXCastDownE{}} Moreover, $ \mathsf{cast}^{\uparrow} $ is no
more treated as a value. With such modification, we can obtain
$ \mathsf{cast}^{\uparrow} ~[ \tau ]~\mathit{loop}  \longrightarrow  \mathit{loop}$. So
$ \mathsf{cast}^{\uparrow} $ will not interfere with the original dynamic semantics of
terms. But noting that $\mathsf{cast}^{\uparrow} \, \ottsym{[}  \tau  \ottsym{]} \,  \ottnt{e}$ or $\mathsf{cast}_{\downarrow} \, \ottnt{e}$ has
different types from $\ottnt{e}$, types of terms are not preserved during
evaluation. This breaks the subject reduction theorem, and
consequently type-safety.

Thus, we stick to the semantics of iso-recursive types for \cast
operators which has type preservation. And we prefer to eliminate
all \cast operators during type erasure to address the potential
performance issue of code generation.

\paragraph{Encoding of GADTs}

Our translation rules also open opportunity for encoding GADTs. In our
experiment, we have several running examples of encoding GADTs. Below
we show a GADT-encoded representation of well-scoped lambda terms
using de Bruijn notation.

In this notation, a variable is represented as a number -- its de
Bruijn index, where the number $k$ stands for the variable bound by
the $k$'s enclosing $\lambda$. Using the GADT syntax, below is the
definition of lambda terms:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}c<{\hspost}@{}}%
\column{5E}{@{}l@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{Fin}\mathbin{:}\Conid{Nat}\to \star\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Varid{fzero}\mathbin{:}(\Varid{n}\mathbin{:}\Conid{Nat})\to \Conid{Fin}\;(\Conid{S}\;\Varid{n}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid {}\<[5E]%
\>[8]{}\Varid{fsucc}\mathbin{:}(\Varid{n}\mathbin{:}\Conid{Nat})\to \Conid{Fin}\;\Varid{n}\to \Conid{Fin}\;(\Conid{S}\;\Varid{n});{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{data}\;\Conid{Term}\mathbin{:}\Conid{Nat}\to \star\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Conid{Var}\mathbin{:}(\Varid{n}\mathbin{:}\Conid{Nat})\to \Conid{Fin}\;\Varid{n}\to \Conid{Term}\;\Varid{n}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid {}\<[5E]%
\>[8]{}\Conid{Lam}\mathbin{:}(\Varid{n}\mathbin{:}\Conid{Nat})\to \Conid{Term}\;(\Conid{S}\;\Varid{n})\to \Conid{Term}\;\Varid{n}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid {}\<[5E]%
\>[8]{}\Conid{App}\mathbin{:}(\Varid{n}\mathbin{:}\Conid{Nat})\to \Conid{Term}\;\Varid{n}\to \Conid{Term}\;\Varid{n}\to \Conid{Term}\;\Varid{n};{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The datatype \emph{Fin n} is used to restrict the the de Brujin index,
so that it lies between $0$ to $n - 1$. The type of a closed term is
simply \ensuremath{\Conid{Term}\;\Conid{Z}}, for instance, a lambda term
$\lambda x.\,\lambda y.\, x$ is represented as (for the presentation,
we use decimal numbers instead of Peano numbers):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Lam}\;\mathrm{0}\;(\Conid{Lam}\;\mathrm{1}\;(\Conid{Var}\;\mathrm{2}\;(\Varid{fsucc}\;\mathrm{1}\;(\Varid{fzero}\;\mathrm{0})))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
If we accidentally write the wrong index, the program would fail to
pass type checking.


We do not have space to present a complete encoding, but instead show
the encoding of \emph{Fin}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{let}\;\Conid{Fin}\mathbin{:}\Conid{Nat}\to \star\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mu\;\Conid{X}\mathbin{:}\Conid{Nat}\to \star.\,\lambda \Varid{a}\mathbin{:}\Conid{Nat}.\,{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}(\Conid{B}\mathbin{:}\Conid{Nat}\to \star)\to {}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}((\Varid{n}\mathbin{:}\Conid{Nat})\to \Conid{B}\;(\Conid{S}\;\Varid{n}))\to {}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}((\Varid{n}\mathbin{:}\Conid{Nat})\to \Conid{X}\;\Varid{n}\to \Conid{B}\;(\Conid{S}\;\Varid{n}))\to {}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{B}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The key issue in encoding GADTs lies in type of variable $B$. In
ordinary datatype encoding, $B$ is fixed to have type $\star$, while
in GADTs, its type is the same as the variable $X$ (possibly
higher-kinded). Currently, we have to manually interpret the type
according to the particular use of some GADTs. We are investigating if
there exits a general way to do that.
