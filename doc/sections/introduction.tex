\section{Introduction}

Modern statically typed functional languages (such as ML, Haskell,
Scala or OCaml) have increasingly expressive type systems. Often these
large source languages are translated into a much smaller typed core
language. The choice of the core language is essential to ensure that
all the features of the source language can be encoded. For a simple
polymorphic functional language it is possible, for example, to pick a
variant of System $F$ as a core language. However, the desire for more
expressive type system features puts pressure on the core languages,
often requiring them to be extended to support new features. 
For example, if the source language supports \emph{higher-kinded types} or
\emph{type-level functions} then System $F$ is not expressive enough
and can no longer be used as the core language. Instead another core
language that does provide support for higher-kinded types, such as
System~$F_{\omega}$, needs to be used.  However System~$F_{\omega}$ is
significantly more complex than System F and thus harder to
maintain. If later a new feature, such as \emph{kind polymorphism}, is
desired the core language may need to be changed again to account for
the new feature, introducing at the same time new sources of
complexity. Indeed the core language for modern versions of 
functional languages are quite complex, having multiple syntactic 
sorts (such as terms, types and kinds), as well as dozens of 
language constructs~\cite{}\bruno{$F_{C}$}. 

The more expressive type systems become, the more types become similar
to the terms. Therefore a natural idea is to unify terms and
types. There are obvious benefits in this approach: only one syntactic
level (terms) is needed; and there are much less language constructs,
making the core language easier to implement and maintain. At the same
time the core language becomes more expressive, giving us for free
many useful language features. \emph{Pure type systems}~\cite{} build
on this observation and they show how a whole family of type systems
(including System $F$ and System $F_{\omega}$) can be implemented
using just a single syntactic form. With the added expressiveness it
is even possible to have type-level programs expressed using the same
syntax as terms as well as dependently typed programs~\cite{}.

However having the same syntax for types and terms can also 
be problematic. If arbitrary type-level computation is allowed 
then type-level programs can use the same language constructs 
as terms. Usually type systems have a conversion rule to support type-level
computation. In such type systems ensuring the \emph{decidability} of
type checking requires type-level computation to terminate.  For
calculi where the syntax of types and terms is the same, the
decidability of type-checking is usually dependent on the strong
normalization of the calculus, which ensures termination. An
unfortunate consequence of this coupling between decidability and
strong normalization is that adding (unrestricted) general recursion
to such calculi is not possible. There is a clear tension 
between decidability of type-checking and allowing general recursion 
at the type-level.

%Tension between decidability of type-checking, logical consistency and 
%general recursion.
%Brief summary of related work

This paper proposes \name: a variant of the calculus of constructions
allows the same syntax for types and terms, supports type-level
computation, and preserves decidability of type-checking under the
presence of general recursion. In \name, each type-level computation
step is explicit.  \bruno{emphasis on the advantages: a minimal core
  language?}  The key idea, which is inspired by the traditional
treatment of \emph{iso-recursive types}, is to introduce each beta
reduction or expansion at the type-level by a \emph{type-safe
  cast}. The
casts allow control over the type-level computation. For example, if
a type-level program requires two beta-reductions to reach normal
form, then two casts are needed in the program. If a non-terminating
program is used at the type-level, it is not possible to cause
non-termination in the type-checker, because that would require a
program with an infinite number of casts. Since single beta-steps are
trivially terminating, decidability of type-checking is possible even
in the presence of non-terminating programs at the type-level. 
%At the type-level recursive programs are interpreted 
%as iso-recursive types. 

Although it may seem that forcing each step of computation 
at the type-level to be explicit will prevent convinient use of 
type-level computation.

Point about the treatment of type-level computation in Haskell. Haskell's
core language has type applications, but no type-level lambda. Equality 
is syntactic modulo alpha-conversion. This design choice was rooted in the 
desire to support Hindley-Milner type-inference... 

The paper also shows how many of programming language features of Haskell, 
including some of the latest extensions, can be encoded in \name via 
a source language. In particular the source language supports 
\emph{algebraic datatypes}, \emph{higher-kinded types}, 
\emph{nested datatypes}, \emph{kind polymorphism} and 
\emph{datatype promotion}. 
This result is interesting because \name is a minimal calculus
with only 8 language constructs and a single syntactic sort. In contrast
the latest versions of System $F_{C}$ (Haskell's core language) 
have multiple syntactic sorts and dozens of language constructs. 
Even if support for equality and coercions, which 
constitutes a significant part of System $F_{C}$, would be removed
the resulting language would still be significantly larger and more 
complex than \name. 





In summary, the constributions of this work are:

\begin{itemize}

\item Decidable type checking and managed type-level computation by
  replacing implicit conversion rule of CoC with generalized
  \textsf{fold}/\textsf{unfold} semantics.

\item A core language based on Calculus of Constructions (CoC) that
  collapses terms, types and kinds into the same hierarchy, supports
  general recursion...

\item General recursion by introducing recursive types for both terms
  and types by the same $\mu$ primitive.

\item Surface language that supports datatypes, pattern matching and
  other language extensions for Haskell, and can be encoded into the
  core language.

\end{itemize}




\begin{enumerate}[a)]
\item Motivations:

\begin{itemize}

\item Because of the reluctance to introduce dependent
  types\footnote{This might be changed in the near future. See
    \url{https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell/Phase1}.},
  the current intermediate language of Haskell, namely System $F_C$
  \cite{fc}, separates expressions as terms, types and kinds, which
  brings complexity to the implementation as well as further
  extensions \cite{fc:pro,fc:kind}.

\item Popular full-spectrum dependently typed languages, like Agda,
  Coq, Idris, have to ensure the termination of functions for the
  decidability of proofs. No general recursion and the limitation of
  enforcing termination checking make such languages impractical for
  general-purpose programming.

\item We would like to introduce a simple and compiler-friendly
  dependently typed core language with only one hierarchy, which
  supports general recursion at the same time.

\end{itemize}

\item Contribution:

\begin{itemize}

\item A core language based on Calculus of Constructions (CoC) that
  collapses terms, types and kinds into the same hierarchy.

\item General recursion by introducing recursive types for both terms
  and types by the same $\mu$ primitive.

\item Decidable type checking and managed type-level computation by
  replacing implicit conversion rule of CoC with generalized
  \textsf{fold}/\textsf{unfold} semantics.

\item First-class equality by coercion, which is used for encoding
  GADTs or newtypes without runtime overhead.

\item Surface language that supports datatypes, pattern matching and
  other language extensions for Haskell, and can be encoded into the
  core language.

\end{itemize}

\item Related work:

\begin{itemize}
\item Henk \cite{pts:henk} and one of its implementation \cite{pts:fp} show the simplicity of the Pure Type System (PTS). \cite{pts:rec} also tries to combine recursion with PTS.

\item \textsf{Zombie} \cite{zombie:popl14, zombie:thesis} is a language with two fragments supporting logics with non-termination. It limits the $\beta$-reduction for congruence closure \cite{zombie:popl15}.

\item $\Pi\Sigma$ \cite{dep:pisigma} is a simple, dependently-typed core language for expressing high-level constructions\footnote{But the paper didn't give any meta-theories about the langauge.}. UHC compiler \cite{fc:uhc} tries to use a simplified core language with coercion to encode GADTs.

\item System $F_C$ \cite{fc} has been extended with type promotion \cite{fc:pro} and kind equality \cite{fc:kind}. The latter one introduces a limited form of dependent types into the system\footnote{Richard A. Eisenberg is going to implement kind equality \cite{fc:kind} into GHC. The implementation is proposed at \url{https://phabricator.haskell.org/D808} and related paper is at \url{http://www.cis.upenn.edu/~eir/papers/2015/equalities/equalities-extended.pdf}.}, which mixes up types and kinds.
\end{itemize}

\end{enumerate}
