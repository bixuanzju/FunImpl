\section{Related Work}
\label{sec:related}

There is a lot work on bring full-spectrum dependent types to the
practical programming world. Compared to existing work, the main
different of our work is that we propose the use of explicit casts to
control type-level computation. Moreover we also unify recursion and
recursive types in a single language construct.

\begin{table*}
\renewcommand{\arraystretch}{0.8}
\centering
\begin{tabularx}{\textwidth}{XXXXXXl}
\midrule
&&&& \multicolumn{2}{c}{Complexity} & \\ \cmidrule{5-6}
Core Language & Surface \mbox{Language} & Decidable Type Checking & General \mbox{Recursion} & \# of Language Constructs & \# of Syntactic Sorts & Logical Consistency \\ \midrule
\name & \sufcc & Yes & Yes & 8 & 1 & No \\
System $F_C$ & Haskell & Yes & Yes & 35 & 3 & No \\
\cc & N/A & Yes & No & 7 & 1 & Yes \\
$\lambda^\theta$ & \textsf{Zombie} & Yes & Yes & 26 & 1 & Yes, in \textsf{L} Fragment \\
Core Cayenne & Cayenne & No & Yes & 11 & 1 & No \\
$\mu F^\star$ & $F^\star$ & Yes & Yes & 39 & 3 & Yes, in \textsf{PURE} Effect \\
$\Pi\Sigma$ & N/A & No\linus{?} & Yes & 18 & 1 & No
\end{tabularx}
\caption{Comparison of Core Languages}
\label{tab:related:comp}
\end{table*}


\paragraph{Unification of Terms, Types, and Kinds}
Pure Type Systems (PTS)~\cite{pts} show how a while family of type systems
can be implemented using just a single syntactic form. PTS are an
obvious source of inspiration for our work. Although this paper
presents a specific system, it should be easy to generalize \name 
in the same way as PTS and further show the applicability of our 
ideas to other systems. 

An early attempt of using a single syntax for an intermediate language
for functional programming was Henk~\cite{pts:henk}. The Henk proposal
was to use the \emph{lambda cube} as a typed intermediate language,
unifying all three levels. The system used in Henk
it is not even a dependently typed
language, as the authors intended to  disallow types to depend
on terms. As for recursion, even though it has a full lambda calculus
at the type level, recursion is disallowed. Moreover no meta-theoretic 
results were proved for Henk.

\begin{comment}
Since the implicit conversion of the lambda
cube is not syntax-directed, they come up with a approach to
strategically distribute the conversion rule over the other typing
rules. In retrospect, Henk is quite conservative in terms of
type-level computation. Actually it is not even a dependently typed
language, as they clearly state that they don't allow types to depend
on terms. As for recursion, even though it has a full lambda calculus
at the type level, recursion is disallowed. In Henk the authors have
not attempted to prove any meta-theoretic results.
\end{comment}

Another recent work on dependently typed language based on the same
syntactic category is \textsf{Zombie}~\cite{zombie:popl14,
  zombie:thesis}, where terms, types and the single kind $\star$ all
reside in the same level. The language is based on a call-by-value
variant of lambda calculus. An interesting aspect of Zombie is that
it is composed of two fragments: a logical fragment and a programmatic
fragment, so that it supports both partial and total programming. Even
though Zombie has one syntactic category, it is still fairly
complicated, as it tries to be both consistent as a logic and
pragmatic as a programming language. In constrast \name takes 
another point of the design space, giving up logical consistency 
for simplicity.

$\Pi\Sigma$~\cite{dep:pisigma} is another recently proposed
dependently typed core language that resembles \name, as there is no
syntactic difference between terms and types.\bruno{So? What's the
  difference?}
\bruno{Cayenne? general recursion, but no decidable type-checking.}

\paragraph{General Recursion and Managed Type-level Computation}
One way to allow general recursion and dependent types in the same
language and still have decidable type-checking is to use multiple
levels of syntax. In this way it is easy to have a term language with 
powerful constructs, such as general recursion, but have a more
restricted type and/or kind language. On the other hand this brings 
complexity to the language as multiple levels (possibly with similar
constructs) have to be managed.

\bruno{Very important reference: A Framework for Defining Logics}
\bruno{integrate paragraph I wrote above better with subsequent text.}

\begin{comment}
As discussed in \S\ref{sec:rec}, bringing general
recursion blindly into the dependently typed world causes more trouble
than convenience. There are many dependently typed languages that
allow general recursion. Zombie approaches general recursion by
separating a consistent sub-language, in which all expressions are
known to terminate, from a programmatic language that supports general
recursion. What is interesting about Zombie is that those two
seemingly conflicting worlds can interact with each other nicely,
without compromising the consistency property. The key idea of this is
to distinguish between these two fragments by using a
\emph{consistency classifier $\theta$}. When $\theta$ is \textsf{L},
it means the logical part, and \textsf{P} the program part. Like
\name, Zombie uses \textsf{roll} and \textsf{unroll} for iso-recursive
types. To ensure normalization (in order for decidable type checking),
it forbids the use of \textsf{unroll} in \textsf{P}, where the
potential non-termination could arise.\bruno{Zombie is being discussed
in two different places.}
\end{comment}

$F^{\star}$~\cite{Swamy2011} also supports writing general-purpose
programs with effects (e.g., state, exceptions, non-terminating, etc.)
while maintaining a consistent core language. Unlike \name, it has
several sub-languages -- for terms, proofs and so on. The interesting
part of $F^{\star}$ lies in its kind system, which tracks the
sub-languages and controls the interactions between them. The idea is
to restrict the use of recursion in specifications and proofs while
allowing arbitrary recursion in the program. They use $\star$ to
denote program terms that may be effectful and divergent, and
\textsf{P} for proofs that identify pure and total functions. In this
way, they are able to ensure that fragments in a program used for
building proof terms are never mixed with those that are potentially
divergent. One difference from \name is that, types in $F^{\star}$ can
only contain values but no non-value expressions, leading to its less
expressiveness than \name.

$\Pi\Sigma$ has a general mechanism for recursion. Like \name, it uses
one recursion mechanism for the definition of both types and
programs\bruno{Oh! So they have recursive types and recursion using 
a single construct?}. The key idea relies on lifted types and boxes: definitions
are not unfolded inside boxes. The way they achieve decidable type
checking is to use boxing to stop the infinite unfolding of the
recursive call, at the cost of additional annotations stating where to
lift, box and force. One concern of $\Pi\Sigma$ is that its metatheory
is not yet formally developed.\bruno{Maybe have a paragraph on
  recursive types?}

\paragraph{Type in Type}
We are not the the first to embrace $\star : \star$ in the system. It
has been long known that systems with $\star : \star$ (usually called
system $\lambda *$) is inconsistent as a logic, in the sense that all
types are inhabited. In this system, we can encode a variant of
Russel's paradox, known as Girard's
paradox~\cite{coquand1986analysis}.

The core language of the Glasgow Haskell Compiler, System $F_{C}$~\cite{fc}
has been extended with type promotion \cite{fc:pro} and kind equality
\cite{fc:kind}. The latter one introduces a limited form of dependent
types into the system\footnote{Richard A. Eisenberg is going to
  implement kind equality \cite{fc:kind} into GHC. The implementation
  is proposed at \url{https://phabricator.haskell.org/D808} and
  related paper is at
  \url{http://www.cis.upenn.edu/~eir/papers/2015/equalities/equalities-extended.pdf}.},
which mixes up types and kinds. This causes no trouble for FC, since
all kinds are already inhabited without the above
extensions. $\Pi\Sigma$ has a impredicative universe of types with
$\mathsf{Type} : \mathsf{Type}$ due to the support of general
recursion. The surface language of Zombie also has the rule
$\Gamma \vdash \mathsf{Type} : \mathsf{Type}$~\cite{zombie:popl15}.

The $\star : \star$ axiom makes it convenient to support kind
polymorphism, among other language features. One concern is that it
often causes type checking to be undecidable, if not dealt with
carefully, as it allows to express divergent terms. However, as we
explained in \S\ref{sec:ecore}, this is not the case for \name. Type
checking in \name is decidable -- all type-level computation is driven
by finite cast operations, thus no potentially infinite reductions can
happen in reality.

\paragraph{Encoding of Datatypes}
One thing \name differs from other functional programming languages is
that all the high-level features in the surface language like
datatypes, pattern matching and so on can be easily encoded into the
core language. There is much work on encoding datatypes into various
high-level languages. The classic Church encoding of datatypes into
System F is detailed in the work of Bohm and
Beraducci~\cite{Bohm1985}. The Church encoding excels in implementing
iterative or fold-like functions over algebraic datatypes, but is
awkward in expressing general recursion, usually in a complex and
insufficient way. An alternative encoding of datatypes is the so
called \emph{Scott} encoding. However Scott encoding is not typable in
System F, as it needs recursive types to represent recursive
datatypes. \name has all it needs to represent polymorphic and
recursive datatypes. The explicit cast rules also makes it possible to
encode GADTs, as can be seen in the last examples in
Section~\ref{sec:app}. Currently we are investigating how the encoding
of GADTs interact with the other language constructs. We leave this as
future work.

Another line of related work is the \emph{inductive defined types} in
the Calculus of Inductive Constructions (CIC)~\cite{cic}, which is the
underlying formal language of Coq. In CIC, inductive defined types can
be represented by closed types in \coc, so are the primitive recursive
functionals over elements of the type. The limitation of their work is
that functions over inductive defined types are definable only by
primitive recursion. McBride et al.~\cite{elim:pi:pattern} show that
inductive families of datatypes with dependent pattern matching can be
translated into terms in Luo's UTT~\cite{Luo:UTT}, extended with axiom
K~\cite{axiomK}. The novelty in his work is the introduction of
\emph{splitting tree}, with which explicit evidence for impossible
case branches is recorded.

% \begin{itemize}
% \item Henk \cite{pts:henk} and one of its implementation \cite{pts:fp} show the simplicity of the Pure Type System (PTS). \cite{pts:rec} also tries to combine recursion with PTS.

% \item \textsf{Zombie} \cite{zombie:popl14, zombie:thesis} is a language with two fragments supporting logics with non-termination. It limits the $\beta$-reduction for congruence closure \cite{zombie:popl15}.

% \item $\Pi\Sigma$ \cite{dep:pisigma} is a simple, dependently-typed core language for expressing high-level constructions\footnote{But the paper didn't give any meta-theories about the langauge.}. UHC compiler \cite{fc:uhc} tries to use a simplified core language with coercion to encode GADTs.

% \item System $F_C$ \cite{fc} has been extended with type promotion \cite{fc:pro} and kind equality \cite{fc:kind}. The latter one introduces a limited form of dependent types into the system\footnote{Richard A. Eisenberg is going to implement kind equality \cite{fc:kind} into GHC. The implementation is proposed at \url{https://phabricator.haskell.org/D808} and related paper is at \url{http://www.cis.upenn.edu/~eir/papers/2015/equalities/equalities-extended.pdf}.}, which mixes up types and kinds.
% \end{itemize}
