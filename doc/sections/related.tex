\section{Related Work}

There is a lot work on bring full-spectrum dependent types to the practical programming world.

\subsubsection{Unification of Terms, Types, and Kinds}

This line of work is largely inspired by Henk~\cite{pts:henk}, where they are the first to use the so-called \emph{lambda cube} as a typed intermediate language, unifying all three levels. Since the implicit conversion of the lambda cube is not syntax-directed, they come up with a approach to strategically distribute the conversion rule over the other typing rules. In retrospect, Henk is quite conservative in terms of type-level computation. Actually it is not even a dependently typed language, as they clearly state that they don't allow types to depend on terms. As for recursion, even though it has a full lambda calculus at the type level, recursion is disallowed.

Another recent work on dependently typed language based on the same syntactic category is \textsf{Zombie}~\cite{zombie:popl14, zombie:thesis}, where terms, types and the single kind $\star$ all reside in the same level. The language is based on a call-by-value variant of lambda calculus. One beautiful thing about Zombie is that it is composed of two fragments: a logical fragment and a programmatic fragment, so that it supports both partial and total programming. Even though Zombie has one syntactic category, it is still fairly complicated, as it tries to be both consistent as a logic and pragmatic as a programming language.

$\Pi\Sigma$~\cite{dep:pisigma} is another recently proposed dependently typed core language that resembles \name, as there is no syntactic difference between terms and types.

\subsubsection{Encoding of Datatypes}

One thing \name differs from other functional programming languages is that all the high-level features in the surface language like datatypes, pattern matching and so on can be easily encoded into the core language. There is much work on encoding datatypes into various high-level languages. The classic Church encoding of datatypes into System F is detailed in the work of Bohm and Beraducci~\cite{Bohm1985}. The Church encoding excels in implementing iterative or fold-like functions over algebraic datatypes, but is awkward in expressing general recursion, usually in a complex and insufficient way. An alternative encoding of datatypes is the so called \emph{Scott} encoding. However Scott encoding is not typable in System F, as it needs recursive types to represent recursive datatypes. \name has all it needs to represent polymorphic and recursive datatypes. The explicit cast rules also makes it possible to encode GADTs, as can be seen in the last examples in \S\ref{sec:app}. Currently we are investigating how the encoding of GADTs interact with the other language constructs. We leave this as future work.

\subsubsection{General Recursion and Managed Type-level Computation}

As discussed before, bringing general recursion blindly into the dependently typed world causes more trouble then convenience. There are many dependently typed languages that allow general recursion. Zombie approaches general recursion by separating a consistent sub-language, in which all expressions are known to terminate, from a programmatic language that supports general recursion. What is interesting about Zombie is that those two seemingly conflicting worlds can interact with each other nicely, without compromising the consistency property. The key idea of this is to distinguish between these two fragments by using a \emph{consistency classifier $\theta$}. When $\theta$ is \textsf{L}, it means the logical part, and \textsf{P} the program part. Like \name, Zombie uses \textsf{roll} and \textsf{unroll} for iso-recursive types. To ensure normalization (in order for decidable type checking), it forbids the use of \textsf{unroll} in \textsf{P}, where the potential non-termination could arise.

$F^{\star}$~\cite{Swamy2011} also supports writing general-purpose programs with effects (e.g., state, exceptions, non-terminating, etc.) while maintaining a consistent core language. Unlike \name, it has several sub-languages -- for terms, proofs and so on. The interesting part of $F^{\star}$ lies in its kind system, which tracks the sub-languages and controls the interactions between them. The idea is to restrict the use of recursion in specifications and proofs while allowing arbitrary recursion in the program. They use $\star$ to denote program terms that may be effectful and divergent, and \textsf{P} for proofs that identify pure and total functions. In this way, they are able to ensure that fragments in a program used for building proof terms are never mixed with those that are potentially divergent. One difference from \name is that, types in $F^{\star}$ can only contain values but no non-value expressions, leading to its less expressiveness than \name.

$\Pi\Sigma$ has a general mechanism for recursion. Like \name, it uses one recursion mechanism for the definition of both types and programs. The key idea relies on lifted types and boxes: definitions are not unfolded inside boxes. The way they achieve decidable type checking is to use boxing to stop the infinite unfolding of the recursive call, at the cost of additional annotations stating where to lift, box and force. One concern of $\Pi\Sigma$ is that its metatheory is not yet formally developed.

\subsubsection{Type in Type}

We are not the the first to embrace $\star : \star$ in the system. It has been long known that systems with $\star : \star$ (usually called system $\lambda *$) is inconsistent as a logic, in the sense that all types are inhabited. In this system, we can encode a variant of Russel's paradox, known as Girard's paradox~\cite{coquand1986analysis}.

The core language of the Glasgow Haskell Compiler, System FC \cite{fc} has been extended with type promotion \cite{fc:pro} and kind equality \cite{fc:kind}. The latter one introduces a limited form of dependent types into the system\footnote{Richard A. Eisenberg is going to implement kind equality \cite{fc:kind} into GHC. The implementation is proposed at \url{https://phabricator.haskell.org/D808} and related paper is at \url{http://www.cis.upenn.edu/~eir/papers/2015/equalities/equalities-extended.pdf}.}, which mixes up types and kinds. This causes no trouble for FC, since all kinds are already inhabited without the above extensions. $\Pi\Sigma$ has a impredicative universe of types with $\mathsf{Type} : \mathsf{Type}$ due to the support of general recursion. The surface language of Zombie also has the rule $\Gamma \vdash \mathsf{Type} : \mathsf{Type}$~\cite{zombie:popl15}.

The $\star : \star$ axiom makes it convenient to support kind polymorphism, among other language features. One concern is that it often causes type checking to be undecidable, if not dealt with carefully, as it allows to express divergent terms. However, as we explained in \S\ref{sec:ecore}, this is not the case for \name. Type checking in \name is decidable -- all type-level computation is driven by finite cast operations, thus no potentially infinite reductions can happen in reality.

% \begin{itemize}
% \item Henk \cite{pts:henk} and one of its implementation \cite{pts:fp} show the simplicity of the Pure Type System (PTS). \cite{pts:rec} also tries to combine recursion with PTS.

% \item \textsf{Zombie} \cite{zombie:popl14, zombie:thesis} is a language with two fragments supporting logics with non-termination. It limits the $\beta$-reduction for congruence closure \cite{zombie:popl15}.

% \item $\Pi\Sigma$ \cite{dep:pisigma} is a simple, dependently-typed core language for expressing high-level constructions\footnote{But the paper didn't give any meta-theories about the langauge.}. UHC compiler \cite{fc:uhc} tries to use a simplified core language with coercion to encode GADTs.

% \item System $F_C$ \cite{fc} has been extended with type promotion \cite{fc:pro} and kind equality \cite{fc:kind}. The latter one introduces a limited form of dependent types into the system\footnote{Richard A. Eisenberg is going to implement kind equality \cite{fc:kind} into GHC. The implementation is proposed at \url{https://phabricator.haskell.org/D808} and related paper is at \url{http://www.cis.upenn.edu/~eir/papers/2015/equalities/equalities-extended.pdf}.}, which mixes up types and kinds.
% \end{itemize}
