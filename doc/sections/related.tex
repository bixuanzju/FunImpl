\section{Related Work}
\label{sec:related}

There is a lot work on bring full-spectrum dependent types to the
practical programming world. Compared to existing work, the main
different of our work is that we propose the use of explicit casts to
control type-level computation. Moreover we also unify recursion and
recursive types in a single language construct. Throughout this
section, we refer to Figure~\ref{fig:related:comp} for comparison. Our
emphasis is that with significantly less language constructs than
System $F_C$ and many modern features found in Haskell, \name is a
well-suited alternative as a core for Haskell-like language.

\begin{figure*}
\begin{threeparttable}
\renewcommand{\arraystretch}{0.4}
\small
\centering
\begin{tabularx}{\textwidth}{XXXXXXl}
\toprule
&&&& \multicolumn{2}{c}{Complexity} & \\ \cmidrule{5-6}
Core Language & Surface \mbox{Language} & Decidable Type Checking & General \mbox{Recursion} & \# of Language Constructs\tnote{1} & \# of Syntactic Sorts & Logical Consistency \\ \midrule
\name & \sufcc & Yes & Yes & 8 & 1 & No \\
System $F_C$ & Haskell & Yes & Yes & 35 & 3 & No \\
\cc & N/A & Yes & No & 7 & 1 & Yes \\
$\lambda^\theta$ & \textsf{Zombie} & Yes & Yes & 24 & 1 & Yes, in \textsf{L} Fragment \\
Core Cayenne & Cayenne & No & Yes & 11 & 1 & No \\
$\mu F^\star$ & $F^\star$ & Yes & Yes & 37 & 3 & Yes, in \textsf{PURE} Fragment \\
$\Pi\Sigma$ & N/A & Unknown\tnote{2} & Yes & 18 & 1 & No \\ \bottomrule
% ~\cite{fc}
% ~\cite{handbook}
% ~\cite{zombie:popl14}
% ~\cite{cayenne}
% ~\cite{fstar}
% ~\cite{dep:pisigma}
\end{tabularx}
\begin{tablenotes}
\item[1] Literals such as integers are ignored.
\item[2] No metatheory given.
\end{tablenotes}
\end{threeparttable}
\caption{Comparison of Core Languages}
\label{fig:related:comp}
\end{figure*}

\paragraph{General recursion without decidable type checking} To our
knowledge, Cayenne~\cite{cayenne} is the first programming language
that integrates the full power of dependent types with general
recursion. It bears some similarities with \name: First, it also uses
one syntactic form for both terms and types. Second, it allows
arbitrary computation to happen at type level. Third, because of
unrestricted recursion allowed in the system, Cayenne is logically
inconsistent, thus cannot be used as a proof system. However, the most
crucial difference from \name is that type-checking in Cayenne is
undecidable. From a pragmatic view, this design choice simplifies the
implementation (the implemented type checker fixes an upper bound on
the number of reductions that it may perform), among
others. Nevertheless, Cayenne is able to type check many useful
programs. \name improves in this regard by preserving decidable type
checking under the presence of general recursion.


\paragraph{Restricted recursion with termination checking}

Dependently typed languages such as Coq~\cite{coqsite} and
Adga~\cite{agda}, on the other hand, are conservative as to what kind
of computation is allowed at type level. Coq, as a proof system,
requires all programs to terminate by means of a termination checker,
ensuring that recursive calls are only allowed on \emph{syntactic
  subterms} of the primary argument. This way, decidable type checking
is also preserved. The conservative, syntactic criteria, to which Coq
adheres, are insufficient to support a variety of important
programming paradigms. Agda and Idris~\cite{idris}, in addition, offer
an option to disable the termination checker to allow for writing
arbitrary functions. This, however, costs us the property of decidable
type checking. While the idea that all programs should terminate is
appealing, \name aims at a different goal: a new programming model
where dependent types, decidable type checking, and general recursion
coexist. Most of the time, programmers just want to write the function
definitions, not much of delicate reasoning and proof.

\paragraph{Stratified type system with general recursion on term level}

One way to allow general recursion and dependent types in the same
language and still have decidable type-checking is to use multiple
levels of syntax. In this way it is easy to have a term language with
powerful constructs, such as general recursion, but have a more
restricted type and/or kind language. On the other hand this brings
complexity to the language as multiple levels (possibly with similar
constructs) have to be managed.

Several early attempts of combining general recursion with dependent
types by using stratified type systems include Twelf~\cite{lf:twelf}
and Delphin~\cite{lf:delphin}, both of which are implementations of
the Edinburgh Logical Framework (LF)~\cite{harper:lf}. In a nutshell,
the LF calculus is a three-level calculus for object, families, and
kinds, and as such, Twelf and Delphin both have multiple syntactic
levels. In this way they are able to preserve decidable type checking
under the presence of general recursion. In other words, decidable
type checking comes at a price of complexity and duplication of
language constructs. In contrast, \name unifies terms and types into a
single category, and still achieves decidable type checking, at a cost
of logical consistency.

$F^{\star}$~\cite{Swamy2011} is a recently proposed dependently typed
language that supports writing general-purpose programs with effects
while maintaining a consistent core language. Like Twelf and Delphin,
it also has several sub-languages -- for terms, proofs and so on
(around 37 language constructs). In $F^{\star}$, the use of recursion
is restricted in specifications and proofs while allowing arbitrary
recursion in the program. Another difference from \name is that types
in $F^{\star}$ can only contain values but no non-value expressions,
leading to its less expressiveness than \name.

\paragraph{Unified syntax and managed type-level computation}

Pure Type Systems (PTS)~\cite{pts} show how a while family of type
systems can be implemented using just a single syntactic form. PTS are
an obvious source of inspiration for our work. Although this paper
presents a specific system based on \coc, it should be easy to
generalize \name in the same way as PTS and further show the
applicability of our ideas to other systems.

An early attempt of using a single syntax for an intermediate language
for functional programming was Henk~\cite{pts:henk}. The Henk proposal
was to use the \emph{lambda cube} as a typed intermediate language,
unifying all three levels. There is also no syntactic distinction
between expressions and types in the Cayenne language.

\textsf{Zombie}~\cite{zombie:popl14, zombie:thesis} is a dependently
typed language based on the same syntactic category. An interesting
aspect of Zombie is that it is composed of two fragments: a logical
fragment where every expression is known to terminate, and a
programmatic fragment that allows general recursion, so that it
supports both partial and total programming. Even though Zombie has
one syntactic category, it is still fairly complicated (with around 25
language constructs) as it tries to be both consistent as a logic and
pragmatic as a programming language. In constrast \name takes another
point of the design space, giving up logical consistency for
simplicity. $\Pi\Sigma$~\cite{dep:pisigma} is another small
dependently typed core language that resembles \name. It has no
syntactic difference between terms and types (with 18 language
constructs), while also supporting general recursion. Like \name,
$\Pi\Sigma$ uses one recursion mechanism for both types and
functions. The key idea relies on lifted types and boxes: definitions
are not unfolded inside boxes. One of its major concerns is that its
metatheory is not yet formally developed.

% \bruno{Maybe have a paragraph on recursive types?}

\paragraph{Adding dependent types to existing languages}

There has also been a lot work on adding dependent types to existing
programming languages. The current core language for Haskell, System
$F_{C}$~\cite{Eisenberg:2014}, already supports GADTs, datatype
promotion, type families, and soon even kind
equality~\cite{fc:kind}. Nowadays System $F_{C}$ has grown to be a
relatively large and complex core language with over 30 language
constructs. Indeed, one of our primal motivations is to develop a
simpler alternative to System $F_C$. Throughout the paper, we have
shown many features that are easy to implement in \name. That being
said, one feature that is missing in \name while widely used in System
$F_C$ is GADTs. While we believe it is possible to support GADTs in
\name, we leave the implementation for future work.

% In \name, we believe we have found a sweet spot, where
% there are fewer language constructs and quite a number of modern
% features found in Haskell.

% \paragraph{Unification of Terms, Types, and Kinds}
% Pure Type Systems (PTS)~\cite{pts} show how a while family of type systems
% can be implemented using just a single syntactic form. PTS are an
% obvious source of inspiration for our work. Although this paper
% presents a specific system, it should be easy to generalize \name 
% in the same way as PTS and further show the applicability of our 
% ideas to other systems. 

% An early attempt of using a single syntax for an intermediate language
% for functional programming was Henk~\cite{pts:henk}. The Henk proposal
% was to use the \emph{lambda cube} as a typed intermediate language,
% unifying all three levels. The system used in Henk
% it is not even a dependently typed
% language, as the authors intended to  disallow types to depend
% on terms. As for recursion, even though it has a full lambda calculus
% at the type level, recursion is disallowed. Moreover no meta-theoretic 
% results were proved for Henk.

% \begin{comment}
% Since the implicit conversion of the lambda
% cube is not syntax-directed, they come up with a approach to
% strategically distribute the conversion rule over the other typing
% rules. In retrospect, Henk is quite conservative in terms of
% type-level computation. Actually it is not even a dependently typed
% language, as they clearly state that they don't allow types to depend
% on terms. As for recursion, even though it has a full lambda calculus
% at the type level, recursion is disallowed. In Henk the authors have
% not attempted to prove any meta-theoretic results.
% \end{comment}

% Another recent work on dependently typed language based on the same
% syntactic category is \textsf{Zombie}~\cite{zombie:popl14,
%   zombie:thesis}, where terms, types and the single kind $\star$ all
% reside in the same level. The language is based on a call-by-value
% variant of lambda calculus. An interesting aspect of Zombie is that
% it is composed of two fragments: a logical fragment and a programmatic
% fragment, so that it supports both partial and total programming. Even
% though Zombie has one syntactic category, it is still fairly
% complicated, as it tries to be both consistent as a logic and
% pragmatic as a programming language. In constrast \name takes 
% another point of the design space, giving up logical consistency 
% for simplicity.

% $\Pi\Sigma$~\cite{dep:pisigma} is another recently proposed
% dependently typed core language that resembles \name, as there is no
% syntactic difference between terms and types.\bruno{So? What's the
%   difference?}
% \bruno{Cayenne? general recursion, but no decidable type-checking.}

% \paragraph{General Recursion and Managed Type-level Computation}
% One way to allow general recursion and dependent types in the same
% language and still have decidable type-checking is to use multiple
% levels of syntax. In this way it is easy to have a term language with 
% powerful constructs, such as general recursion, but have a more
% restricted type and/or kind language. On the other hand this brings 
% complexity to the language as multiple levels (possibly with similar
% constructs) have to be managed.

% \bruno{Very important reference: A Framework for Defining Logics}
% \bruno{integrate paragraph I wrote above better with subsequent text.}

% \begin{comment}
% As discussed in \S\ref{sec:rec}, bringing general
% recursion blindly into the dependently typed world causes more trouble
% than convenience. There are many dependently typed languages that
% allow general recursion. Zombie approaches general recursion by
% separating a consistent sub-language, in which all expressions are
% known to terminate, from a programmatic language that supports general
% recursion. What is interesting about Zombie is that those two
% seemingly conflicting worlds can interact with each other nicely,
% without compromising the consistency property. The key idea of this is
% to distinguish between these two fragments by using a
% \emph{consistency classifier $\theta$}. When $\theta$ is \textsf{L},
% it means the logical part, and \textsf{P} the program part. Like
% \name, Zombie uses \textsf{roll} and \textsf{unroll} for iso-recursive
% types. To ensure normalization (in order for decidable type checking),
% it forbids the use of \textsf{unroll} in \textsf{P}, where the
% potential non-termination could arise.\bruno{Zombie is being discussed
% in two different places.}
% \end{comment}

% $F^{\star}$~\cite{Swamy2011} also supports writing general-purpose
% programs with effects (e.g., state, exceptions, non-terminating, etc.)
% while maintaining a consistent core language. Unlike \name, it has
% several sub-languages -- for terms, proofs and so on. The interesting
% part of $F^{\star}$ lies in its kind system, which tracks the
% sub-languages and controls the interactions between them. The idea is
% to restrict the use of recursion in specifications and proofs while
% allowing arbitrary recursion in the program. They use $\star$ to
% denote program terms that may be effectful and divergent, and
% \textsf{P} for proofs that identify pure and total functions. In this
% way, they are able to ensure that fragments in a program used for
% building proof terms are never mixed with those that are potentially
% divergent. One difference from \name is that, types in $F^{\star}$ can
% only contain values but no non-value expressions, leading to its less
% expressiveness than \name.

% $\Pi\Sigma$ has a general mechanism for recursion. Like \name, it uses
% one recursion mechanism for the definition of both types and
% programs\bruno{Oh! So they have recursive types and recursion using 
% a single construct?}. The key idea relies on lifted types and boxes: definitions
% are not unfolded inside boxes. The way they achieve decidable type
% checking is to use boxing to stop the infinite unfolding of the
% recursive call, at the cost of additional annotations stating where to
% lift, box and force. One concern of $\Pi\Sigma$ is that its metatheory
% is not yet formally developed.\bruno{Maybe have a paragraph on
%   recursive types?}

\paragraph{Type in Type}
We are not the the first to embrace $\star : \star$ in the system. It
has been long known that systems with $\star : \star$ is inconsistent
as a logic~\cite{handbook}. The core language of the Glasgow Haskell
Compiler, System $F_{C}$~\cite{fc} has already been inconsistent,
since all kinds are inhabited. $\Pi\Sigma$ has a impredicative
universe of types with $\mathsf{Type} : \mathsf{Type}$ due to the
support of general recursion. The surface language of Zombie also has
the rule
$\Gamma \vdash \mathsf{Type} : \mathsf{Type}$~\cite{zombie:popl15}.

The $\star : \star$ axiom makes it convenient to support kind
polymorphism, among other language features. One concern is that it
often causes type checking to be undecidable in dependently typed
language.  However, as we explained in Section~\ref{sec:ecore}, this
is not the case for \name. Type checking in \name is decidable -- all
type-level computation is driven by finite cast operations, thus no
potentially infinite reductions can happen in reality.

\paragraph{Encoding Datatypes}
There is much work on encoding datatypes into various high-level
languages. The classic Church encoding of datatypes into System F is
detailed in the work of Bohm and Beraducci~\cite{Bohm1985}.  An
alternative encoding of datatypes is Scott
encoding~\cite{encoding:scott}. However Scott encoding is not typable
in System F as it needs recursive types. \name has all it requires to
represent polymorphic and recursive datatypes.

Another line of related work is the \emph{inductive defined types} in
the Calculus of Inductive Constructions (CIC)~\cite{cic}, which is the
underlying formal language of Coq. In CIC, inductive defined types can
be represented by closed types in \coc, so are the primitive recursive
functionals over elements of the type. McBride et
al.~\cite{elim:pi:pattern} show that inductive families of datatypes
with dependent pattern matching can be translated into terms in Luo's
UTT~\cite{Luo:UTT}, extended with axiom K~\cite{axiomK}. The novelty
in his work is the introduction of \emph{splitting tree}, with which
explicit evidence for impossible case branches is recorded.
