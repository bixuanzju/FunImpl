\section{Related Work}
\label{sec:related}

There is a lot work on bring full-spectrum dependent types to the
practical programming world. Compared to existing work, the main
different of our work is that we propose the use of explicit casts to
control type-level computation. Moreover we also unify recursion and
recursive types in a single language construct. There are many
approaches to the topic, as we will cover below.

\begin{table*}
\renewcommand{\arraystretch}{0.8}
\centering
\begin{tabularx}{\textwidth}{XXXXXXl}
\midrule
&&&& \multicolumn{2}{c}{Complexity} & \\ \cmidrule{5-6}
Core Language & Surface \mbox{Language} & Decidable Type Checking & General \mbox{Recursion} & \# of Language Constructs & \# of Syntactic Sorts & Logical Consistency \\ \midrule
\name & \sufcc & Yes & Yes & 8 & 1 & No \\
System $F_C$ & Haskell & Yes & Yes & 35 & 3 & No \\
\cc & N/A & Yes & No & 7 & 1 & Yes \\
$\lambda^\theta$ & \textsf{Zombie} & Yes & Yes & 26 & 1 & Yes, in \textsf{L} Fragment \\
Core Cayenne & Cayenne & No & Yes & 11 & 1 & No \\
$\mu F^\star$ & $F^\star$ & Yes & Yes & 39 & 3 & Yes, in \textsf{PURE} Effect \\
$\Pi\Sigma$ & N/A & No\linus{?} & Yes & 18 & 1 & No
\end{tabularx}
\caption{Comparison of Core Languages}
\label{tab:related:comp}
\end{table*}

\paragraph{General recursion without decidable type checking} To our
knowledge, Cayenne~\cite{cayenne} is the first programming language
that integrates the full power of dependent types with general
recursion. It bears some similarities with \name: first, it also uses
one syntactic form for both terms and types; second, it allows
arbitrary computation to happen at type level; third, because of
unrestricted recursion allowed in the system, Cayenne is logically
inconsistent, thus cannot be used as a proof system. However, the most
crucial difference from \name is that type-checking in Cayenne is
undecidable. From a pragmatic view, this design choice simplifies the
implementation (the implemented type checker fixes an upper bound on
the number of reductions that it may perform), among
others. Nevertheless, Cayenne is able to type check many useful
programs. In our opinion, \name improves in this respect by
persevering decidable type checking under the presence of general
recursion at type level.


\paragraph{Restricted recursion with termination checking}

Dependently typed languages such as Coq~\cite{coqsite} and
Adga~\cite{agda}, on the other hand, are conservative as to what kind
of computation is allowed at type level. Coq, as a proof system,
requires all programs to terminate by means of a termination checker,
ensuring that recursive calls are only allowed on \emph{syntactic
  subterms} of the primary argument. This way, decidable type checking
is also preserved. The conservative, syntactic criteria, to which Coq
adheres, are insufficient to support a variety of important
programming paradigms. Agda and Idris~\cite{idris}, in addition, offer
an option to disable the termination checker to allow for writing
arbitrary functions. This, however, costs us the nice property of
decidable type checking. While the idea that all programs should
terminate is all very nice, \name aims at a different goal: a
practical programming language. Most of the time, programmers just
want to write the function definitions, not much about delicate
reasoning and proof. We believe, by combining general recursion with
decidable type checking, we are closer to the goal of a practical
dependently typed programming language that work for both average
programmers and experts alike.

\paragraph{Stratified type system with general recursion on term level}

One way to allow general recursion and dependent types in the same
language and still have decidable type-checking is to use multiple
levels of syntax. In this way it is easy to have a term language with
powerful constructs, such as general recursion, but have a more
restricted type and/or kind language. On the other hand this brings
complexity to the language as multiple levels (possibly with similar
constructs) have to be managed.

Several early attempts of adding general recursion by using stratified
type systems include Twelf~\cite{lf:twelf} and
Delphin~\cite{lf:delphin}, both of which are implementations of the
Edinburgh Logical Framework (LF)~\cite{harper:lf}. LF is a
meta-langauge for encoding syntax, rules, and proofs by means of a
typed $\lambda$-calculus with dependent types. In a nutshell, the LF
calculus is a three-level calculus for object, families, and kinds,
and as such, Twelf and Delphin both have multiple syntactic
levels. Furthermore, Delphin defines a computation level, where
recursive functions can be defined by case analysis, and that the
recursion operator can only be used on computation types. This
however, from a language implementation view, is not desirable. In
other words, decidable type checking comes at a price of complexity
and duplication of language constructs. In contrast, \name unifies
terms and types into a single category, and still achieves decidable
type checking.

$F^{\star}$~\cite{Swamy2011} is a recently proposed dependently typed
language that supports writing general-purpose programs with effects
(e.g., state, exceptions, non-terminating, etc.) while maintaining a
consistent core language. Like Twelf and Delphin, it also has several
sub-languages -- for terms, proofs and so on. In $F^{\star}$, the use
of recursion is restricted in specifications and proofs while allowing
arbitrary recursion in the program. Another difference from \name is
that types in $F^{\star}$ can only contain values but no non-value
expressions, leading to its less expressiveness than \name.

To provide grounds for comparison, Table~\ref{tab:related:comp} lists
many aspects for different core languages. Here it is not to judge
which language is good or bad, but reflect different design
choices. As can be seen, \name uses fewer language constructs while
preserving decidable type checking, at a cost of logical consistency.

\paragraph{Unified syntax and managed type-level computation}

Pure Type Systems (PTS)~\cite{pts} show how a while family of type
systems can be implemented using just a single syntactic form. PTS are
an obvious source of inspiration for our work. Although this paper
presents a specific system, it should be easy to generalize \name in
the same way as PTS and further show the applicability of our ideas to
other systems.

An early attempt of using a single syntax for an intermediate language
for functional programming was Henk~\cite{pts:henk}. The Henk proposal
was to use the \emph{lambda cube} as a typed intermediate language,
unifying all three levels. The system used in Henk is not even a
dependently typed language, as the authors intended to disallow types
to depend on terms. As for recursion, even though it has a full lambda
calculus at the type level, recursion is disallowed. Moreover no
meta-theoretic results were proved for Henk.

In Cayenne, there is also no syntactic distinction between expressions
and types. Another recent work on dependently typed language based on
the same syntactic category is \textsf{Zombie}~\cite{zombie:popl14,
  zombie:thesis}, where terms, types and the single kind $\star$ all
reside in the same level. An interesting aspect of Zombie is that it
is composed of two fragments: a logical fragment where every
expression is known to terminate, and a programmatic fragment that
allows general recursion, so that it supports both partial and total
programming. Even though Zombie has one syntactic category, it is
still fairly complicated (note that in Table~\ref{tab:related:comp},
language constructs in some languages may also include primitives), as
it tries to be both consistent as a logic and pragmatic as a
programming language. In constrast \name takes another point of the
design space, giving up logical consistency for simplicity.

$\Pi\Sigma$~\cite{dep:pisigma} is another small dependently typed core
language that resembles \name. It has no syntactic difference between
terms and types, while also supporting general recursion. Like \name,
$\Pi\Sigma$ uses one recursion mechanism for both types and
functions. The key idea relies on lifted types and boxes: definitions
are not unfolded inside boxes. One concern of $\Pi\Sigma$ is that its
metatheory is not yet formally developed. \jeremy{more?}

\bruno{Maybe have a paragraph on recursive types?}

\paragraph{Adding dependent types to existing languages}

There has also been a lot work on adding dependent types to existing
programming languages. Indeed, one of our primal motivations is to
develop a simpler alternative to existing core language for
Haskell. The current core language for Haskell, System
$F_{C}$~\cite{Eisenberg:2014}, already supports general algebraic
datatypes, datatype promotion, type families, and soon even kind
equality~\cite{fc:kind}. Nowadays System $F_{C}$ has grown to be a
relatively large and complex core language. As can been seen in
Table~\ref{tab:related:comp}, it has over 30 language constructs. In
\name, we believe we have found a sweet spot, where there are fewer
language constructs and quite a number of modern features found in
Haskell.


% \paragraph{Unification of Terms, Types, and Kinds}
% Pure Type Systems (PTS)~\cite{pts} show how a while family of type systems
% can be implemented using just a single syntactic form. PTS are an
% obvious source of inspiration for our work. Although this paper
% presents a specific system, it should be easy to generalize \name 
% in the same way as PTS and further show the applicability of our 
% ideas to other systems. 

% An early attempt of using a single syntax for an intermediate language
% for functional programming was Henk~\cite{pts:henk}. The Henk proposal
% was to use the \emph{lambda cube} as a typed intermediate language,
% unifying all three levels. The system used in Henk
% it is not even a dependently typed
% language, as the authors intended to  disallow types to depend
% on terms. As for recursion, even though it has a full lambda calculus
% at the type level, recursion is disallowed. Moreover no meta-theoretic 
% results were proved for Henk.

% \begin{comment}
% Since the implicit conversion of the lambda
% cube is not syntax-directed, they come up with a approach to
% strategically distribute the conversion rule over the other typing
% rules. In retrospect, Henk is quite conservative in terms of
% type-level computation. Actually it is not even a dependently typed
% language, as they clearly state that they don't allow types to depend
% on terms. As for recursion, even though it has a full lambda calculus
% at the type level, recursion is disallowed. In Henk the authors have
% not attempted to prove any meta-theoretic results.
% \end{comment}

% Another recent work on dependently typed language based on the same
% syntactic category is \textsf{Zombie}~\cite{zombie:popl14,
%   zombie:thesis}, where terms, types and the single kind $\star$ all
% reside in the same level. The language is based on a call-by-value
% variant of lambda calculus. An interesting aspect of Zombie is that
% it is composed of two fragments: a logical fragment and a programmatic
% fragment, so that it supports both partial and total programming. Even
% though Zombie has one syntactic category, it is still fairly
% complicated, as it tries to be both consistent as a logic and
% pragmatic as a programming language. In constrast \name takes 
% another point of the design space, giving up logical consistency 
% for simplicity.

% $\Pi\Sigma$~\cite{dep:pisigma} is another recently proposed
% dependently typed core language that resembles \name, as there is no
% syntactic difference between terms and types.\bruno{So? What's the
%   difference?}
% \bruno{Cayenne? general recursion, but no decidable type-checking.}

% \paragraph{General Recursion and Managed Type-level Computation}
% One way to allow general recursion and dependent types in the same
% language and still have decidable type-checking is to use multiple
% levels of syntax. In this way it is easy to have a term language with 
% powerful constructs, such as general recursion, but have a more
% restricted type and/or kind language. On the other hand this brings 
% complexity to the language as multiple levels (possibly with similar
% constructs) have to be managed.

% \bruno{Very important reference: A Framework for Defining Logics}
% \bruno{integrate paragraph I wrote above better with subsequent text.}

% \begin{comment}
% As discussed in \S\ref{sec:rec}, bringing general
% recursion blindly into the dependently typed world causes more trouble
% than convenience. There are many dependently typed languages that
% allow general recursion. Zombie approaches general recursion by
% separating a consistent sub-language, in which all expressions are
% known to terminate, from a programmatic language that supports general
% recursion. What is interesting about Zombie is that those two
% seemingly conflicting worlds can interact with each other nicely,
% without compromising the consistency property. The key idea of this is
% to distinguish between these two fragments by using a
% \emph{consistency classifier $\theta$}. When $\theta$ is \textsf{L},
% it means the logical part, and \textsf{P} the program part. Like
% \name, Zombie uses \textsf{roll} and \textsf{unroll} for iso-recursive
% types. To ensure normalization (in order for decidable type checking),
% it forbids the use of \textsf{unroll} in \textsf{P}, where the
% potential non-termination could arise.\bruno{Zombie is being discussed
% in two different places.}
% \end{comment}

% $F^{\star}$~\cite{Swamy2011} also supports writing general-purpose
% programs with effects (e.g., state, exceptions, non-terminating, etc.)
% while maintaining a consistent core language. Unlike \name, it has
% several sub-languages -- for terms, proofs and so on. The interesting
% part of $F^{\star}$ lies in its kind system, which tracks the
% sub-languages and controls the interactions between them. The idea is
% to restrict the use of recursion in specifications and proofs while
% allowing arbitrary recursion in the program. They use $\star$ to
% denote program terms that may be effectful and divergent, and
% \textsf{P} for proofs that identify pure and total functions. In this
% way, they are able to ensure that fragments in a program used for
% building proof terms are never mixed with those that are potentially
% divergent. One difference from \name is that, types in $F^{\star}$ can
% only contain values but no non-value expressions, leading to its less
% expressiveness than \name.

% $\Pi\Sigma$ has a general mechanism for recursion. Like \name, it uses
% one recursion mechanism for the definition of both types and
% programs\bruno{Oh! So they have recursive types and recursion using 
% a single construct?}. The key idea relies on lifted types and boxes: definitions
% are not unfolded inside boxes. The way they achieve decidable type
% checking is to use boxing to stop the infinite unfolding of the
% recursive call, at the cost of additional annotations stating where to
% lift, box and force. One concern of $\Pi\Sigma$ is that its metatheory
% is not yet formally developed.\bruno{Maybe have a paragraph on
%   recursive types?}

\paragraph{Type in Type}
We are not the the first to embrace $\star : \star$ in the system. It
has been long known that systems with $\star : \star$ (usually called
system $\lambda *$) is inconsistent as a logic, in the sense that all
types are inhabited. In this system, we can encode a variant of
Russel's paradox, known as Girard's
paradox~\cite{coquand1986analysis}.

The core language of the Glasgow Haskell Compiler, System
$F_{C}$~\cite{fc} has been extended with type promotion \cite{fc:pro}
and kind equality \cite{fc:kind}. The latter one introduces a limited
form of dependent types into the system\footnote{Richard A. Eisenberg
  is going to implement kind equality \cite{fc:kind} into GHC. The
  implementation is proposed at
  \url{https://phabricator.haskell.org/D808} and related paper is at
  \url{http://www.cis.upenn.edu/~eir/papers/2015/equalities/equalities-extended.pdf}.},
which mixes up types and kinds. This causes no trouble for FC, since
all kinds are already inhabited without the above
extensions. $\Pi\Sigma$ has a impredicative universe of types with
$\mathsf{Type} : \mathsf{Type}$ due to the support of general
recursion. The surface language of Zombie also has the rule
$\Gamma \vdash \mathsf{Type} : \mathsf{Type}$~\cite{zombie:popl15}.

The $\star : \star$ axiom makes it convenient to support kind
polymorphism, among other language features. One concern is that it
often causes type checking to be undecidable, if not dealt with
carefully, as it allows to express divergent terms. However, as we
explained in \S\ref{sec:ecore}, this is not the case for \name. Type
checking in \name is decidable -- all type-level computation is driven
by finite cast operations, thus no potentially infinite reductions can
happen in reality.

\paragraph{Encoding of Datatypes}
One thing \name differs from other functional programming languages is
that all the high-level features in the surface language like
datatypes, pattern matching and so on can be easily encoded into the
core language. There is much work on encoding datatypes into various
high-level languages. The classic Church encoding of datatypes into
System F is detailed in the work of Bohm and
Beraducci~\cite{Bohm1985}. The Church encoding excels in implementing
iterative or fold-like functions over algebraic datatypes, but is
awkward in expressing general recursion, usually in a complex and
insufficient way. An alternative encoding of datatypes is the so
called \emph{Scott} encoding. However Scott encoding is not typable in
System F, as it needs recursive types to represent recursive
datatypes. \name has all it needs to represent polymorphic and
recursive datatypes. The explicit cast rules also makes it possible to
encode GADTs, as can be seen in the last examples in
Section~\ref{sec:app}. Currently we are investigating how the encoding
of GADTs interact with the other language constructs. We leave this as
future work.

Another line of related work is the \emph{inductive defined types} in
the Calculus of Inductive Constructions (CIC)~\cite{cic}, which is the
underlying formal language of Coq. In CIC, inductive defined types can
be represented by closed types in \coc, so are the primitive recursive
functionals over elements of the type. The limitation of their work is
that functions over inductive defined types are definable only by
primitive recursion. McBride et al.~\cite{elim:pi:pattern} show that
inductive families of datatypes with dependent pattern matching can be
translated into terms in Luo's UTT~\cite{Luo:UTT}, extended with axiom
K~\cite{axiomK}. The novelty in his work is the introduction of
\emph{splitting tree}, with which explicit evidence for impossible
case branches is recorded.

% \begin{itemize}
% \item Henk \cite{pts:henk} and one of its implementation \cite{pts:fp} show the simplicity of the Pure Type System (PTS). \cite{pts:rec} also tries to combine recursion with PTS.

% \item \textsf{Zombie} \cite{zombie:popl14, zombie:thesis} is a language with two fragments supporting logics with non-termination. It limits the $\beta$-reduction for congruence closure \cite{zombie:popl15}.

% \item $\Pi\Sigma$ \cite{dep:pisigma} is a simple, dependently-typed core language for expressing high-level constructions\footnote{But the paper didn't give any meta-theories about the langauge.}. UHC compiler \cite{fc:uhc} tries to use a simplified core language with coercion to encode GADTs.

% \item System $F_C$ \cite{fc} has been extended with type promotion \cite{fc:pro} and kind equality \cite{fc:kind}. The latter one introduces a limited form of dependent types into the system\footnote{Richard A. Eisenberg is going to implement kind equality \cite{fc:kind} into GHC. The implementation is proposed at \url{https://phabricator.haskell.org/D808} and related paper is at \url{http://www.cis.upenn.edu/~eir/papers/2015/equalities/equalities-extended.pdf}.}, which mixes up types and kinds.
% \end{itemize}
