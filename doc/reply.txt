We thank all reviewers for their valuable and thoughtful comments.

***First of all, let us reemphasize the goal of our paper, since some
reviewers seem to be confused about it.  There are at least two
benefits of using PTS-style, unified syntax for a core language:

1)It can open up the rich world of Dependently Typed Programming
(DTP), as in Coq/Agda/Idris...;

2)It can *significantly simplify core languages*, by eliminating
redundancy between the various syntactic levels.

The goal of this paper is to achieve 2, not 1! In particular we aim at
more traditional functional languages like ML or Haskell extended with
many interesting type-level features, but perhaps not the full power
of dependent types.

#143A

***Logical and programmatic fragments in languages like Zombie or F* are
tightly coupled. Therefore it is hard to make comparisons only with
the programmatic fragment. For example, in Zombie, the conversion rule
(TConv) for the programmatic part depends on equality proofs, which
are only available in the logical part.

#143B

***"The ideas in this paper are not new."

Our work essentially gives a positive answer to the question: 

"Can we have a calculus comparable in simplicity to PTS that models key
features of modern functional languages (like Haskell and ML), while
preserving type-soundness and decidable type-checking?"

*None of the suggested references [1,2,3,4,5] gives a direct 
answer to this question. [1] does not support decidable type-checking; 
whereas [2,3,4,5] are significantly more complex than a PTS-based 
calculus. 

*“The use of general recursion to implement recursive types is
already shown in Cardelli's paper”

Our claimed contribution is "a generalization of iso-recursive
types". *Cardelli's work does not show this*: Cardelli models
*equi*-recursive types (he uses no casts and/or
fold/unfold). The whole point of using iso-recursive types is to
obtain decidable type-checking, which Cardelli does not have.

Moreover, *we do not claim to be the first to unify recursion and
recursive types*. In our related work we acknowledge that others had
this idea in the past:

"Like λμ⋆ , ΠΣ uses one recursion mechanism for both types and
functions" 

*The reviewer suggests that our idea for casts is not new.  It is true
that other systems have some form of casts as an alternative to the
conversion rule, including System FC which was our initial
inspiration. However, all cast approaches in [2,3,4,5] and System FC
rely on equality proofs. *In contrast, our one-step casts do not rely
on equality proofs*. This is a *fundamental* difference in because:

1)To build equality proofs we need various other language
constructs, which **adds to the complexity of the language**.

2)We need to ensure that the equality proofs are valid. Otherwise, we
could easily build bogus equality proofs with non-termination, and
break type-safety:

_|_ : Int = Char

Solutions to this problem do exist. For example, in Zombie, the
existence of a logical fragment can guarantee that the proofs are
valid. Other approaches include restricting valid equality proofs to
be syntactic values only [2,4], or having different languages for
proofs and terms [3,5]. However all those solutions *significantly
complicate the language design!*


***A large part of the criticism in this review is based on the
assumption that we claim our core language to be good for DTP. For
example, the reviewer states:

”In particular, the comparisons suggest that the goal of the proposed
language is dependently-typed programming, as in Cayenne, Idris, Coq
or Agda”

*This assumption is false*. In the introduction, we clearly say that:

“A **non-goal** of the current work (although a worthy avenue for
future work) is to use λμ⋆ as a core language for modern dependently
typed languages like Agda or Idris”

The reviewer also has a large paragraph complaining about missing 
features from FC and features useful for DTP.

It is true that certain features of FC cannot be expressed, 
*but this is acknowledged in the paper*. See related work paragraph 
on System FC, where we talk about GADTs and equality for example.
We will emphasize the limitations against FC better, 
and include discussions on erasability (which we have indeed 
not mentioned).  


***"the paper does not discuss the trade-offs involved when allowing
nontermination in dependently-typed languages"

*This is not true*: we do mention the loss of logical consistency as
another trade-off in the introduction (paragraph before contributions).


***“but this surface language lacks type-level computation, meaning that it
cannot take advantage of the main benefits of the core language.”

In fact the surface language takes good advantage of the benefits
of the core language. The encoding of datatypes and case analysis, for
example, uses casts and type-level computation steps in a fundamental
way: we need to use casts to simulate fold/unfold, and we also need
small type-level computational steps to encode parametrised datatypes.

#143D

***Please note that casts are mostly meant as a feature of the *core*
language, and are not meant to be used in the source.  The
contribution of Section 3 is to illustrate how many features of source
languages are encoded using *type-level computation and casts*.
See also the reply to the last point for reviewer B.

Intensive type-level computation would indeed be inconvenient at
the moment (say by allowing casts on the source), but please look at
our discussion in last paragraph of Section 8 for what can be done.
