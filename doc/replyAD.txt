# Reviewer A

- "Since the language presented does not have a consistent logical
fragment, it would be more interesting to make the comparison with
just the programming part of other languages in the related work
section."

[Response] Because two fragments of Zombie or F* are tightly coupled,
it is rather hard to make the comparison only with the programmatic
fragment alone. In Zombie, the conversion rule (TConv) for
programmatic part depends on the equality proof, which is only
available in the logical part.

# Reviewer D

- "Making type-level computation steps explicit is a big inconvenience
at best ... and impossible at worst"

- "... unless you're willing to first prove that type-checking a
higher-level language is decidable before attempting a down-coding, or
restrict yourself to provably terminating forms of recursion ..."

- "These problems become evident in Section 6, which translates a
language for which *type-checking is already known to be decidable* to
the core calculus developed in the paper.  In that light, the
discussion of supported features in Section 3 doesn't seem to point to
any contribution."

[Response] Just like System FC, the convenience of type-level
computation in the core is given up but compensated by language
constructs in the surface. The number of casts can be computed during
the translation. It is indeed impossible to compute the number of
casts for arbitrary type-level computation. But in a practical surface
language, type-level computation is often restricted for generating
type casts, such as type families in Haskell. We have thoroughly
discussed this issue in the second paragraph of Section 8.

