\newcommand{\Nat}{\mathsf{Nat}} \newcommand{\zero}{\mathsf{zero}}
\newcommand{\suc}{\mathsf{suc}} \newcommand{\plus}{\mathsf{plus}}
\newcommand{\List}{\mathsf{List}} \newcommand{\nil}{\mathsf{nil}}
\newcommand{\cons}{\mathsf{cons}}
\newcommand{\length}{\mathsf{length}}
\newcommand{\PlFunc}{\Nat\rightarrow\Nat\rightarrow\Nat}
\newcommand{\case}{\mathbf{case}} \newcommand{\of}{\mathbf{of}}
\newcommand{\data}{\mathbf{data}} \newcommand{\where}{\mathbf{where}}
\newcommand{\letb}{\mathbf{let}} \newcommand{\inb}{\mathbf{in}}

\subsection{Extended Language}

We extend $\lambda C_{\mu}$ with simple datatypes and case analysis,
namely $\lambda C_{\mu c}$. Differences with $\lambda C_{\mu}$ are
highlighted in Figure~\ref{fig:datasyn}.

\begin{figure}[ht]
  \small
  \begin{syntax}
    pgm &::= & \hlmath{\overline{decl}; A} & \ptext{Declarations} \\
    decl &::= & \hlmath{\data\,T\,\where\,\overline{K : A \rightarrow T}} & \ptext{Datatype} \\
    u &::= & \hlmath{x \mid K} & \ptext{Variables and data constructors} \\
    A &::= & \hlmath{u} & \ptext{Term atoms} \\
    & \mid & \star & \ptext{Star} \\
    & \mid & \square & \ptext{Square} \\
    & \mid & A \ A & \ptext{Application} \\
    & \mid & \lam{x}{A}{A} & \ptext{Abstraction} \\
    & \mid & \pai{x}{A}{A} & \ptext{Product} \\
    & \mid & \miu{x}{A} & \ptext{Recursive type} \\
    & \mid & \fold{\miu{x}{A}}{A} & \ptext{Roll} \\
    & \mid & \unfold{A} & \ptext{Unroll} \\
    & \mid & \bet{A} & \ptext{Type reduction} \\
    & \mid & \hlmath{\letb\,x : A = A\,\inb\,A} & \ptext{Let binding} \\
    & \mid & \hlmath{\case\,A\,\of\,\overline{p \Rightarrow A}} & \ptext{Case analysis} \\
    p &::= & \hlmath{K\,\overline{x : A}} & \ptext{Pattern} \\
    \Gamma &::= &\varnothing & \ptext{Empty} \\
    & \mid & \hlmath{\Gamma,u:A} & \ptext{Variable binding}
  \end{syntax}
  \caption{Syntax of $\lambda C_{\mu c}$}\label{fig:datasyn}
\end{figure}

The extended typing rules are shown in Figure~\ref{fig:datatype}. To
save space, we only show the new typing rules.

\begin{figure}[ht]
  \centering \small
  \begin{tabular}{lcl}
    \framebox{$\Gamma \vdash pgm : A$} \\
    (Pgm) & \ruleIII{\overline{\Gamma \vdash decl : \Gamma_{d}}}{\Gamma = \Gamma_{0}, \overline{\Gamma_{d}}}{\ctx{e:A}}{\Gamma_{0} \vdash \overline{decl}; e : A} \\
    \framebox{$\Gamma \vdash decl : \Gamma^{\prime}$} \\
    (Data) & \ruleI{\overline{\Gamma, T:\star \vdash A:\star}}{\ctx{(\data\,T\,\where\,\overline{K:A}): (T:\star, \overline{K:A})}} \\
    \framebox{$\Gamma \vdash e : A$} \\
    (Case) & \ruleII{\ctx{e:T}}{\overline{\Gamma\vdash_{p} p \Rightarrow e:T \rightarrow B}}{\Gamma\vdash\case\,e\,\of\,\overline{p \Rightarrow e}:B} \\
    (Let) & \ruleII{\ctx{e_{1}:A}}{\ctxw{x:A}{e_{2}:B}}{\letb\,x:A = e_{1}\,\inb\,e_{2}:B} \\
    \framebox{$\Gamma \vdash_{p} p \Rightarrow e : T \rightarrow B$} \\
    (Alt) & \ruleII{K : \overline{A} \rightarrow T \in \Gamma}{\Gamma, \overline{x:A} \vdash e : B}{\Gamma \vdash_{p} K\,\overline{x:A} \Rightarrow e : T \rightarrow B}
  \end{tabular}
  \caption{Typing rules for $\lambda C_\mu c$}\label{fig:datatype}
\end{figure}

\subsection{Translation Overview}

We use a type-directed translation. The typing relations have the
form:
\[
  \Gamma \vdash e : A \rightsquigarrow \hat{e}
\]

It states that $\lambda C_{\mu}$ expression $\hat{e}$ is the
translation of $\lambda C_{\mu c}$ expression $e$.


% \subsubsection{Examples of Simple Datatypes}

% \begin{itemize}

% \item We can encode the type of natural numbers as follow:
%   \[
%     \Nat = \mu X.\ \Pi(a : \star).\ a \rightarrow (X \rightarrow a)
%     \rightarrow a
%   \]
%   then we can define $\zero$ and $\suc$ as follows:
%   \begin{align*}
%   \zero &: \Nat \\
%   \zero &= \fold{\Nat}{(\lambda (a : \star) (z : a) (f : \Nat \rightarrow a).\,z)}\\
%   \suc &: \Nat \rightarrow \Nat\\
%   \suc &= \lambda (n : \Nat).\,\fold{\Nat}{(\lambda (a : \star) (z : a) (f : \Nat \rightarrow a).\,f\,n)}
% \end{align*}
% Using $\mathsf{fix}$, we can define a recursive function $\plus$ as
% follow:
% \begin{align*}
%   \plus &:\PlFunc\\
%   \plus &=\mathsf{fix}\,(\PlFunc)\,(\lambda(p : \PlFunc)(n : \Nat)(m : \Nat).\\
%         &\qquad (\unfold[\Nat]{n})\,\Nat\,m\,(\lambda (n^{\prime} : \Nat).\,\suc\,(p\,n^{\prime}\,m)))
% \end{align*}
% \item We can encode the type of lists of a certain type:
%   \[
%     \List = \mu X.\,\Pi(a : \star).\,a \rightarrow (\Pi (b :
%     \star).\,b \rightarrow X \rightarrow a) \rightarrow a
%   \]
%   then we can define $\nil$ and $\cons$ as follows:
%   \begin{align*}
%   \nil &: \List\\
%   \nil &= \fold{\List}{(\lambda (a : \star) (z : a) (f : \Pi (b : \star).\,b \rightarrow \List \rightarrow a).\ z)}\\
%   \cons &: \Pi (b : \star).\,b \rightarrow \List \rightarrow \List\\
%   \cons &= \lambda(b : \star)(x : b)(xs : \List).\\
%        &\qquad \fold{\List}{(\lambda(a : \star)(z : a)(f : \Pi (b : \star).\,b\rightarrow \List \rightarrow a).\,f\,b\,x\,xs)}
% \end{align*}
% Using $\mathsf{fix}$, we can define a recursive function $\length$
% as follow:
% \begin{align*}
%   \length &: \List \rightarrow \Nat\\
%   \length &= \mathsf{fix}\,(\List \rightarrow \Nat)\,(\lambda(l : \List
%             \rightarrow \Nat)(xs : \List).\\
%           &\qquad (\unfold[\List]{xs})\,\Nat\,\zero\,(\lambda(b : \star)(y : b)(ys : \List).\,\suc\,(l\,ys)))
% \end{align*}
% % \item The rule $(\mathsf{Mu})$ doesn't allow me to express
% %   something
% %   like $(\mu x.\,A) : \Nat \rightarrow \star$
% \end{itemize}

% \subsubsection{Elaboration of Datatypes}

% We can extend $\lambda C_{\mu}$ with \emph{first-order}
% datatypes~\cite{geuvers2014church}:
% \[
%   \mathbf{data} \quad D = K_{1}\,T_{1}^{1}(D) \dots
%   T_{\mathsf{ar}(1)}^{1}(D) \mid \cdots \mid K_{n}\,T_{1}^{n}(D)
%   \dots T_{\mathsf{ar}(n)}^{n}(D)
% \]
% where each of the $T_{i}^{j}(X)$ is either $X$ or a type expression
% that does not contain $X$. This defines an algebraic datatype $D$
% with $n$ constructors. Each constructor $K_{i}$ has arity
% $\mathsf{ar}(i)$, which can be zero.

% We adopt the following convention: we write $T^{1}(X)$ for
% $T_{1}^{1}(X) \dots T_{\mathsf{ar}(1)}^{1}(X)$ etc. So each data
% constructor has the following types:
% \begingroup
% \renewcommand*{\arraystretch}{1.0}
% \begin{table}[h]
%   \centering
%   \begin{tabular}{lll}
%     $K_{1}$ &:& $T^{1}(D) \rightarrow D$ \\
%             && \dots \\
%     $K_{n}$ &:& $T^{n}(D) \rightarrow D$
%   \end{tabular}
% \end{table}
% \endgroup

% Next we show how datatypes can be translated to our system with
% recursive types.

% Given a datatype $D$, with constructors $K_{1},\dots,K_{n}$, the
% encoding of $D$ in our system is given by:
% \[
%   D ::= \mu \beta.\,\Pi(\alpha : \star).\,(T^{1}(\beta) \rightarrow
%   \alpha) \rightarrow \dots \rightarrow (T^{n}(\beta) \rightarrow
%   \alpha) \rightarrow \alpha
% \]

% The constructors are encoded by:
% \begin{align*}
%   K_{i} &::= \lambda(x_{1}:T_{1}^{i}(D))\dots(x_{\mathsf{ar}(i)}:T_{\mathsf{ar}(i)}^{i}(D)).\\
%         &\quad \fold{D}{(\lambda(\alpha:\star)(c_{1}:T^{1}(D) \rightarrow \alpha)\dots(c_{n}:T^{n}(D) \rightarrow \alpha).\,c_{i}\,x_{1} \dots x_{\mathsf{ar}(i)})}
% \end{align*}

% \subsubsection{Elaboration of Case Analysis}

% The set of expressions $A$ of $\lambda C_{\mu}$ extended with case
% analysis is defined by
% \[
%   \renewcommand*{\arraystretch}{1.0}%
%   \begin{array}{lcl}
%     A &::= & x \mid \star \mid \square \\
%       & \mid & AA \mid \lambda x:A.A \mid \Pi x:A.A \\
%       & \mid & \mu x.A \mid \fold{A}{A} \mid \unfold[A]{A} \\
%       & \mid & \bet{A} \\
%       & \mid & \case \,A\,\of\,\{x\,x_{1}\,x_{2} \dots \Rightarrow A; \dots\}
%   \end{array}
% \]

% Suppose we have
% \begin{align*}
%   \case\,&x\,\of\,\{\\
%          &K_{1}\,x_{1}\dots x_{\mathsf{ar}(1)} \Rightarrow r_{1}\\
%          &\dots\\
%          &K_{n}\,x_{1}\dots x_{\mathsf{ar}(n)} \Rightarrow r_{n}\\
%          &\}
% \end{align*}
% where $x : D$ and $r_{1},\dots,r_{n} : T$ ($T$ is some known type).

% This can be translated to our system as follows:
% \begin{align*}
%   (\unfold[D]{x})\,T\,&(\lambda(x_{1}:T_{1}^{1}(D))\dots(x_{\mathsf{ar}(1)}:T_{\mathsf{ar}(1)}^{1}(D)).\,r_{1})\\
%                       &\dots\\
%                       &(\lambda(x_{1}:T_{1}^{n}(D))\dots(x_{\mathsf{ar}(n)}:T_{\mathsf{ar}(n)}^{n}(D)).\,r_{n})
% \end{align*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "pts"
%%% End:
