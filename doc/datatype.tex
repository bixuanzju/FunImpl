\newcommand{\Nat}{\mathsf{Nat}} \newcommand{\zero}{\mathsf{zero}}
\newcommand{\suc}{\mathsf{suc}} \newcommand{\plus}{\mathsf{plus}}
\newcommand{\List}{\mathsf{List}} \newcommand{\nil}{\mathsf{nil}}
\newcommand{\cons}{\mathsf{cons}}
\newcommand{\length}{\mathsf{length}}
\newcommand{\PlFunc}{\Nat\rightarrow\Nat\rightarrow\Nat}
\newcommand{\case}{\mathbf{case}} \newcommand{\of}{\mathbf{of}}
\newcommand{\data}{\mathbf{data}} \newcommand{\where}{\mathbf{where}}
\newcommand{\letbb}{\mathbf{let}} \newcommand{\inb}{\mathbf{in}}

\subsection{Extended Language}

We extend $\lambda C_{\mu}$ with simple datatypes and case analysis,
namely $\lambda C_{\mu c}$. Differences with $\lambda C_{\mu}$ are
highlighted in Figure~\ref{fig:datasyn}.

\begin{figure}[H]
  \small
  \begin{syntax}
    \textbf{Declarations} \\
    pgm &::= & \hlmath{\overline{decl}; e} & \ptext{Declarations} \\
    decl &::= & \hlmath{\data\,D : \overline{\kappa} \rightarrow \star\,\where} \\
    & & \quad \hlmath{K : \Pi\overline{x : \kappa}.\Pi\overline{y : \iota}.\overline{\tau} \rightarrow D\,\overline{x}} & \ptext{Datatype} \\ \\
    \textbf{Terms} \\
    u &::= & \hlmath{x \mid K} & \ptext{Variables and data constructors} \\
    e,\tau,\kappa,\iota &::= & \hlmath{u} & \ptext{Term atoms} \\
    & \mid & \star & \ptext{Star} \\
    & \mid & \square & \ptext{Square} \\
    & \mid & e \ e & \ptext{Application} \\
    & \mid & \lam{x}{\tau}{e} & \ptext{Abstraction} \\
    & \mid & \pai{x}{\tau}{\tau} & \ptext{Product} \\
    & \mid & \miu{x}{\tau} & \ptext{Recursive type} \\
    & \mid & \fold{\tau}{e} & \ptext{Generalized roll} \\
    & \mid & \unfold{e} & \ptext{Generalized unroll} \\
    & \mid & \hlmath{\case\,e\,\of\,\overline{p \Rightarrow e}} & \ptext{Case analysis} \\
    p &::= & \hlmath{K\,\overline{y : \kappa}\,\overline{x : \tau}} & \ptext{Pattern} \\ \\
    \textbf{Environments} \\
    \Gamma &::= &\varnothing & \ptext{Empty} \\
    & \mid & \hlmath{\Gamma,u:\tau} & \ptext{Variable binding}
  \end{syntax}
  \caption{Syntax of $\lambda C_{\mu c}$ ($e$ for terms, $\tau$ for
    types, $\kappa, \iota$ for kinds)}\label{fig:datasyn}
\end{figure}

An \emph{algebraic data type} $D$ is introduced as a top-level
\textbf{data} declaration with its \emph{data constructors}. The type
of a data constructor $K$ has the form:
\[
  K : \Pi\overline{x : \kappa}^{n}.\Pi\overline{y : \iota}.\overline{\tau} \rightarrow D\,\overline{x}^{n}
\]
The first $n$ quantified type variables $\overline{x}$ appear in the
same order in the return type $D\,\overline{x}$, and $\overline{y}$
stands for existentially quantified type variables. There is a $\case$
expression to take apart values built with data constructors. The
patterns of a case expression are flat (no nested patterns), and bind
existential type variables.

The extended typing rules are shown in Figure~\ref{fig:datatype}. To
save space, we only show the new typing rules.

\begin{figure}[ht]
  \centering \small
  \begin{tabular}{lcl}
    \framebox{$\Gamma \vdash pgm : \tau$} \\
    (Pgm) & \ruleIII{\overline{\Gamma_{0} \vdash decl : \Gamma_{d}}}{\Gamma = \Gamma_{0}, \overline{\Gamma_{d}}}{\ctx{e:\tau}}{\Gamma_{0} \vdash \overline{decl}; e : \tau} \\
    \framebox{$\Gamma \vdash decl : \Gamma^{\prime}$} \\
    (Data) & \ruleI{\overline{\Gamma, D:\star \vdash \overline{\tau} \rightarrow D:\star}}{\ctx{(\data\,D = \overline{K\,\overline{\tau}}): (D:\star, \overline{K:\overline{\tau} \rightarrow D})}} \\
    \framebox{$\Gamma \vdash e : \tau$} \\
    (Case) & \ruleII{\ctx{e:D}}{\overline{\Gamma\vdash_{p} p \Rightarrow e:D \rightarrow \tau}}{\Gamma\vdash\case\,e\,\of\,\overline{p \Rightarrow e}:\tau} \\
    \framebox{$\Gamma \vdash_{p} p \Rightarrow e : D \rightarrow \tau$} \\
    (Alt) & \ruleII{K : \overline{\tau} \rightarrow D \in \Gamma}{\Gamma, \overline{x:\tau} \vdash e : \tau'}{\Gamma \vdash_{p} K\,\overline{x:\tau} \Rightarrow e : D \rightarrow \tau'}
  \end{tabular}
  \caption{Typing rules for $\lambda C_\mu c$}\label{fig:datatype}
\end{figure}

\subsection{Translation Overview}

We use a type-directed translation. The typing relations have the
form:
\[
  \Gamma \vdash e : \tau \rightsquigarrow E
\]

It states that $\lambda C_{\mu}$ expression $E$ is the translation of
$\lambda C_{\mu c}$ expression $e$ of type
$\tau$. Figure~\ref{fig:datatrans} shows the translation rules, which
are the typing rules of the previous section extended with the
resulting expression $E$.

\begin{figure}[ht!]
  \centering \small
  \begin{tabular}{lcl}
    \framebox{$\Gamma \vdash e : \tau \rightsquigarrow E$} \\
    (Ax) & \ruleI{}{\ctxz{\star:\square \rightsquigarrow \star}} \\

    (Var) & \ruleI{x:\tau \in \Gamma}{\ctx{x:\tau \rightsquigarrow x}} \\

    (App) & \ruleII{\ctx{e_{1}:(\pai{x}{\tau_{2}}{\tau_{1}}) \rightsquigarrow E_{1}}}{\ctx{e_{2}:\tau_{2} \rightsquigarrow E_{2}}}{\ctx{e_{1}e_{2}:\tau_{1}[x:=e_{2}] \rightsquigarrow E_{1}E_{2}}} \\

    (Lam) & \ruleII{\ctxw{x:\tau_{1}}{e:\tau_{2} \rightsquigarrow E}}{\ctx{(\pai{x}{\tau_{1}}{\tau_{2}}):t}}
            {\ctx{(\lam{x}{\tau_{1}}{e}}):(\pai{x}{\tau_{1}}{\tau_{2}}) \rightsquigarrow \lam{x}{\tau_{1}}{E}}
          & $t \in \{\star, \square\}$ \\

    (Pi) & \ruleII{\ctx{\tau_{1}:s}}{\ctxw{x:\tau_{1}}{\tau_{2}:t}}{\ctx{(\pai{x}{\tau_{1}}{\tau_{2}}):t \rightsquigarrow \pai{x}{\tau_{1}}{\tau_{2}}}}
          & $(s,t) \in \mathcal{R}$ \\

    (Mu) & \ruleI{\ctxw{x:s}{\tau:s}}{\ctx{(\miu{x}{\tau}):s \rightsquigarrow \miu{x}{\tau}}} \\

    (Fold) & \ruleIII{\ctx{e:\tau_{2} \rightsquigarrow E}}{\ctx{\tau_{1}:s}}{\tau_{1} \tolong \tau_{2}}%
             {\ctx{(\fold{{\tau_{1}}}{e}):{\tau_{1}} \rightsquigarrow \fold{\tau_{1}}{E}}} \\

    (Unfold) & \ruleIII{\ctx{e:\tau_{1} \rightsquigarrow E}}{\ctx{\tau_{2}:s}}{\tau_{1} \tolong \tau_{2}}%
               {\ctx{(\unfold{e}):\tau_{2} \rightsquigarrow \unfold{E}}} \\

    (Case) & \ruleII{\ctx{e:D \rightsquigarrow E}}{\overline{\Gamma\vdash_{p} p \Rightarrow e:D \rightarrow \tau \rightsquigarrow E_{1}}}{\Gamma\vdash\case\,e\,\of\,\overline{p \Rightarrow e}:\tau \rightsquigarrow (\unfold{E})\,\tau\,\overline{E_{1}}}\\
    % & $E ::= (\unfold{\hat{e}})\,B\,\overline{E_{1}}$ \\
    \framebox{$\Gamma \vdash_{p} p \Rightarrow e : D \rightarrow \tau \rightsquigarrow E$} \\
    (Alt) & \ruleII{K : \overline{\tau} \rightarrow D \in \Gamma}{\Gamma, \overline{x:\tau} \vdash e : \tau' \rightsquigarrow E}{\Gamma \vdash_{p} K\,\overline{x:\tau} \Rightarrow e : D \rightarrow \tau' \rightsquigarrow \lambda \overline{(x : \tau)}.E} \\
    \framebox{$\Gamma \vdash decl : \Gamma^{\prime} \rightsquigarrow E$} \\
    (Data) & \ruleI{\overline{\Gamma, D:\star \vdash \overline{\tau} \rightarrow D:\star}}{\ctx{(\data\,D = \overline{K\,\overline{\tau}}): (D:\star, \overline{K:\overline{\tau} \rightarrow D}) \rightsquigarrow E}} \\ \\
         & \begingroup \renewcommand*{\arraystretch}{1.0} $\begin{array} {lll} E & ::= & \letbb\,D : \star = \miu{\beta}{\pai{\alpha}{\star}{\overline{(\overline{\tau[D:=\beta]} \rightarrow \alpha)}} \rightarrow \alpha}\,\inb \\ & & \letbb\,K_{i}^{i \in 1..n} : \overline{\tau_{i}} \rightarrow D = \lambda\overline{(x : \tau_{i})}.\\ 
                                                                                 & & \quad \fold{D}{(\lambda (\alpha : \star)\overline{(c : \overline{\tau} \rightarrow \alpha)} . c_{i}\,\overline{x})}\,\inb \end{array}$ \endgroup \\
    \framebox{$\Gamma \vdash pgm : \tau \rightsquigarrow E$} \\
    (Pgm) & \ruleIII{\overline{\Gamma_{0} \vdash decl : \Gamma_{d} \rightsquigarrow E_{1}}}{\Gamma = \Gamma_{0}, \overline{\Gamma_{d}}}{\ctx{e:\tau \rightsquigarrow E}}{\Gamma_{0} \vdash \overline{decl}; e : A \rightsquigarrow \overline{E_{1}} \oplus E}
  \end{tabular}
  \caption{Type-directed translation from $\lambda C_\mu c$ to
    $\lambda C_\mu$}\label{fig:datatrans}
\end{figure}


\subsection{Examples of Simple Datatypes}

\begin{itemize}

\item We can encode the type of natural numbers as follows:
  \begin{align*}
    \data\,\Nat &= \zero \mid \suc\,\Nat \\
    \Nat &::= \mu X.\ \Pi(a : \star).\ a \rightarrow (X \rightarrow a) \rightarrow a    
  \end{align*}
  $\zero$ and $\suc$ are encoded as follows:
  \begin{align*}
    \zero &::= \fold{\Nat}{(\lambda (a : \star) (z : a) (f : \Nat \rightarrow a).\,z)}\\
    \suc &::= \lambda (n : \Nat).\,\fold{\Nat}{(\lambda (a : \star) (z : a) (f : \Nat \rightarrow a).\,f\,n)}
  \end{align*}
  Using $\mathsf{fix}$, we can define a recursive function $\plus$ as
  follow:
  \begin{align*}
    \plus &:\PlFunc\\
    \plus &=\mathsf{fix}\,(\PlFunc)\,(\lambda(p : \PlFunc)(n : \Nat)(m : \Nat).\\
          &\qquad (\unfold[\Nat]{n})\,\Nat\,m\,(\lambda (n^{\prime} : \Nat).\,\suc\,(p\,n^{\prime}\,m)))
  \end{align*}
\item We can encode the type of lists of natural numbers:
  \begin{align*}
    \data\,\List &= \nil \mid \cons\,\Nat\,\List \\
    \List &::= \mu X.\,\Pi(a : \star).\,a \rightarrow (\Nat \rightarrow X \rightarrow a) \rightarrow a    
  \end{align*}
  $\nil$ and $\cons$ are encoded as follows:
  \begin{align*}
    \nil &::= \fold{\List}{(\lambda (a : \star) (z : a) (f : \Nat \rightarrow \List \rightarrow a).\ z)}\\
    \cons &::= \lambda(x : \Nat)(xs : \List).\\
         &\qquad \fold{\List}{(\lambda(a : \star)(z : a)(f : \Nat\rightarrow \List \rightarrow a).\,f\,x\,xs)}
  \end{align*}
  Using $\mathsf{fix}$, we can define a recursive function $\length$
  as follows:
  \begin{align*}
    \length &: \List \rightarrow \Nat\\
    \length &= \mathsf{fix}\,(\List \rightarrow \Nat)\,(\lambda(l : \List
              \rightarrow \Nat)(xs : \List).\\
            &\qquad (\unfold[\List]{xs})\,\Nat\,\zero\,(\lambda(y : \Nat)(ys : \List).\,\suc\,(l\,ys)))
  \end{align*}
  % \item The rule $(\mathsf{Mu})$ doesn't allow me to express
  %   something like $(\mu x.\,A) : \Nat \rightarrow \star$
\end{itemize}

% \subsubsection{Elaboration of Datatypes}

% We can extend $\lambda C_{\mu}$ with \emph{first-order}
% datatypes~\cite{geuvers2014church}:
% \[
%   \mathbf{data} \quad D = K_{1}\,T_{1}^{1}(D) \dots
%   T_{\mathsf{ar}(1)}^{1}(D) \mid \cdots \mid K_{n}\,T_{1}^{n}(D)
%   \dots T_{\mathsf{ar}(n)}^{n}(D)
% \]
% where each of the $T_{i}^{j}(X)$ is either $X$ or a type expression
% that does not contain $X$. This defines an algebraic datatype $D$
% with $n$ constructors. Each constructor $K_{i}$ has arity
% $\mathsf{ar}(i)$, which can be zero.

% We adopt the following convention: we write $T^{1}(X)$ for
% $T_{1}^{1}(X) \dots T_{\mathsf{ar}(1)}^{1}(X)$ etc. So each data
% constructor has the following types:
% \begingroup
% \renewcommand*{\arraystretch}{1.0}
% \begin{table}[h]
%   \centering
%   \begin{tabular}{lll}
%     $K_{1}$ &:& $T^{1}(D) \rightarrow D$ \\
%             && \dots \\
%     $K_{n}$ &:& $T^{n}(D) \rightarrow D$
%   \end{tabular}
% \end{table}
% \endgroup

% Next we show how datatypes can be translated to our system with
% recursive types.

% Given a datatype $D$, with constructors $K_{1},\dots,K_{n}$, the
% encoding of $D$ in our system is given by:
% \[
%   D ::= \mu \beta.\,\Pi(\alpha : \star).\,(T^{1}(\beta) \rightarrow
%   \alpha) \rightarrow \dots \rightarrow (T^{n}(\beta) \rightarrow
%   \alpha) \rightarrow \alpha
% \]

% The constructors are encoded by:
% \begin{align*}
%   K_{i} &::= \lambda(x_{1}:T_{1}^{i}(D))\dots(x_{\mathsf{ar}(i)}:T_{\mathsf{ar}(i)}^{i}(D)).\\
%         &\quad \fold{D}{(\lambda(\alpha:\star)(c_{1}:T^{1}(D) \rightarrow \alpha)\dots(c_{n}:T^{n}(D) \rightarrow \alpha).\,c_{i}\,x_{1} \dots x_{\mathsf{ar}(i)})}
% \end{align*}

% \subsubsection{Elaboration of Case Analysis}

% The set of expressions $A$ of $\lambda C_{\mu}$ extended with case
% analysis is defined by
% \[
%   \renewcommand*{\arraystretch}{1.0}%
%   \begin{array}{lcl}
%     A &::= & x \mid \star \mid \square \\
%       & \mid & AA \mid \lambda x:A.A \mid \Pi x:A.A \\
%       & \mid & \mu x.A \mid \fold{A}{A} \mid \unfold[A]{A} \\
%       & \mid & \bet{A} \\
%       & \mid & \case \,A\,\of\,\{x\,x_{1}\,x_{2} \dots \Rightarrow A; \dots\}
%   \end{array}
% \]

% Suppose we have
% \begin{align*}
%   \case\,&x\,\of\,\{\\
%          &K_{1}\,x_{1}\dots x_{\mathsf{ar}(1)} \Rightarrow r_{1}\\
%          &\dots\\
%          &K_{n}\,x_{1}\dots x_{\mathsf{ar}(n)} \Rightarrow r_{n}\\
%          &\}
% \end{align*}
% where $x : D$ and $r_{1},\dots,r_{n} : T$ ($T$ is some known type).

% This can be translated to our system as follows:
% \begin{align*}
%   (\unfold[D]{x})\,T\,&(\lambda(x_{1}:T_{1}^{1}(D))\dots(x_{\mathsf{ar}(1)}:T_{\mathsf{ar}(1)}^{1}(D)).\,r_{1})\\
%                       &\dots\\
%                       &(\lambda(x_{1}:T_{1}^{n}(D))\dots(x_{\mathsf{ar}(n)}:T_{\mathsf{ar}(n)}^{n}(D)).\,r_{n})
% \end{align*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "pts"
%%% End:
