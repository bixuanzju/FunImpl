\newcommand{\Nat}{\mathsf{Nat}} \newcommand{\zero}{\mathsf{zero}}
\newcommand{\suc}{\mathsf{suc}} \newcommand{\plus}{\mathsf{plus}}
\newcommand{\List}{\mathsf{List}} \newcommand{\nil}{\mathsf{nil}}
\newcommand{\cons}{\mathsf{cons}}
\newcommand{\length}{\mathsf{length}}
\newcommand{\PlFunc}{\Nat\rightarrow\Nat\rightarrow\Nat}
\newcommand{\case}{\mathbf{case}} \newcommand{\of}{\mathbf{of}}
\newcommand{\data}{\mathbf{data}} \newcommand{\where}{\mathbf{where}}
\newcommand{\letbb}{\mathbf{let}} \newcommand{\inb}{\mathbf{in}}

\subsection{Extended Language}

We extend $\lambda C_{\mu}$ with simple datatypes and case
analysis~\cite{sulzmann2007system}, namely $\lambda C_{\mu c}$.
Differences with $\lambda C_{\mu}$ are highlighted in
Figure~\ref{fig:datasyn}.

\begin{figure}[H]
  \small
  \begin{syntax}
    \textbf{Declarations} \\
    pgm &::= & \hlmath{\overline{decl}; e} & \ptext{Declarations} \\
    decl &::= & \hlmath{\data\,D : \overline{\kappa} \rightarrow \star\,\where} & \ptext{Datatype} \\
    & & \quad \hlmath{\overline{K : \Pi\overline{x : \kappa}.\Pi\overline{y : \iota}.\overline{\tau} \rightarrow D\,\overline{x}}} \\ \\
    \textbf{Terms} \\
    u &::= & \hlmath{x \mid K} & \ptext{Variables and data constructors} \\
    e,\tau,\sigma,\kappa,\iota &::= & \hlmath{u} & \ptext{Term atoms} \\
    & \mid & \star & \ptext{Star} \\
    & \mid & \square & \ptext{Square} \\
    & \mid & e \ e & \ptext{Application} \\
    & \mid & \lam{x}{\tau}{e} & \ptext{Abstraction} \\
    & \mid & \pai{x}{\tau}{\tau} & \ptext{Product} \\
    & \mid & \miu{x}{\tau} & \ptext{Recursive type} \\
    & \mid & \fold{\tau}{e} & \ptext{Generalized roll} \\
    & \mid & \unfold{e} & \ptext{Generalized unroll} \\
    & \mid & \hlmath{\case\,e\,\of\,\overline{p \Rightarrow e}} & \ptext{Case analysis} \\
    p &::= & \hlmath{K\,\overline{y : \iota}\,\overline{x : \tau}} & \ptext{Pattern} \\ \\
    \textbf{Environments} \\
    \Gamma &::= &\varnothing & \ptext{Empty} \\
    & \mid & \hlmath{\Gamma,u:\tau} & \ptext{Variable binding}
  \end{syntax}
  \caption{Syntax of $\lambda C_{\mu c}$ ($e$ for terms; $\tau,\sigma$
    for types; $\kappa, \iota$ for kinds)}\label{fig:datasyn}
\end{figure}

An \emph{algebraic data type} $D$ is introduced as a top-level
\textbf{data} declaration with its \emph{data constructors}. The type
of a data constructor $K$ has the form:
\[
  K : \Pi\overline{x : \kappa}^{n}.\Pi\overline{y :
    \iota}.\overline{\tau} \rightarrow D\,\overline{x}^{n}
\]
The first $n$ quantified type variables $\overline{x}$ appear in the
same order in the return type $D\,\overline{x}$, and $\overline{y}$
stands for existentially quantified type variables. There is a $\case$
expression to take apart values built with data constructors. The
patterns of a case expression are flat (no nested patterns), and bind
existential type variables.

The extended typing rules are shown in Figure~\ref{fig:datatype}. To
save space, we only show the new typing rules.

\begin{figure}[ht]
  \centering \small
  \begin{tabular}{lcl}
    \framebox{$\Gamma \vdash pgm : \tau$} \\
    (Pgm) & \ruleIII{\overline{\Gamma_{0} \vdash decl : \Gamma_{d}}}{\Gamma = \Gamma_{0}, \overline{\Gamma_{d}}}{\ctx{e:\tau}}{\Gamma_{0} \vdash \overline{decl}; e : \tau} \\
    \framebox{$\Gamma \vdash decl : \Gamma^{\prime}$} \\
    (Data) & \ruleII{\Gamma \vdash \kappa : \square}{\overline{\Gamma, D:\kappa \vdash \tau:\star}}{\ctx{(\data\,D:\kappa\,\where\,\overline{K:\tau}): (D:\kappa, \overline{K:\tau})}} \\
    \framebox{$\Gamma \vdash e : \tau$} \\
    (Case) & \ruleII{\ctx{e_{1}:\sigma}}{\overline{\Gamma\vdash_{p} p \Rightarrow e_{2}:\sigma \rightarrow \tau}}{\Gamma\vdash\case\,e_{1}\,\of\,\overline{p \Rightarrow e_{2}}:\tau} \\
    \framebox{$\Gamma \vdash_{p} p \Rightarrow e : D \rightarrow \tau$} \\
    (Alt) & \ruleIII{K:\Pi\overline{a:\kappa}.\Pi\overline{y:\iota}.\overline{\sigma} \rightarrow D\,\overline{a} \in \Gamma}{\theta=[\overline{a := \upsilon}]}{\Gamma, \overline{y:\theta(\iota)},\overline{x:\theta(\sigma)} \vdash e:\tau}{\Gamma \vdash_{p} K\,\overline{y:\theta(\iota)}\,\overline{x:\theta(\sigma)} \Rightarrow e : D\,\overline{\upsilon} \rightarrow \tau}
  \end{tabular}
  \caption{Typing rules for $\lambda C_\mu c$}\label{fig:datatype}
\end{figure}

\subsection{Translation Overview}

We use a type-directed translation~\cite{middelkoop2010lean}. The
typing relations have the form:
\[
  \Gamma \vdash e : \tau \rightsquigarrow E
\]

It states that $\lambda C_{\mu}$ expression $E$ is the translation of
$\lambda C_{\mu c}$ expression $e$ of type
$\tau$. Figure~\ref{fig:datatrans} shows the translation rules, which
are the typing rules of the previous section extended with the
resulting expression $E$. In the translation, \emph{We require that
  applications of type functions $D$ to be saturated}.

\begin{figure}[ht!]
  \centering \small
  \begin{tabular}{lcl}
    \framebox{$\Gamma \vdash e : \tau \rightsquigarrow E$} \\
    (Ax) & \ruleI{}{\ctxz{\star:\square \rightsquigarrow \star}} \\

    (Var) & \ruleI{x:\tau \in \Gamma}{\ctx{x:\tau \rightsquigarrow x}} \\

    (App) & \ruleII{\ctx{e_{1}:(\pai{x}{\tau_{2}}{\tau_{1}}) \rightsquigarrow E_{1}}}{\ctx{e_{2}:\tau_{2} \rightsquigarrow E_{2}}}{\ctx{e_{1}e_{2}:\tau_{1}[x:=e_{2}] \rightsquigarrow E_{1}E_{2}}} \\

    (Lam) & \ruleII{\ctxw{x:\tau_{1}}{e:\tau_{2} \rightsquigarrow E}}{\ctx{(\pai{x}{\tau_{1}}{\tau_{2}}):t}}
            {\ctx{(\lam{x}{\tau_{1}}{e}}):(\pai{x}{\tau_{1}}{\tau_{2}}) \rightsquigarrow \lam{x}{\tau_{1}}{E}}
          & $t \in \{\star, \square\}$ \\

    (Pi) & \ruleII{\ctx{\tau_{1}:s}}{\ctxw{x:\tau_{1}}{\tau_{2}:t}}{\ctx{(\pai{x}{\tau_{1}}{\tau_{2}}):t \rightsquigarrow \pai{x}{\tau_{1}}{\tau_{2}}}}
          & $(s,t) \in \mathcal{R}$ \\

    (Mu) & \ruleI{\ctxw{x:s}{\tau:s}}{\ctx{(\miu{x}{\tau}):s \rightsquigarrow \miu{x}{\tau}}} \\

    (Fold) & \ruleIII{\ctx{e:\tau_{2} \rightsquigarrow E}}{\ctx{\tau_{1}:s}}{\tau_{1} \tolong \tau_{2}}%
             {\ctx{(\fold{{\tau_{1}}}{e}):{\tau_{1}} \rightsquigarrow \fold{\tau_{1}}{E}}} \\

    (Unfold) & \ruleIII{\ctx{e:\tau_{1} \rightsquigarrow E}}{\ctx{\tau_{2}:s}}{\tau_{1} \tolong \tau_{2}}%
               {\ctx{(\unfold{e}):\tau_{2} \rightsquigarrow \unfold{E}}} \\

    (Case) & \ruleII{\ctx{e_{1}:\sigma \rightsquigarrow E_{1}}}{\overline{\Gamma\vdash_{p} p \Rightarrow e_{2}:\sigma \rightarrow \tau \rightsquigarrow E_{2}}}{\Gamma\vdash\case\,e_{1}\,\of\,\overline{p \Rightarrow e_{2}}:\tau \rightsquigarrow (\unfold{E_{1}})\,\tau\,\overline{E_{2}}}\\
    \framebox{$\Gamma \vdash_{p} p \Rightarrow e : D \rightarrow \tau \rightsquigarrow E$} \\
    (Alt) & \AxiomC{$K:\Pi\overline{a:\kappa}.\Pi\overline{y:\iota}.\overline{\sigma} \rightarrow D\,\overline{a} \in \Gamma$} \alwaysNoLine \AxiomC{$\theta=[\overline{a := \upsilon}]$} \UnaryInfC{$\Gamma, \overline{y:\theta(\iota)},\overline{x:\theta(\sigma)} \vdash e:\tau \rightsquigarrow E$} \alwaysSingleLine \BinaryInfC{$\Gamma \vdash_{p} K\,\overline{y:\theta(\iota)}\,\overline{x:\theta(\sigma)} \Rightarrow e : D\,\overline{\upsilon} \rightarrow \tau \rightsquigarrow \lambda(\overline{y:\theta(\iota)})(\overline{x:\theta(\sigma)}).E$} \DisplayProof \\
    \framebox{$\Gamma \vdash decl : \Gamma' \rightsquigarrow E$} \\
    (Data) & \ruleII{\Gamma \vdash \overline{\kappa} \rightarrow \star : \square}{\overline{\Gamma, D:\overline{\kappa} \rightarrow \star \vdash \sigma:\star}}{\ctx{(\data\,D:\overline{\kappa} \rightarrow \star\,\where\,\overline{K:\sigma}): (D:\overline{\kappa} \rightarrow \star, \overline{K:\sigma})} \rightsquigarrow E} \\
         & \begingroup \renewcommand*{\arraystretch}{1.0} $\begin{array} {lll}
                                                             \\ \sigma & ::= & \Pi\overline{a:\kappa}.\Pi\overline{y:\iota}.\overline{\tau} \rightarrow D\,\overline{a} \\
                                                             E & ::= & \letbb\,D : \overline{\kappa} \rightarrow \star =\Pi\overline{a : \kappa}. \mu X. \Pi b:\star. \\
& & \quad \overline{(\Pi\overline{y:\iota}.\tau[D\,\overline{a}:=X] \rightarrow b)} \rightarrow b\,\inb \\ & & \letbb\,K_{i}^{i \in 1..n} : \sigma = \lambda \overline{(a : \kappa)}.\lambda\overline{(y : \iota)}.\lambda\overline{(x : \tau)}.\\
                                                                    & & \quad \fold{D\,\overline{a}}{(\lambda (b : \star)\overline{(c : \Pi\overline{y:\iota}.\overline{\tau} \rightarrow b)} . c_{i}\,\overline{y}\,\overline{x})}\,\inb \end{array}$ \endgroup \\
    \framebox{$\Gamma \vdash pgm : \tau \rightsquigarrow E$} \\
    (Pgm) & \ruleIII{\overline{\Gamma_{0} \vdash decl : \Gamma_{d} \rightsquigarrow E_{1}}}{\Gamma = \Gamma_{0}, \overline{\Gamma_{d}}}{\ctx{e:\tau \rightsquigarrow E}}{\Gamma_{0} \vdash \overline{decl}; e : A \rightsquigarrow \overline{E_{1}} \oplus E}
  \end{tabular}
  \caption{Type-directed translation from $\lambda C_\mu c$ to
    $\lambda C_\mu$}\label{fig:datatrans}
\end{figure}


\subsection{Examples of Simple Datatypes}

\begin{itemize}

\item Encoding of natural numbers
  \begin{align*}
    \data\,&\Nat : \star\,\where \\
           &\zero : \Nat \\
           &\suc : \Nat \rightarrow \Nat
  \end{align*}
  $\Nat,\zero$ and $\suc$ are encoded as follows:
  \begin{align*}
    \letbb\,&\Nat : \star = \miu{X}{\pai{b}{\star}{b \rightarrow (X \rightarrow b) \rightarrow b}}\,\inb \\
    \letbb\,&\zero : \Nat = \fold{\Nat}{(\lambda (b : \star) (z : b) (f : \Nat \rightarrow b).\,z)}\,\inb \\
    \letbb\,&\suc : \Nat \rightarrow \Nat = \lambda (n : \Nat).\,\fold{\Nat}{(\lambda (b : \star) (z : b) (f : \Nat \rightarrow b).\,f\,n)}\,\inb \\
  \end{align*}
\item Encoding of polymorphic lists
  \begin{align*}
    \data\,&\List : \star \rightarrow \star\,\where \\
           &\nil : \pai{a}{\star}{\List\,a} \\
           &\cons : \pai{a}{\star}{a \rightarrow \List\,a \rightarrow \List\,a}
  \end{align*}
  $\List,\nil$ and $\cons$ are encoded as follows:
  \begin{align*}
    \letbb\,&\List : \star \rightarrow \star = \pai{a}{\star}{\miu{X}{\pai{b}{\star}{b \rightarrow (a \rightarrow X \rightarrow b) \rightarrow b}}}\,\inb \\
    \letbb\,&\nil : \pai{a}{\star}{\List\,a} = \lambda a : \star.\\
            &\fold{\List\,a}{(\lambda (b : \star) (z : b) (f : a \rightarrow \List\,a \rightarrow b).\ z)}\,\inb \\
    \letbb\,&\cons : \pai{a}{\star}{a \rightarrow \List\,a \rightarrow \List\,a} = \lambda(a:\star)(x : a)(xs : \List\,a).\\
            &\qquad \fold{\List\,a}{(\lambda(b : \star)(z : b)(f : a \rightarrow \List\,a \rightarrow b).\,f\,x\,xs)}\,\inb
  \end{align*}
  Using $\mathsf{fix}$, we can define a recursive function $\length$
  as follows:
  \begin{align*}
    \length &: \pai{a}{\star}{\List\,a \rightarrow \Nat} \\
    \length &= \mathsf{fix}\,(\pai{a}{\star}{\List\,a \rightarrow \Nat})\,(\lambda(f : \pai{a}{\star}{\List\,a \rightarrow \Nat})(a:\star)(l : \List\,a).\\
            &(\unfold[\List\,a]{l})\,\Nat\,\zero\,(\lambda(x : a)(xs : \List\,a).\,\suc\,(f\,a\,xs)))
  \end{align*}
\item Encoding of a datatype with existential types
  \begin{align*}
    \data\,&D : \star \rightarrow \star\,\where \\
           &K : \pai{a}{\star}{\pai{b}{\star}{a \rightarrow b \rightarrow (b \rightarrow \Nat)} \rightarrow D\,a}
  \end{align*}
  $D$ and $K$ are encoded as follows:
  \begin{align*}
    \letbb\,&D:\star \rightarrow \star = \pai{a}{\star}\miu{X}{\pai{\beta}{\star}{(\pai{b}{\star}{a \rightarrow b \rightarrow (b \rightarrow \Nat) \rightarrow \beta}) \rightarrow \beta}}\,\inb \\
    \letbb\,&K:\pai{a}{\star}{\pai{b}{\star}{a \rightarrow b \rightarrow (b \rightarrow \Nat)} \rightarrow D\,a} = \\
            &\lambda (a:\star)(b:\star)(x:a)(y:b)(f:b \rightarrow \Nat).\\
            &\fold{D\,a}{(\lambda (\beta : \star)(g: \pai{b}{\star}{a \rightarrow b \rightarrow (b \rightarrow \Nat) \rightarrow \beta}).g\,b\,x\,y\,f)}\,\inb
  \end{align*}
\end{itemize}

% \subsubsection{Elaboration of Datatypes}

% We can extend $\lambda C_{\mu}$ with \emph{first-order}
% datatypes~\cite{geuvers2014church}:
% \[
%   \mathbf{data} \quad D = K_{1}\,T_{1}^{1}(D) \dots
%   T_{\mathsf{ar}(1)}^{1}(D) \mid \cdots \mid K_{n}\,T_{1}^{n}(D)
%   \dots T_{\mathsf{ar}(n)}^{n}(D)
% \]
% where each of the $T_{i}^{j}(X)$ is either $X$ or a type expression
% that does not contain $X$. This defines an algebraic datatype $D$
% with $n$ constructors. Each constructor $K_{i}$ has arity
% $\mathsf{ar}(i)$, which can be zero.

% We adopt the following convention: we write $T^{1}(X)$ for
% $T_{1}^{1}(X) \dots T_{\mathsf{ar}(1)}^{1}(X)$ etc. So each data
% constructor has the following types:
% \begingroup
% \renewcommand*{\arraystretch}{1.0}
% \begin{table}[h]
%   \centering
%   \begin{tabular}{lll}
%     $K_{1}$ &:& $T^{1}(D) \rightarrow D$ \\
%             && \dots \\
%     $K_{n}$ &:& $T^{n}(D) \rightarrow D$
%   \end{tabular}
% \end{table}
% \endgroup

% Next we show how datatypes can be translated to our system with
% recursive types.

% Given a datatype $D$, with constructors $K_{1},\dots,K_{n}$, the
% encoding of $D$ in our system is given by:
% \[
%   D ::= \mu \beta.\,\Pi(\alpha : \star).\,(T^{1}(\beta) \rightarrow
%   \alpha) \rightarrow \dots \rightarrow (T^{n}(\beta) \rightarrow
%   \alpha) \rightarrow \alpha
% \]

% The constructors are encoded by:
% \begin{align*}
%   K_{i} &::= \lambda(x_{1}:T_{1}^{i}(D))\dots(x_{\mathsf{ar}(i)}:T_{\mathsf{ar}(i)}^{i}(D)).\\
%         &\quad \fold{D}{(\lambda(\alpha:\star)(c_{1}:T^{1}(D) \rightarrow \alpha)\dots(c_{n}:T^{n}(D) \rightarrow \alpha).\,c_{i}\,x_{1} \dots x_{\mathsf{ar}(i)})}
% \end{align*}

% \subsubsection{Elaboration of Case Analysis}

% The set of expressions $A$ of $\lambda C_{\mu}$ extended with case
% analysis is defined by
% \[
%   \renewcommand*{\arraystretch}{1.0}%
%   \begin{array}{lcl}
%     A &::= & x \mid \star \mid \square \\
%       & \mid & AA \mid \lambda x:A.A \mid \Pi x:A.A \\
%       & \mid & \mu x.A \mid \fold{A}{A} \mid \unfold[A]{A} \\
%       & \mid & \bet{A} \\
%       & \mid & \case \,A\,\of\,\{x\,x_{1}\,x_{2} \dots \Rightarrow A; \dots\}
%   \end{array}
% \]

% Suppose we have
% \begin{align*}
%   \case\,&x\,\of\,\{\\
%          &K_{1}\,x_{1}\dots x_{\mathsf{ar}(1)} \Rightarrow r_{1}\\
%          &\dots\\
%          &K_{n}\,x_{1}\dots x_{\mathsf{ar}(n)} \Rightarrow r_{n}\\
%          &\}
% \end{align*}
% where $x : D$ and $r_{1},\dots,r_{n} : T$ ($T$ is some known type).

% This can be translated to our system as follows:
% \begin{align*}
%   (\unfold[D]{x})\,T\,&(\lambda(x_{1}:T_{1}^{1}(D))\dots(x_{\mathsf{ar}(1)}:T_{\mathsf{ar}(1)}^{1}(D)).\,r_{1})\\
%                       &\dots\\
%                       &(\lambda(x_{1}:T_{1}^{n}(D))\dots(x_{\mathsf{ar}(n)}:T_{\mathsf{ar}(n)}^{n}(D)).\,r_{n})
% \end{align*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "pts"
%%% End:
