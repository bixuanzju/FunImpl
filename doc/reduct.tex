Since recursive types are introduced and due to the practical concern, we use the \emph{call-by-name} reduction strategy, i.e. iteratively reducing the \emph{left-most} \emph{outer-most} redex. Figure~\ref{fig:mueval} shows the dynamic semantics with no call-by-value specific premises or rules.

\begin{figure}[H]
  \centering
  \small
  \begin{syntax}
  \textbf{values:}\quad v &::= & \lam{x}{A}{B} & \ptext{abstraction} \\
    & \mid & \pai{x}{A}{B} & \ptext{product} \\
    & \mid & \hlmath{\fold{\miu{x}{A}}{B}} & \ptext{roll}
\end{syntax}
  \begin{tabular}{lcl}
    (R-AppLam) & \ruleI{}{(\lam{x}{A}{M})N \tolong M[x:=N]} \\
    (R-AppL) & \ruleI{M \tolong M'}{MN \tolong M'N} \\
    (R-Unfold) & \hl{\ruleI{M \tolong M'}{\unfold{M} \tolong \unfold{M'}}} \\
    (R-Unfold-Fold) & \hl{\ruleI{}{\unfold{(\fold{\miu{x}{A}}{M})} \tolong M}} \\
    (R-Mu) & \hl{\ruleI{}{\miu{x}{M} \tolong M[x:=\miu{x}{M}]}} \\
    (R-Beta) & \hl{\ruleI{}{\bet{M} \tolong M}}
  \end{tabular}
\caption{Reduction rules for $\lambda C$}\label{fig:mueval}
\end{figure}
