% Article template
\documentclass[oneside,a4paper]{article}

% Set margins
\usepackage[top=1in,bottom=1in,left=1.25in,right=1.25in]{geometry}

% Font settings
\usepackage{times}
\usepackage{url}
\urlstyle{rm}

% AMS support
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

% Logic proof support
\usepackage{bussproofs}

% Language support
\usepackage{csquotes}
\usepackage[english]{babel}
\MakeOuterQuote{"}
\usepackage{indentfirst}

% Reference settings
\usepackage{hyperref}
\hypersetup{
   colorlinks,
   citecolor=black,
   filecolor=black,
   linkcolor=black,
   urlcolor=black
}

% Caption format
\usepackage{titlesec}
\titleformat{\section}{\normalfont\large\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\normalfont\normalsize\bfseries}{\thesubsection}{0.5em}{}
\usepackage[font=small,labelfont=bf]{caption}
\DeclareCaptionLabelSeparator{colon}{.~}
\numberwithin{equation}{section}

% No indentation before paragraph
\usepackage{parskip}

% Line spacing
\usepackage{setspace}
\onehalfspacing

% List support
\usepackage{paralist}

% Table support
\usepackage{booktabs}
\renewcommand{\arraystretch}{2.5}

% Graphics support
\usepackage{graphicx}
\usepackage{float}

% Citation support
\usepackage[numbers]{natbib}

% Title
\title{\bf Formalization of Pure Type System}
\author{}
\date{}

% Text
\begin{document}
\maketitle

\section{Definition}
\begin{enumerate}[(i)]
\item A \emph{pure type system} (\emph{PTS}) is a triple tuple
  $(\mathcal{S},\mathcal{A},\mathcal{R})$ where

  \begin{enumerate}
  \item $\mathcal{S}$ is a set of \emph{sorts};
  \item $\mathcal{A}\subseteq \mathcal{S} \times \mathcal{S}$ is a set
    of \emph{axioms};
  \item
    $\mathcal{R}\subseteq \mathcal{S} \times \mathcal{S} \times
    \mathcal{S}$ is a set of \emph{rules}.
  \end{enumerate}

\item \emph{Raw expressions} $A$ and \emph{raw environments} $\Gamma$
  are defined by
  \begin{align*}
    A &::= x \mid s \mid AA \mid \lambda x:A.\ A \mid \Pi x:A.\ A\\
    \Gamma &::= \varnothing \mid \Gamma,x:A
  \end{align*}
  where we use $s,t,u$, etc., to range over sorts, $x,y,z$, etc., to
  range over variables, and $A,B,C,a,b,c$, etc., to range over
  expressions.

\item $\Pi$ and $\lambda$ are used to bind variables. Let
  $\mathrm{FV}(A)$ denote free variable set of $A$. Let $A[x:=B]$
  denote the substitution of $x$ in $A$ with $B$. Standard notational
  conventions are applied here. Besides we also let $A \to B$ be an
  abbreviation for $(\Pi \_:A.\ B)$.

\item The relation $\to _ \beta$ is the smallest binary relation on
  raw expressions satisfying
  \[ (\lambda x:A.\ M)N \to _ \beta M[x:=N] \]
  which can be used to define the notation $\twoheadrightarrow_\beta$
  and $=_\beta$ by convention.

\item Type assignment rules for
  $(\mathcal{S},\mathcal{A},\mathcal{R})$ are given in
  Table~\ref{fig:rules}. Particularly, the rule \emph{(Conv)} is
  needed to make everything work.

\begin{table}[h]
  \centering
  \small
  \begin{tabular}{lcl}
    (Ax) &
           \AxiomC{}
           \UnaryInfC{$\vdash s:t$}
           \DisplayProof &
                           $(s,t) \in \mathcal{A}$ \\

    (Var) &
            \AxiomC{$\Gamma \vdash A:s$}
            \UnaryInfC{$\Gamma,x:A \vdash x:A$}
            \DisplayProof &
                            $x \not \in \mathrm{dom}(\Gamma)$ \\

    (Weak) &
             \AxiomC{$\Gamma \vdash b:B$}
             \AxiomC{$\Gamma \vdash A:s$}
             \BinaryInfC{$\Gamma,x:A \vdash b:B$}
             \DisplayProof &
                             $x \not \in \mathrm{dom}(\Gamma)$ \\

    (App) &
            \AxiomC{$\Gamma \vdash f:(\Pi x:A.\ B)$}
            \AxiomC{$\Gamma \vdash a:A$}
            \BinaryInfC{$\Gamma \vdash fa:B[x:=a]$}
            \DisplayProof \\

    (Lam) &
            \AxiomC{$\Gamma,x:A \vdash b:B$}
            \AxiomC{$\Gamma \vdash (\Pi x:A.\ B):t$}
            \BinaryInfC{$\Gamma \vdash (\lambda x:A.\ b):(\Pi x:A.\ B)$}
            \DisplayProof \\

    (Pi) &
           \AxiomC{$\Gamma \vdash A:s$}
           \AxiomC{$\Gamma,x:A \vdash B:t$}
           \BinaryInfC{$\Gamma \vdash (\Pi x:A.\ B):u$}
           \DisplayProof &
                           $(s,t,u) \in \mathcal{R}$ \\

    (Conv) &
             \AxiomC{$\Gamma \vdash a:A$}
             \AxiomC{$\Gamma \vdash B:s$}
             \AxiomC{$A=_\beta B$}
             \TrinaryInfC{$\Gamma \vdash a:B$}
             \DisplayProof

  \end{tabular}
  \caption{Typing rules for pure type system}\label{fig:rules}
\end{table}

\end{enumerate}

\section{Examples of PTSs}

\begin{enumerate}[(i)]

\item The $\lambda$-cube (Table~\ref{tab:lambda}) consists of eight
  PTSs, where

  \begin{enumerate}
  \item $\mathcal{S} = \{\star,\square\}$
  \item $\mathcal{A} = \{(\star, \square)\}$
  \item
    $\{(\star, \star)\} \subseteq \mathcal{R} \subseteq \{(\star,
    \star), (\star, \square), (\square, \star), (\square, \square)\}$
  \end{enumerate}


\begingroup
\renewcommand*{\arraystretch}{1.5}
\begin{table}[h!]
  \centering
  \begin{tabular}{|l|llll|}
    \hline
    System & \multicolumn{4}{|c|}{Set of Rules $\mathcal{R}$} \\ \hline
    $\lambda_{\rightarrow}$ & $(\star, \star)$ & & & \\
    $\lambda2$ & $(\star, \star)$ & $(\square, \star)$ & & \\ 
    $\lambda\underbar{$\omega$}$ & $(\star, \star)$ & &  $(\square, \square)$ & \\ 
    $\lambda\omega$ & $(\star, \star)$ & $(\square, \star)$ & $(\square, \square)$ & \\ 
    $\lambda$P & $(\star, \star)$ & & & $(\star, \square)$ \\ 
    $\lambda$P2 & $(\star, \star)$ & $(\square, \star)$ & & $(\star, \square)$ \\ 
    $\lambda$P$\underbar{$\omega$}$ & $(\star, \star)$ & & $(\square, \square)$ & $(\star, \square)$ \\ 
    $\lambda$C & $(\star, \star)$ & $(\square, \star)$ & $(\square, \square)$ & $(\star, \square)$ \\ \hline
  \end{tabular}
  \caption{The systems of the $\lambda$-cube}
  \label{tab:lambda}
\end{table}
\endgroup

Note that here we slightly abuse the notation of the set of rules
$\mathcal{R}$, since in PTSs, $\mathcal{R}$ is a ternary relation,
while in the $\lambda$-cube, $\mathcal{R}$ is a binary relation
($\Pi x: A.\ B$ has the same sorts as $B$).


\item An extension of $\lambda\omega$ that supports ``polymorphic
  identity function on types'', where

  \begin{enumerate}
  \item $\mathcal{S} = \{\star,\square, \square^{\prime}\}$
  \item
    $\mathcal{A} = \{(\star, \square), (\square, \square^{\prime})\}$
  \item
    $\mathcal{R} = \{(\star, \star), (\square, \star), (\square,
    \square), (\square^{\prime}, \square^{\prime})\}$
  \end{enumerate}

  in which we can have
  $\vdash (\lambda \kappa : \square.\ \lambda \alpha : \kappa.\ \alpha) :
  (\Pi \kappa : \square .\ \kappa \rightarrow \kappa)$,
  justified as follows:

\begin{prooftree}
  \AxiomC{$\mathcal{B}$} \RightLabel{\emph{Var}}
  \UnaryInfC{$\kappa : \square, \alpha : \kappa \vdash \alpha :
    \kappa$}
  \AxiomC{$\mathcal{A}$} \RightLabel{\emph{Lam}}
  \BinaryInfC{$\kappa : \square \vdash (\lambda \alpha :
    \kappa.\ \alpha) : (\Pi \alpha : \kappa.\ \kappa)$}
  \AxiomC{} \RightLabel{\emph{Ax}}
  \UnaryInfC{$\vdash \square : \square^{\prime}$}
  \AxiomC{$\mathcal{A}$} \RightLabel{\emph{Pi}}
  \BinaryInfC{$\vdash (\Pi \kappa : \square .\ \Pi \alpha :
    \kappa.\ \kappa) : \square$}
  \RightLabel{\emph{Lam}}
  \BinaryInfC{$\vdash (\lambda \kappa : \square.\ \lambda \alpha :
    \kappa.\ \alpha) : (\Pi \kappa : \square .\ \Pi \alpha :
    \kappa.\ \kappa)$}
\end{prooftree}

\begin{table}[H]
  \centering
  \begin{tabular}{ll}
    $\mathcal{A}=$ &
                     \AxiomC{$\mathcal{B}$}
                     \AxiomC{$\mathcal{B}$}
                     \AxiomC{$\mathcal{B}$}
                     \RightLabel{\emph{Weak}}
                     \BinaryInfC{$\kappa : \square , \alpha : \kappa \vdash \kappa : \square$}
                     \RightLabel{\emph{Pi}}
                     \BinaryInfC{$\kappa : \square \vdash (\Pi \alpha : \kappa.\ \kappa) : \square$} 
                     \DisplayProof \\
    $\mathcal{B}=$ & 
                     \AxiomC{}
                     \RightLabel{\emph{Ax}}
                     \UnaryInfC{$\vdash \square : \square^{\prime}$}
                     \RightLabel{\emph{Var}}
                     \UnaryInfC{$\kappa : \square \vdash \kappa : \square$}
                     \DisplayProof
  \end{tabular}
\end{table}

\end{enumerate}

\section{Extending PTSs }

This section investigates how to extend PTSs to have algebraic
datatypes, case expressions, etc.

\subsection{Algebraic Datatypes}

An algebraic datatype has the form:
\[
T \ u_{1} \dots u_{k} = K_{1} \ t_{11} \dots t_{1k_{1}} \ | \cdots |
K_{n} \ t_{n1} \dots t_{nk_{n}}
\]
where $T$ denotes a new \emph{type constructor} with zero or more
constituent \emph{data constructors} $K_{1}, \dots, K_{n}$. We call
$u_{1}, \dots, u_{k}$ the arguments of the type constructor $T$, and
$t_{j1}, \dots, t_{jk_{j}}$ the types of the arguments of the
$K_{j} (1 \leqslant j \leqslant n)$ data constructor. Each $u_{i}$ is
a variable of \emph{sort type}, each $t_{jk}$ is an expression of
\emph{kind type} (i.e., $t_{jk} : \star$), which may contain $T$ and
$u_{1}, \dots, u_{k}$ as free variables.

We use the following notation:
$\vec{\mathbf{u}} = [u_{1}, \dots, u_{k}]$,
$\vec{\mathbf{t_{j}}} = [t_{j1}, \dots t_{jk_{j}}]$, etc. If
$\vec{\mathbf{a}} = [a_{1}, \dots, a_{n}]$ and
$\vec{\mathbf{A}} = [A_{1}, \dots, A_{n}]$, then
$\Pi \vec{\mathbf{a}} : \vec{\mathbf{A}}.\ B$ denotes
$\Pi a_{1}:A_{1} \dots \Pi a_{n}:A_{n}.\ B$. Let
$\tau_{1},\dots,\tau_{k}$ be the types of $u_{1}, \dots, u_{k}$,
respectively.

A PTS with ADTs is a tuple $(P, ADTS)$ where:

\begin{enumerate}[(i)]
\item $P$ is a Pure Type System, let $V$, $E$ be the sets of variables
  and expressions of $P$.
\item $ADTS$ is a set of ADTs, each consisting of
  $[T : T^{\prime}, K_{1} : K_{1}^{\prime}, \dots, K_{n}^{\prime}]$
  such that:
  \begin{itemize}
  \item $T, K_{j} \in V$ and $T^{\prime}, K_{j}^{\prime} \in E$, for
    every $1 \leqslant j \leqslant n$
  \item
    $T^{\prime} = \Pi \vec{\mathbf{u}} : \vec{\mathbf{\tau}}.\ \star$
  \item
    $K_{j}^{\prime} = \Pi \vec{\mathbf{u}} : \vec{\mathbf{\tau}}.\ \Pi
    \vec{\mathbf{\alpha}}: \vec{\mathbf{t_{j}}}.\ (T\
    \vec{\mathbf{u}}) $, for every $1 \leqslant j \leqslant n$
  \item $T : T^{\prime} \vdash K_{j} : K_{j}^{\prime} : \star$
  \end{itemize}
  Note that the use of the dependent product ($\Pi$) makes it possible
  to let the types of the data constructor arguments depend on other
  data constructor arguments.
\item (\textbf{Typability in a PTS with ADTs}) let
  $\Sigma = [c : ct \mid c : ct \leftarrow ADT, ADT \leftarrow ADTS]$,
  we say that $\Gamma \vdash_{(P,ADTS)} a : A$ if and only if
  $\Sigma \biguplus \Gamma \vdash a : A$
\end{enumerate}

\subsubsection{An Example of a PTS with ADTs}

Let $P = \lambda C$ and
\begin{align*}
  \Sigma_{a} = [&Int : \star, Zero : Int, Suc : Int \rightarrow Int,\\
               &Bool : \star, True : Bool, False : Bool]\\
  \Sigma_{b} = [&Vec : (\Pi n : Int.\ \Pi \alpha : \star.\ \star),\\
                &Nil : (\Pi \alpha : \star.\ Vec\ Zero\ \alpha),\\
                &Cons : (\Pi n : Int.\ \Pi \alpha : \star.\ \alpha \rightarrow Vec\ n\ \alpha \rightarrow Vec\ (Suc\ n)\ \alpha)]\\
  ADTS = [&\Sigma_{a}, \Sigma_{b}]
\end{align*}
then we can derive $\vdash_{(P, ADTS)}$ Cons Zero Bool True (Nil Bool) : Vec (Suc Zero) Bool



% References
\nocite{*} \bibliographystyle{plainnat} \bibliography{pts}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
