% Article template
\documentclass[oneside,a4paper]{article}

% Set margins
\usepackage[top=1in,bottom=1in,left=1.25in,right=1.25in]{geometry}

% Font settings
\usepackage{times}
\usepackage{url}
\urlstyle{rm}

% AMS support
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

% Logic proof support
\usepackage{bussproofs}

% Language support
\usepackage{csquotes}
\usepackage[english]{babel}
\MakeOuterQuote{"}
\usepackage{indentfirst}

% Reference settings
\usepackage{hyperref}
\hypersetup{
   colorlinks,
   citecolor=black,
   filecolor=black,
   linkcolor=black,
   urlcolor=black
}

% Caption format
\usepackage{titlesec}
\titleformat{\section}{\normalfont\large\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\normalfont\normalsize\bfseries}{\thesubsection}{0.5em}{}
\usepackage[font=small,labelfont=bf]{caption}
\DeclareCaptionLabelSeparator{colon}{.~}
\numberwithin{equation}{section}

% No indentation before paragraph
\usepackage{parskip}

% Line spacing
\usepackage{setspace}
\onehalfspacing

% List support
\usepackage{paralist}

% Table support
\usepackage{booktabs}
\renewcommand{\arraystretch}{2.5}

% Graphics support
\usepackage{graphicx}
\usepackage{float}

% Citation support
\usepackage[numbers]{natbib}

% Comment block
\usepackage{comment}

% Date & time
\usepackage[us,12hr]{date time}

% Custom commands
\newcommand{\fold}[2]{\mathsf{fold}[#1]\,#2}
\newcommand{\unfold}[2]{\mathsf{unfold}[#1]\,#2}
\newcommand{\betaa}[1]{\mathsf{beta}\,#1}

% Title
\title{\bf Formalization of Pure Type Systems}
\author{}
\date{\small \it Last modified: \today\ at \currenttime}

% Text
\begin{document}
\maketitle

\section{Definition}
\begin{enumerate}[(i)]
\item A \emph{pure type system} (\emph{PTS}) is a triple tuple
  $(\mathcal{S},\mathcal{A},\mathcal{R})$ where

  \begin{enumerate}
  \item $\mathcal{S}$ is a set of \emph{sorts};
  \item $\mathcal{A}\subseteq \mathcal{S} \times \mathcal{S}$ is a set
    of \emph{axioms};
  \item
    $\mathcal{R}\subseteq \mathcal{S} \times \mathcal{S} \times
    \mathcal{S}$ is a set of \emph{rules}.
  \end{enumerate}

Following standard practice, we use $(s_{1}, s_{2})$ to denote rules
of the form $(s_{1}, s_{2}, s_{2})$.

\item \emph{Raw expressions} $A$ and \emph{raw environments} $\Gamma$
  are defined by
  \begin{align*}
    A &::= x \mid s \mid AA \mid \lambda x:A.\ A \mid \Pi x:A.\ A\\
    \Gamma &::= \varnothing \mid \Gamma,x:A
  \end{align*}
  where we use $s,t,u$, etc., to range over sorts, $x,y,z$, etc., to
  range over variables, and $A,B,C,a,b,c$, etc., to range over
  expressions.

\item $\Pi$ and $\lambda$ are used to bind variables. Let
  $\mathrm{FV}(A)$ denote free variable set of $A$. Let $A[x:=B]$
  denote the substitution of $x$ in $A$ with $B$. Standard notational
  conventions are applied here. Besides we also let $A \to B$ be an
  abbreviation for $(\Pi \_:A.\ B)$.

\item The relation $\to _ \beta$ is the smallest binary relation on
  raw expressions satisfying
  \[ (\lambda x:A.\ M)N \to _ \beta M[x:=N] \]
  which can be used to define the notation $\twoheadrightarrow_\beta$
  and $=_\beta$ by convention.

\item Type assignment rules for
  $(\mathcal{S},\mathcal{A},\mathcal{R})$ are given in
  Table~\ref{tab:rules}. Particularly, the rule \emph{(Conv)} is
  needed to make everything work.

\end{enumerate}

\section{Examples of PTSs}\label{sec:example}

\begin{enumerate}[(i)]

\begin{comment}
\item The $\lambda$-cube (Table~\ref{tab:lambda}) consists of eight
  PTSs, where

  \begin{enumerate}
  \item $\mathcal{S} = \{\star,\square\}$
  \item $\mathcal{A} = \{(\star, \square)\}$
  \item
    $\{(\star, \star)\} \subseteq \mathcal{R} \subseteq \{(\star,
    \star), (\star, \square), (\square, \star), (\square, \square)\}$
  \end{enumerate}


\begingroup
\renewcommand*{\arraystretch}{1.5}
\begin{table}[h!]
  \centering
  \begin{tabular}{|l|llll|}
    \hline
    System & \multicolumn{4}{|c|}{Set of Rules $\mathcal{R}$} \\ \hline
    $\lambda_{\rightarrow}$ & $(\star, \star)$ & & & \\
    $\lambda2$ & $(\star, \star)$ & $(\square, \star)$ & & \\ 
    $\lambda\underbar{$\omega$}$ & $(\star, \star)$ & &  $(\square, \square)$ & \\ 
    $\lambda\omega$ & $(\star, \star)$ & $(\square, \star)$ & $(\square, \square)$ & \\ 
    $\lambda$P & $(\star, \star)$ & & & $(\star, \square)$ \\ 
    $\lambda$P2 & $(\star, \star)$ & $(\square, \star)$ & & $(\star, \square)$ \\ 
    $\lambda$P$\underbar{$\omega$}$ & $(\star, \star)$ & & $(\square, \square)$ & $(\star, \square)$ \\ 
    $\lambda$C & $(\star, \star)$ & $(\square, \star)$ & $(\square, \square)$ & $(\star, \square)$ \\ \hline
  \end{tabular}
  \caption{The systems of the $\lambda$-cube}
  \label{tab:lambda}
\end{table}
\endgroup

Note that here we slightly abuse the notation of the set of rules
$\mathcal{R}$, since in PTSs, $\mathcal{R}$ is a ternary relation,
while in the $\lambda$-cube, $\mathcal{R}$ is a binary relation
($\Pi x: A.\ B$ has the same sorts as $B$).
\end{comment}

\item Here we present the formal definition of a type
  system called \emph{the calculus of construction ($\lambda C$)},
  where

  \begin{enumerate}
  \item $\mathcal{S} = \{\star,\square\}$
  \item $\mathcal{A} = \{(\star, \square)\}$
  \item
    $\mathcal{R} = \{(\star, \star), (\star, \square), (\square,
    \star), (\square, \square)\}$
  \end{enumerate}

and the typing relation is shown in Table~\ref{tab:coc}.

\begin{table}[h]
  \centering
  \small
  \begin{tabular}{lcl}
    (Ax) &
           \AxiomC{}
           \UnaryInfC{$\vdash \star:\square$}
           \DisplayProof \\

    (Var) &
            \AxiomC{$\Gamma \vdash A:s$}
            \UnaryInfC{$\Gamma,x:A \vdash x:A$}
            \DisplayProof &
                            $x \not \in \mathrm{dom}(\Gamma)$ \\

    (Weak) &
             \AxiomC{$\Gamma \vdash b:B$}
             \AxiomC{$\Gamma \vdash A:s$}
             \BinaryInfC{$\Gamma,x:A \vdash b:B$}
             \DisplayProof &
                             $x \not \in \mathrm{dom}(\Gamma)$ \\

    (App) &
            \AxiomC{$\Gamma \vdash f:(\Pi x:A.\ B)$}
            \AxiomC{$\Gamma \vdash a:A$}
            \BinaryInfC{$\Gamma \vdash fa:B[x:=a]$}
            \DisplayProof \\

    (Lam) &
            \AxiomC{$\Gamma,x:A \vdash b:B$}
            \AxiomC{$\Gamma \vdash (\Pi x:A.\ B):t$}
            \BinaryInfC{$\Gamma \vdash (\lambda x:A.\ b):(\Pi x:A.\ B)$}
            \DisplayProof &
                             $t \in \{\star, \square\}$ \\

    (Pi) &
           \AxiomC{$\Gamma \vdash A:s$}
           \AxiomC{$\Gamma,x:A \vdash B:t$}
           \BinaryInfC{$\Gamma \vdash (\Pi x:A.\ B):t$}
           \DisplayProof &
                           $(s,t) \in \mathcal{R}$ \\

    (Conv) &
             \AxiomC{$\Gamma \vdash a:A$}
             \AxiomC{$\Gamma \vdash B:s$}
             \AxiomC{$A=_\beta B$}
             \TrinaryInfC{$\Gamma \vdash a:B$}
             \DisplayProof

  \end{tabular}
  \caption{Typing rules for $\lambda C$}\label{tab:coc}
\end{table}

\item An extension of $\lambda\omega$ that supports ``polymorphic
  identity function on types'', where

  \begin{enumerate}
  \item $\mathcal{S} = \{\star,\square, \square^{\prime}\}$
  \item
    $\mathcal{A} = \{(\star, \square), (\square, \square^{\prime})\}$
  \item
    $\mathcal{R} = \{(\star, \star), (\square, \star), (\square,
    \square), (\square^{\prime}, \square^{\prime})\}$
  \end{enumerate}

  in which we can have
  $\vdash (\lambda \kappa : \square.\ \lambda \alpha : \kappa.\ \alpha) :
  (\Pi \kappa : \square .\ \kappa \rightarrow \kappa)$,
  justified as follows:

\begin{prooftree}
  \AxiomC{$\mathcal{B}$} \RightLabel{\emph{Var}}
  \UnaryInfC{$\kappa : \square, \alpha : \kappa \vdash \alpha :
    \kappa$}
  \AxiomC{$\mathcal{A}$} \RightLabel{\emph{Lam}}
  \BinaryInfC{$\kappa : \square \vdash (\lambda \alpha :
    \kappa.\ \alpha) : (\Pi \alpha : \kappa.\ \kappa)$}
  \AxiomC{} \RightLabel{\emph{Ax}}
  \UnaryInfC{$\vdash \square : \square^{\prime}$}
  \AxiomC{$\mathcal{A}$} \RightLabel{\emph{Pi}}
  \BinaryInfC{$\vdash (\Pi \kappa : \square .\ \Pi \alpha :
    \kappa.\ \kappa) : \square$}
  \RightLabel{\emph{Lam}}
  \BinaryInfC{$\vdash (\lambda \kappa : \square.\ \lambda \alpha :
    \kappa.\ \alpha) : (\Pi \kappa : \square .\ \Pi \alpha :
    \kappa.\ \kappa)$}
\end{prooftree}

\begin{table}[H]
  \centering
  \begin{tabular}{ll}
    $\mathcal{A}=$ &
                     \AxiomC{$\mathcal{B}$}
                     \AxiomC{$\mathcal{B}$}
                     \AxiomC{$\mathcal{B}$}
                     \RightLabel{\emph{Weak}}
                     \BinaryInfC{$\kappa : \square , \alpha : \kappa \vdash \kappa : \square$}
                     \RightLabel{\emph{Pi}}
                     \BinaryInfC{$\kappa : \square \vdash (\Pi \alpha : \kappa.\ \kappa) : \square$} 
                     \DisplayProof \\
    $\mathcal{B}=$ & 
                     \AxiomC{}
                     \RightLabel{\emph{Ax}}
                     \UnaryInfC{$\vdash \square : \square^{\prime}$}
                     \RightLabel{\emph{Var}}
                     \UnaryInfC{$\kappa : \square \vdash \kappa : \square$}
                     \DisplayProof
  \end{tabular}
\end{table}

\end{enumerate}

\section{Extending PTSs }

\begin{comment}

This section investigates how to extend PTSs to have algebraic
datatypes, case expressions, etc.

\subsection{Algebraic Datatypes}

An algebraic datatype has the form:
\[
T \ u_{1} \dots u_{k} = K_{1} \ \alpha_{11} \dots \alpha_{1k_{1}} \ | \cdots |
K_{n} \ \alpha_{n1} \dots \alpha_{nk_{n}}
\]
where $T$ denotes a new \emph{type constructor} with zero or more
constituent \emph{data constructors} $K_{1}, \dots, K_{n}$. We call
$u_{1}, \dots, u_{k}$ the arguments of the type constructor $T$, and
$t_{j1}, \dots, t_{jk_{j}}$ the arguments of the
$K_{j} (1 \leqslant j \leqslant n)$ data constructor, whose types are
$\alpha_{j1}, \dots, \alpha_{jk_{j}}$ respectively. Each $u_{i}$ is a variable of
\emph{sort type}, each $\alpha_{jk}$ is an expression of \emph{kind type}
(i.e., $\alpha_{jk} : \star$), which may contain $T$ and
$u_{1}, \dots, u_{k}$ as free variables.

We use the following notation:
$\vec{\mathbf{u}} = [u_{1}, \dots, u_{k}]$,
$\vec{\mathbf{t}}_{j} = [t_{j1}, \dots t_{jk_{j}}]$, etc. If
$\vec{\mathbf{a}} = [a_{1}, \dots, a_{n}]$ and
$\vec{\mathbf{A}} = [A_{1}, \dots, A_{n}]$, then
$\Pi \vec{\mathbf{a}} : \vec{\mathbf{A}}.\ B$ denotes
$\Pi a_{1}:A_{1} \dots \Pi a_{n}:A_{n}.\ B$. Let
$\tau_{1},\dots,\tau_{k}$ be the types of $u_{1}, \dots, u_{k}$.

A PTS with ADTs is a tuple $(P, ADTS)$ where:

\begin{enumerate}[(i)]
\item $P$ is a Pure Type System, let $V$, $E$ be the sets of variables
  and expressions of $P$.
\item $ADTS$ is a set of ADTs, each consisting of
  $[T : T^{\prime}, K_{1} : K_{1}^{\prime}, \dots, K_{n}^{\prime}]$
  such that:
  \begin{itemize}
  \item $T, K_{j} \in V$ and $T^{\prime}, K_{j}^{\prime} \in E$, for
    every $1 \leqslant j \leqslant n$
  \item
    $T^{\prime} = \Pi \vec{\mathbf{u}} : \vec{\mathbf{\tau}}.\ \star$
  \item
    $K_{j}^{\prime} = \Pi \vec{\mathbf{u}} : \vec{\mathbf{\tau}}.\ \Pi
    \vec{\mathbf{t}}_j: \vec{\mathbf{\alpha}}_{j}.\ (T\
    \vec{\mathbf{u}}) $, for every $1 \leqslant j \leqslant n$
  \item $T : T^{\prime} \vdash K_{j} : K_{j}^{\prime} : \star$
  \end{itemize}
  Note that the use of the dependent product ($\Pi$) makes it possible
  to let the types of the data constructor arguments depend on other
  data constructor arguments.
\item (\textbf{Typability in a PTS with ADTs}) let
  $\Sigma = [c : ct \mid c : ct \leftarrow ADT, ADT \leftarrow ADTS]$,
  we say that $\Gamma \vdash_{(P,ADTS)} a : A$ if and only if
  $\Sigma \biguplus \Gamma \vdash a : A$
\end{enumerate}

\subsubsection{An Example of a PTS with ADTs}

Let $P = \lambda C$ and
\begin{align*}
  \Sigma_{a} = [&Int : \star, Zero : Int, Suc : Int \rightarrow Int,\\
                &Bool : \star, True : Bool, False : Bool]\\
  \Sigma_{b} = [&Vec : (\Pi n : Int.\ \Pi \alpha : \star.\ \star),\\
                &Nil : (\Pi \alpha : \star.\ Vec\ Zero\ \alpha),\\
                &Cons : (\Pi n : Int.\ \Pi \alpha : \star.\ \alpha \rightarrow Vec\ n\ \alpha \rightarrow Vec\ (Suc\ n)\ \alpha)]\\
  ADTS = [&\Sigma_{a}, \Sigma_{b}]
\end{align*}
then we can derive $\vdash_{(P, ADTS)}$ Cons Zero Bool True (Nil Bool) : Vec (Suc Zero) Bool

\subsection{Case Expressions}

\subsubsection{Definition}

The set of expressions $E_{c}$ of a PTS extended with ADTs and case
expressions is defined by
\begin{align*}
  A_{c} ::= x &\mid s \mid A_{c}A_{c} \mid \lambda x:A_{c}.\ A_{c} \mid \Pi x:A_{c}.\ A_{c}\\
              &\mid case\ A_{c}\ of\ \{x_{1}\ x_{2} \dots \Rightarrow
                A_{c}; \dots\}
\end{align*}

\subsubsection{Evaluation Relation}

Let $(P, ATDS)$ be a PTS extended with ADTs. The evaluation relation
$\rightarrow_{c}$ is the smallest binary relation on $A_{c}$ such that
\begin{center}
  case $(K_{j}$ $\vec{\mathbf{x}})$ of
  \{$K_{j}\ \vec{\mathbf{u}}\ \vec{\mathbf{t}}_j \Rightarrow
  res_{j}$\}
  $\rightarrow_{c} (\lambda \vec{\mathbf{u}}:\vec{\mathbf{\tau}},\
  \vec{\mathbf{t}}_j:\vec{\mathbf{\alpha}}_{j}.\ res_{j})\ \vec{\mathbf{x}}$
\end{center}
and closed under usual rules.

The evaluation relation $\rightarrow_{\beta c}$ is defined by
\[
\rightarrow_{\beta c} = \rightarrow_{\beta} \cup \rightarrow_{c}
\]

\subsubsection{Typing Relation}

The extended typing relation $\vdash_{c}$ is shown below
\begin{table}[H]
  \centering
  \small
  \begin{tabular}{lc}
    (Case) &
             \alwaysNoLine
             \AxiomC{$\Gamma \vdash_{c} e : T\ \vec{\mathbf{u^{\prime}}}$}
             \UnaryInfC{$\forall j.\Gamma \vdash_{c} K_{j}\
             \vec{\mathbf{u^{\prime}}} : \Pi \vec{\mathbf{t}}_j :
             \vec{\mathbf{\alpha}}_{j}.\ (T\ \vec{\mathbf{u^{\prime}}})$}
             \UnaryInfC{$\forall j.\Gamma,
             \vec{\mathbf{t}}_j:\vec{\mathbf{\alpha}}_{j} \vdash_{c}
             res_{j}[\vec{\mathbf{u}} := \vec{\mathbf{u^{\prime}}}] : t$}
             \UnaryInfC{$\Gamma \vdash_{c} t : s$}
             \alwaysSingleLine
             \UnaryInfC{$\Gamma \vdash_{c}$ case $e$ of \{$K_{j}\
             \vec{\mathbf{u}}\ \vec{\mathbf{t}}_j \Rightarrow
             res_{j}$\} : $t$}
             \DisplayProof \\

    (Conv) &
             \AxiomC{$\Gamma \vdash_{c} a:A$}
             \AxiomC{$\Gamma \vdash_{c} B:s$}
             \AxiomC{$A=_{\beta c} B$}
             \TrinaryInfC{$\Gamma \vdash_{c} a:B$}
             \DisplayProof
  \end{tabular}
\end{table}
the $(Conv)$ rule is extended with reduction of case expressions.

In the $(Case)$ rule, the first premise binds the actual type
constructor arguments to $\vec{\mathbf{u^{\prime}}}$. The second
premise derives the types of the data constructor arguments
$\vec{\mathbf{t}}_j$ and binds them to $\vec{\mathbf{\alpha}}_{j}$,
using the data constructor $K_{j}$ and the actual type constructor
arguments. The third premise checks whether the types of the right
hand sides, instantiated to the actual type constructor arguments, are
equal, and if so the result type is bound to $t$. Finally, the forth
premise checks whether the derived type $t$ is well formed.

\end{comment}

\subsection{Recursive types}

\subsubsection{Definition}
We extend Calculus of Constructions ($\lambda C$, see Section
\ref{sec:example}) with recursive types, namely $\lambda C_{\mu}$.
The raw expressions are extended as follows:
\begin{align*}
  A &::= x \mid \star \mid \square \\
    &\mid AA \mid \lambda x:A.A \mid \Pi x:A.A \\
    & \mid \mu x.A \mid \fold{A}{A} \mid \unfold{A}{A} \\
    & \mid \betaa{A}
\end{align*}

We introduce a new reduction rule for $\mathsf{unfold}$ and
$\mathsf{fold}$:
\[\unfold{A}{(\fold{B}{a})} \to a\]

The extended typing rules are shown in Table~\ref{tab:cocr}. Compared
with $\lambda C$, the original \emph{Conv} rule is replaced by the new
\emph{Beta} rule where the latter only performs one step of
$\beta$-reduction.

\begin{table}[h]
  \centering
  \small
  \begin{tabular}{lcl}
    (Ax) &
           \AxiomC{}
           \UnaryInfC{$\vdash \star:\square$}
           \DisplayProof \\

    (Var) &
            \AxiomC{$\Gamma \vdash A:s$}
            \UnaryInfC{$\Gamma,x:A \vdash x:A$}
            \DisplayProof &
                            $x \not \in \mathrm{dom}(\Gamma)$ \\

    (Weak) &
             \AxiomC{$\Gamma \vdash b:B$}
             \AxiomC{$\Gamma \vdash A:s$}
             \BinaryInfC{$\Gamma,x:A \vdash b:B$}
             \DisplayProof &
                             $x \not \in \mathrm{dom}(\Gamma)$ \\

    (App) &
            \AxiomC{$\Gamma \vdash f:(\Pi x:A.\ B)$}
            \AxiomC{$\Gamma \vdash a:A$}
            \BinaryInfC{$\Gamma \vdash fa:B[x:=a]$}
            \DisplayProof \\

    (Lam) &
            \AxiomC{$\Gamma,x:A \vdash b:B$}
            \AxiomC{$\Gamma \vdash (\Pi x:A.\ B):t$}
            \BinaryInfC{$\Gamma \vdash (\lambda x:A.\ b):(\Pi x:A.\ B)$}
            \DisplayProof &
                             $t \in \{\star, \square\}$ \\

    (Pi) &
           \AxiomC{$\Gamma \vdash A:s$}
           \AxiomC{$\Gamma,x:A \vdash B:t$}
           \BinaryInfC{$\Gamma \vdash (\Pi x:A.\ B):t$}
           \DisplayProof &
                           $(s,t) \in \mathcal{R}$ \\

    (Mu) &
           \AxiomC{$\Gamma,x:s \vdash A:s$}
           \UnaryInfC{$\Gamma \vdash (\mu x.A):s$}
           \DisplayProof \\

    (Fold) &
             \AxiomC{$\Gamma \vdash a:(A[x:=\mu x.A])$}
             \AxiomC{$\Gamma \vdash \mu x.A:s$}
             \BinaryInfC{$\Gamma \vdash (\fold{\mu x.A}{a}):\mu x.A$}
             \DisplayProof \\

    (Unfold) &
               \AxiomC{$\Gamma \vdash a:\mu x.A$}
               \AxiomC{$\Gamma \vdash A[x:=\mu x.A]:s$}
               \BinaryInfC{$\Gamma \vdash (\unfold{\mu x.A}{a}):A[x:=\mu x.A]$}
               \DisplayProof \\

    (Beta) &
             \AxiomC{$\Gamma \vdash a:A$}
             \AxiomC{$\Gamma \vdash B:s$}
             \AxiomC{$A \to_\beta B$}
             \TrinaryInfC{$\Gamma \vdash (\betaa{a}):B$}
             \DisplayProof

  \end{tabular}
  \caption{Typing rules for $\lambda C_{\mu}$}\label{tab:cocr}
\end{table}

\subsubsection{Examples of typable terms}

By convention, we can abbreviate a product $\Pi x:A.B$ to $A \to B$
when $x \not \in \mathrm{FV}(B)$.

\begin{itemize}
  \newcommand{\FPTypeU}{\mu\sigma . \sigma \to \alpha}
  \newcommand{\FPTermfxx}{\lambda
    x:(\FPTypeU).f((\unfold{\FPTypeU}{x})x)}
  \newcommand{\FP}{\mathsf{fix}} %
\item A polymorphic fixed-point constructor
  $\FP:(\Pi \alpha:\star.(\alpha \to \alpha) \to \alpha)$ can be
  defined as follows:
\begin{align*}
  \FP=&\lambda \alpha:\star . \lambda f:\alpha \to \alpha.\\
      &(\FPTermfxx)\\
      &(\fold{\FPTypeU}{(\FPTermfxx)})
\end{align*}
\newcommand{\HGType}{\mu\sigma. \alpha \to \sigma}%
\item Using $\FP$, we can build recursive functions. For example,
  given a ``hungry'' type $H=\HGType$, the ``hungry'' function $h$
  where
  \[h=\lambda \alpha:\star.\FP\,(\alpha \to H)\,(\lambda f:\alpha \to
  H.\lambda x:\alpha.\fold{H}{f})\]
  can take arbitrary number of arguments.
\end{itemize}

\subsection{Encoding of Datatypes}

\begin{itemize}
  \newcommand{\Nat}{\mathsf{Nat}}
  \newcommand{\List}{\mathsf{List}}
  \newcommand{\zero}{\mathsf{zero}}
  \newcommand{\suc}{\mathsf{suc}}
  \newcommand{\plus}{\mathsf{plus}}
  \newcommand{\PlFunc}{\Nat\rightarrow\Nat\rightarrow\Nat}

\item We can encode the type of natural numbers as follow:
  \[
  \Nat = \mu X.\ \Pi(a : \star).\ a \rightarrow (X \rightarrow a)
  \rightarrow a
  \]
  then we can define $\zero$ and $\suc$ as follows:
  \begin{align*}
    \zero &: \Nat \\
    \zero &= \fold{\Nat}{\lambda (a : \star) (z : a) (f : \Nat
           \rightarrow a).\ z}\\
    \suc &: \Nat \rightarrow \Nat\\
    \suc &= \lambda (n : \Nat).\ \fold{\Nat}{\lambda (a : \star) (z : a)
           (f : \Nat \rightarrow a).\ f\ n}
  \end{align*}
  Using $\mathsf{fix}$, we can define a recursive function $\plus$ as
  follow:
  \begin{align*}
    \plus &:\,\PlFunc\\
    \plus &=\,\mathsf{fix}\,(\PlFunc)\,(\lambda(p : \PlFunc)(n :
            \Nat)(m : \Nat).\\
          &\qquad (\unfold{\Nat}{n})\,\Nat\,m\,(\lambda (n^{\prime} : \Nat).\ \suc\,
            (p\,n^{\prime}\,m)))
  \end{align*}
\item We can encode the type of lists of natural numbers as follows:
  \[
  \List = \mu X.\ \Pi(a : \star).\ a \rightarrow (\Nat \rightarrow X
  \rightarrow a)
  \rightarrow a
  \]
\end{itemize}


\nocite{*} \bibliographystyle{plainnat} \bibliography{pts}

\appendix
\section{Appendix}

\begin{table}[h]
  \centering
  \small
  \begin{tabular}{lcl}
    (Ax) &
           \AxiomC{}
           \UnaryInfC{$\vdash s:t$}
           \DisplayProof &
                           $(s,t) \in \mathcal{A}$ \\

    (Var) &
            \AxiomC{$\Gamma \vdash A:s$}
            \UnaryInfC{$\Gamma,x:A \vdash x:A$}
            \DisplayProof &
                            $x \not \in \mathrm{dom}(\Gamma)$ \\

    (Weak) &
             \AxiomC{$\Gamma \vdash b:B$}
             \AxiomC{$\Gamma \vdash A:s$}
             \BinaryInfC{$\Gamma,x:A \vdash b:B$}
             \DisplayProof &
                             $x \not \in \mathrm{dom}(\Gamma)$ \\

    (App) &
            \AxiomC{$\Gamma \vdash f:(\Pi x:A.\ B)$}
            \AxiomC{$\Gamma \vdash a:A$}
            \BinaryInfC{$\Gamma \vdash fa:B[x:=a]$}
            \DisplayProof \\

    (Lam) &
            \AxiomC{$\Gamma,x:A \vdash b:B$}
            \AxiomC{$\Gamma \vdash (\Pi x:A.\ B):t$}
            \BinaryInfC{$\Gamma \vdash (\lambda x:A.\ b):(\Pi x:A.\ B)$}
            \DisplayProof \\

    (Pi) &
           \AxiomC{$\Gamma \vdash A:s$}
           \AxiomC{$\Gamma,x:A \vdash B:t$}
           \BinaryInfC{$\Gamma \vdash (\Pi x:A.\ B):u$}
           \DisplayProof &
                           $(s,t,u) \in \mathcal{R}$ \\

    (Conv) &
             \AxiomC{$\Gamma \vdash a:A$}
             \AxiomC{$\Gamma \vdash B:s$}
             \AxiomC{$A=_\beta B$}
             \TrinaryInfC{$\Gamma \vdash a:B$}
             \DisplayProof

  \end{tabular}
  \caption{Typing rules for a PTS}\label{tab:rules}
\end{table}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
